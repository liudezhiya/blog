<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="数据结构" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="[toc]" /><meta property="og:description" content="[toc]" /><link rel="canonical" href="https://liudezhiya.github.io//posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" /><meta property="og:url" content="https://liudezhiya.github.io//posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" /><meta property="og:site_name" content="番茄智" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-30T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="数据结构" /><meta name="twitter:site" content="@liudezhi" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-03-30T00:00:00+00:00","datePublished":"2022-03-30T00:00:00+00:00","description":"[toc]","headline":"数据结构","mainEntityOfPage":{"@type":"WebPage","@id":"https://liudezhiya.github.io//posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},"url":"https://liudezhiya.github.io//posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}</script><title>数据结构 | 番茄智</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="番茄智"><meta name="application-name" content="番茄智"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">番茄智</a></div><div class="site-subtitle font-italic">这里是番茄智的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/liudezhiya" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/liudezhi" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['2451456574','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>数据结构</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>数据结构</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1648598400" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/03/30 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://twitter.com/username">liudezhiya</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="12360 字"> <em>68 分钟</em>阅读</span></div></div></div><div class="post-content"><p>[toc]</p><h1 id="线性表">线性表</h1><h2 id="顺序表"><span class="mr-2">顺序表</span><a href="#顺序表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="顺序表静态分配数据类型定义"><span class="mr-2">顺序表静态分配数据类型定义</span><a href="#顺序表静态分配数据类型定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#define MaxSize 10      //定义最大长度 
</span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">ElemType</span> <span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span>  <span class="c1">//用静态的“数组”存放数据元素 </span>
    <span class="kt">int</span> <span class="n">Length</span><span class="p">;</span>         <span class="c1">//顺序表的当前长度</span>
<span class="p">}</span><span class="n">SqList</span><span class="p">;</span>                <span class="c1">//顺序表的类型定义</span>

<span class="kt">void</span> <span class="n">InitList</span><span class="p">(</span><span class="n">SqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MaxSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>   <span class="c1">//防止脏数据”</span>
    <span class="p">}</span>
    <span class="n">L</span><span class="p">.</span><span class="n">Length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>        <span class="c1">//顺序表初始长度为0</span>
<span class="p">}</span>

</pre></table></code></div></div><h3 id="顺序表动态分配数据类型定义"><span class="mr-2">顺序表动态分配数据类型定义</span><a href="#顺序表动态分配数据类型定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#define InitSize 10    //设置默认最大长度
</span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
	<span class="n">ElemType</span>  <span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="c1">//指示动态分配数组的指针</span>
	<span class="kt">int</span> <span class="n">MaxSize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">SeqList</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">InitList</span><span class="p">(</span><span class="n">SeqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//malloc申请连续的存储空间</span>
	<span class="n">L</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">InitSize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="n">L</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">L</span><span class="p">.</span><span class="n">MaxSize</span> <span class="o">=</span> <span class="n">InitSize</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="顺序表定义"><span class="mr-2">顺序表定义✨📚</span><a href="#顺序表定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#define MaxSize 10      //定义最大长度 
</span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">ElemType</span> <span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span>  <span class="c1">//用静态的“数组”存放数据元素 </span>
    <span class="kt">int</span> <span class="n">Length</span><span class="p">;</span>         <span class="c1">//顺序表的当前长度</span>
<span class="p">}</span><span class="n">SqList</span><span class="p">;</span> 
<span class="cp">#define InitSize 10    //设置默认最大长度
</span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
	<span class="n">ElemType</span>  <span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="c1">//指示动态分配数组的指针</span>
	<span class="kt">int</span> <span class="n">MaxSize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">SeqList</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="增加动态数组的长度"><span class="mr-2">增加动态数组的长度</span><a href="#增加动态数组的长度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">//增加动态数组的长度</span>
<span class="kt">void</span> <span class="nf">IncreaseSize</span><span class="p">(</span><span class="n">SeqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
    <span class="n">L</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">L</span><span class="p">.</span><span class="n">MaxSize</span><span class="o">+</span><span class="n">len</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>         <span class="c1">//将数据复制到新区域</span>
    <span class="p">}</span>
    <span class="n">L</span><span class="p">.</span><span class="n">MaxSize</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">MaxSize</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span> <span class="c1">//顺序表最大长度增加len</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>                     <span class="c1">//释放原来的内存空间</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="顺序表插入"><span class="mr-2">顺序表插入✨</span><a href="#顺序表插入" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">//在L位序为i处插入元素e</span>
<span class="n">bool</span> <span class="nf">ListInsert</span><span class="p">(</span><span class="n">SqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">){</span> 
    <span class="c1">//判断i的范围是否有效</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">||</span><span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> 
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">&gt;</span><span class="n">MaxSize</span><span class="p">)</span> <span class="c1">//当前存储空间已满，不能插入  </span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
     
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">){</span>    <span class="c1">//将第i个元素及其之后的元素后移</span>
        <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>  <span class="c1">//在位置i处放入e</span>
    <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">++</span><span class="p">;</span>      <span class="c1">//长度加1</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="顺序表删除"><span class="mr-2">顺序表删除✨</span><a href="#顺序表删除" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">bool</span> <span class="nf">ListDelete</span><span class="p">(</span><span class="n">SeqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">Element</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">){</span> <span class="c1">// e用引用型参数 </span>
    <span class="c1">//判断i的范围是否有效</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">||</span><span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> 
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>   <span class="c1">//将被删除的元素赋值给e</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>    <span class="c1">//将第i个后的元素前移  后移个数为n-i+1</span>
        <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">--</span><span class="p">;</span>      <span class="c1">//长度减1</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="顺序表查找"><span class="mr-2">顺序表查找</span><a href="#顺序表查找" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">//按值查找顺序表,找到第一个元素值等于e的位序并返回其位序</span>
<span class="kt">int</span> <span class="nf">LocateElem</span><span class="p">(</span><span class="n">SeqList</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">e</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="习题"><span class="mr-2">习题</span><a href="#习题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="1删除最小元素节点value返回"><span class="mr-2">1.删除最小元素节点，value返回</span><a href="#1删除最小元素节点value返回" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">//删除最小元素节点，value返回</span>
<span class="cm">/*查找最小值下标，用最后一个覆盖它*/</span>
<span class="n">bool</span> <span class="nf">Del_Main</span><span class="p">(</span><span class="n">SqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="n">ElemType</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">value</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//假设0号元素的值最小</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">value</span><span class="p">){</span>
            <span class="n">value</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> 
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span><span class="c1">//空出的位置由最后一个元素填补</span>
    <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="2顺序表元素逆置"><span class="mr-2">2.顺序表元素逆置🚦</span><a href="#2顺序表元素逆置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Reverse</span><span class="p">(</span><span class="n">Sqlist</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
    <span class="n">ElemType</span> <span class="n">temp</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">temp</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="3删除顺序表中所有值为x的元素"><span class="mr-2">3.删除顺序表中所有值为x的元素</span><a href="#3删除顺序表中所有值为x的元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">//删除顺序表中所有值为x的元素</span>
<span class="kt">void</span> <span class="nf">del_x</span><span class="p">(</span><span class="n">Sqlist</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">x</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//记录值不等于x的元素</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">x</span><span class="p">){</span>
            <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">k</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
   <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">k</span><span class="p">;</span>  
<span class="p">}</span>
</pre></table></code></div></div><h4 id="4从有序顺序表中删除s-t之间的所有元素"><span class="mr-2">4.从有序顺序表中删除s t之间的所有元素🎉</span><a href="#4从有序顺序表中删除s-t之间的所有元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">//从有序顺序表中删除s t之间的所有元素</span>
<span class="n">bool</span> <span class="nf">Del_st</span><span class="p">(</span><span class="n">Sqlist</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">s</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">t</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">&gt;</span><span class="n">t</span><span class="o">||</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">&amp;&amp;</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">s</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">);</span><span class="c1">//寻找大于等于s的第一个元素&lt;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//所有元素均小于s返回</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">&amp;&amp;</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">t</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">);</span><span class="c1">//寻找大于t的第一个元素&lt;=</span>
    <span class="k">for</span><span class="p">(;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="c1">//前移，填充被删除元素</span>
    <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="5从顺序表中删除s-t包括s-t之间的所有元素"><span class="mr-2">5.从顺序表中删除s t(包括s t)之间的所有元素</span><a href="#5从顺序表中删除s-t包括s-t之间的所有元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">//从顺序表中删除s t(包括s t)之间的所有元素</span>
<span class="n">bool</span> <span class="nf">Del_st</span><span class="p">(</span><span class="n">Sqlist</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">s</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">t</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//k为s t之间的元素个数</span>
    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">==</span><span class="mi">0</span><span class="o">||</span><span class="n">s</span><span class="o">&gt;=</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">s</span><span class="o">&amp;&amp;</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">t</span><span class="p">)</span>
            <span class="n">k</span><span class="o">++</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//当前元素前移k个位置</span>
    <span class="p">}</span>
    <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-=</span><span class="n">k</span><span class="p">;</span><span class="c1">//长度减少</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="6从有序顺序表中删除所有其值重复的元素"><span class="mr-2">6.从有序顺序表中删除所有其值重复的元素🚦</span><a href="#6从有序顺序表中删除所有其值重复的元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">//#### 从有序顺序表中删除所有其值重复的元素</span>
<span class="n">bool</span> <span class="nf">Delete_Same</span><span class="p">(</span><span class="n">SqList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span><span class="c1">//i存储第一个不相同元素,j为工作指针</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="c1">//查找与上一个不同的元素</span>
            <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="o">++</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="c1">//找到后前移，放到不同的后面</span>
    <span class="p">}</span>
    <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>	<span class="c1">//0开始</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="7合并有序顺序表"><span class="mr-2">7.合并有序顺序表</span><a href="#7合并有序顺序表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">//合并有序顺序表 </span>
<span class="n">bool</span> <span class="nf">Merge</span><span class="p">(</span><span class="n">SqList</span> <span class="n">A</span><span class="p">,</span><span class="n">SqList</span> <span class="n">B</span><span class="p">,</span><span class="n">SqList</span> <span class="n">c</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="o">+</span><span class="n">B</span><span class="p">.</span><span class="n">length</span><span class="o">&gt;</span><span class="n">C</span><span class="p">.</span><span class="n">maxSize</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">B</span><span class="p">.</span><span class="n">length</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">B</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">C</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
        <span class="k">else</span>
            <span class="n">C</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
        <span class="n">C</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
    <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">B</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
        <span class="n">C</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
    <span class="n">C</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">k</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="链表"><span class="mr-2">链表</span><a href="#链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="节点类型定义"><span class="mr-2">节点类型定义</span><a href="#节点类型定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">LNode</span><span class="p">{</span>
    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">LNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">LNode</span><span class="p">,</span> <span class="o">*</span><span class="n">LinkList</span><span class="p">;</span>

<span class="c1">//不带头节点初始化</span>
<span class="n">bool</span> <span class="nf">InitList</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>  <span class="c1">//注意用引用 &amp;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">//空表，暂时还没有任何结点；</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//带头结点初始</span>
<span class="n">bool</span> <span class="nf">InitList</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>  
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LNode</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>  <span class="c1">//头结点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">L</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>          <span class="c1">//内存不足，分配失败</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">L</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>       <span class="c1">//头结点之后暂时还没有结点</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="头插法"><span class="mr-2">头插法✨</span><a href="#头插法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="c1">//带头结点的头插法</span>
<span class="n">LinkList</span> <span class="nf">List_HeadInsert</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>       <span class="c1">//逆向建立单链表</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>     <span class="c1">//建立头结点</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                          <span class="c1">//初始为空链表,这步不能少！</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>                         <span class="c1">//输入要插入的结点的值</span>
    <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="p">){</span>                          <span class="c1">//输入9999表结束</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>  <span class="c1">//创建新结点</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>                         <span class="c1">//将新结点插入表中，L为头指针</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>   
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">;</span>

 <span class="c1">//向表中指定的位置pos处添加键值为key的元素</span>
<span class="kt">int</span> <span class="n">insert</span><span class="p">(</span><span class="n">Lnode</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="n">elemtype</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Lnode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">h</span><span class="p">,</span><span class="o">*</span><span class="n">s</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>     <span class="c1">//寻找第i-1号结点</span>
    <span class="p">{</span>
		<span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">j</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
		<span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">Lnode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Lnode</span><span class="p">));</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>     <span class="c1">//改变指针状态，将s插入表中</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
        <span class="k">return</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>        <span class="c1">//返回1表示正常结束</span>
    <span class="p">}</span>
    <span class="k">else</span> 
        <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>       <span class="c1">//返回0表示插入失败</span>
<span class="p">}</span>
  
    
    
<span class="c1">//不带头结点的头插法</span>
<span class="n">LinkList</span> <span class="n">List_HeadInsert</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>       <span class="c1">//逆向建立单链表</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>     <span class="c1">//建立头结点</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>                         <span class="c1">//输入要插入的结点的值</span>
	<span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> 
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                          <span class="c1">//初始为空链表,这步不能少！</span>
    <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="p">){</span>                          <span class="c1">//输入9999表结束</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>  <span class="c1">//创建新结点</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>                         <span class="c1">//将新结点插入表中，L为头指针</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>   
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">;</span>
   
<span class="p">}</span>
</pre></table></code></div></div><h3 id="尾插法"><span class="mr-2">尾插法✨</span><a href="#尾插法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">//带头结点的尾插法</span>
<span class="n">LinkList</span> <span class="nf">List_TailInsert</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>       <span class="c1">//正向建立单链表</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>                                   <span class="c1">//设ElemType为整型int</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>     <span class="c1">//建立头结点(初始化空表)</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">L</span><span class="p">;</span>                        <span class="c1">//r为表尾指针</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>                         <span class="c1">//输入要插入的结点的值</span>
    <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="p">){</span>                          <span class="c1">//输入9999表结束</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>                                <span class="c1">//r指针指向新的表尾结点</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>   
    <span class="p">}</span>
    <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                          <span class="c1">//尾结点指针置空</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//不带头结点的尾插法</span>
<span class="n">LinkList</span> <span class="nf">List_TailInsert</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>       <span class="c1">//正向建立单链表</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>                                   <span class="c1">//设ElemType为整型int</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>    
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>                         <span class="c1">//输入要插入的结点的值</span>
	<span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> 
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">L</span><span class="p">;</span>                        <span class="c1">//r为表尾指针</span>
    <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="p">){</span>                          <span class="c1">//输入9999表结束</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">LNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>                                <span class="c1">//r指针指向新的表尾结点</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>   
    <span class="p">}</span>
    <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                          <span class="c1">//尾结点指针置空</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="创建n个带头单循环链表"><span class="mr-2">创建n个带头单循环链表🚦</span><a href="#创建n个带头单循环链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">LNode</span> <span class="nf">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="n">LNode</span> <span class="n">head</span> <span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">head</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
        <span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="按序号查找结点"><span class="mr-2">按序号查找结点</span><a href="#按序号查找结点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">//按位查找 获取表L中第i个位置的元素的值</span>
<span class="n">LNode</span> <span class="o">*</span> <span class="nf">GetElem</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L</span><span class="p">;</span><span class="c1">//返回头节点</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> 
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">){</span>  <span class="c1">//循环找到第i个结点</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">j</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>         <span class="c1">//返回p指针指向的值</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="按值查找结点"><span class="mr-2">按值查找结点</span><a href="#按值查找结点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">//按值查找结点</span>
<span class="n">LNode</span> <span class="o">*</span> <span class="nf">LocateElem</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">){</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>    <span class="c1">//p指向第一个结点</span>
    <span class="c1">//从第一个结点开始查找数据域为e的结点</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">e</span><span class="p">){</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>           <span class="c1">//找到后返回该结点指针</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="5头插法原地逆序x2"><span class="mr-2">5.头插法原地逆序✨🚦📝X2</span><a href="#5头插法原地逆序x2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">LinkList</span> <span class="nf">Reverse</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">)</span><span class="c1">//LNode *Reverse(LinkList L)</span>
<span class="p">{</span>
	<span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>        <span class="c1">//p指针指向第一个结点</span>
	<span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>     <span class="c1">//头结点指向NULL</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>  <span class="c1">//依次将元素节点摘下</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>    <span class="c1">//暂存p的后继</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">//将p节点插入到头结点之后//无头节点L-&gt;next换成L</span>
		<span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">p</span><span class="o">=</span><span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">L</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="判断链表元素递增"><span class="mr-2">判断链表元素递增✨📚</span><a href="#判断链表元素递增" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">//判断链表元素递增  试卷是递减</span>
<span class="n">bool</span> <span class="nf">Judge</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">L</span><span class="p">){</span> 
	<span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>         
	<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>    
	<span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
			<span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>			
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="2删除单链表值为x的结点"><span class="mr-2">2.删除单链表值为x的结点✨📚</span><a href="#2删除单链表值为x的结点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">//删除带头结点的单链表中值为x的结点</span>
<span class="kt">void</span> <span class="nf">delX</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="o">*</span><span class="n">pre</span><span class="o">=</span><span class="n">L</span><span class="p">,</span><span class="o">*</span><span class="n">q</span><span class="p">;</span><span class="c1">//pre指向p的前驱</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">==</span><span class="n">x</span><span class="p">){</span>
				<span class="n">q</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
                <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//注意这里删除分开是保留p</span>
                <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="p">;</span> <span class="c1">//删除q节点</span>
                <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>      
           <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>			 
				<span class="n">pre</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>      <span class="c1">// pre 和 p 同步后移</span>
                <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> 
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="习题-1"><span class="mr-2">习题</span><a href="#习题-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="1递归删除不带头结点的单链表中值为x的结点"><span class="mr-2">1.递归删除不带头结点的单链表中值为x的结点</span><a href="#1递归删除不带头结点的单链表中值为x的结点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">//递归删除不带头结点的单链表中值为x的结点Y</span>
<span class="kt">void</span> <span class="nf">dex_x</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">==</span><span class="n">x</span><span class="p">){</span>
        <span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="p">;</span>
        <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">dex_x</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
        <span class="n">dex_x</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="4删除带头结点的单链表中最小值的结点"><span class="mr-2">4.删除带头结点的单链表中最小值的结点</span><a href="#4删除带头结点的单链表中最小值的结点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">//删除带头结点的单链表中最小值的结点Y</span>
<span class="n">LinkList</span> <span class="nf">Del_Min</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">pre</span><span class="o">=</span><span class="n">L</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//p为工作指针,pre指向前驱</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">minpre</span><span class="o">=</span><span class="n">pre</span><span class="p">,</span><span class="o">*</span><span class="n">minp</span><span class="o">=</span><span class="n">p</span><span class="p">;</span><span class="c1">//保存最小值节点及其前驱</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">minp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">){</span><span class="c1">//找到更小</span>
            <span class="n">minp</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
            <span class="n">minpre</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">pre</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>	<span class="c1">//继续扫描下一个节点</span>
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">minpre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">minp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	<span class="c1">//删除最小值节点</span>
    <span class="n">free</span><span class="p">(</span><span class="n">minp</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="6使带头结点单链表元素递增有序插入排序"><span class="mr-2">6.使带头结点单链表元素递增有序（插入排序）✨🚦</span><a href="#6使带头结点单链表元素递增有序插入排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">//使带头结点单链表元素递增有序Y</span>
<span class="kt">void</span> <span class="nf">Sort</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="o">*</span><span class="n">pre</span><span class="p">;</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">r</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	<span class="c1">//r保持*p后继指针保证不断链</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>		<span class="c1">//构造只含一个数据节点的有序表</span>
    <span class="n">p</span><span class="o">=</span><span class="n">r</span><span class="p">;</span>				<span class="c1">//断开一个后拿到其后面</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">r</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> 		<span class="c1">//保存*p的后继指针</span>
        <span class="n">pre</span><span class="o">=</span><span class="n">L</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
            <span class="n">pre</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//在有序表中查找插入*p的前驱节点*pre</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//将*p插入到*pre之后</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
        <span class="n">p</span><span class="o">=</span><span class="n">r</span><span class="p">;</span>			  <span class="c1">//扫描原单链表中剩下的节点</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="7删除带头结点单链表介于两值之间元素"><span class="mr-2">7.删除带头结点单链表介于两值之间元素🚦</span><a href="#7删除带头结点单链表介于两值之间元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">//7.删除带头结点单链表介于两值之间元素Y</span>
<span class="kt">void</span> <span class="nf">RangeDelete</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">min</span><span class="p">,</span><span class="kt">int</span> <span class="n">max</span><span class="p">){</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">pre</span><span class="o">=</span><span class="n">L</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	<span class="c1">//p检测指针，pre前驱</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&gt;</span><span class="n">min</span><span class="o">&amp;&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">max</span><span class="p">){</span>
            <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="n">p</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
    	<span class="k">else</span><span class="p">{</span>
            <span class="n">pre</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="9递增输出单链表各节点并删除"><span class="mr-2">9.递增输出单链表各节点并删除</span><a href="#9递增输出单链表各节点并删除" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">//9.递增输出单链表各节点并删除 Y</span>
<span class="cm">/*对链表进行遍历，每次找到整个链表最最小值元素删除*/</span>
<span class="kt">void</span> <span class="nf">MIn_Delete</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">){</span><span class="c1">//head为头指针</span>
    <span class="k">while</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span><span class="c1">//循环到仅剩头结点</span>
        <span class="n">LNode</span> <span class="o">*</span><span class="n">pre</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
                <span class="n">pre</span><span class="o">=</span><span class="n">p</span><span class="p">;</span><span class="c1">//记住当前最小节点前驱</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="n">LNode</span><span class="o">*</span> <span class="n">u</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">nexr</span><span class="p">;</span>	<span class="c1">//删除释放空间</span>
        <span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="10将a拆分为a存奇数b存偶数"><span class="mr-2">10.将A拆分为A存奇数B存偶数</span><a href="#10将a拆分为a存奇数b存偶数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="c1">//10.将A拆分为A存奇数B存偶数</span>
<span class="n">LinkList</span> <span class="nf">DisCreat_1</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">LinkList</span> <span class="n">B</span><span class="p">;</span>
    <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
    <span class="n">B</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">ra</span> <span class="o">=</span> <span class="n">A</span><span class="p">,</span><span class="o">*</span><span class="n">rb</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span>	<span class="c1">//A，B尾结点</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">A</span><span class="o">-&gt;</span><span class="n">next</span>
    <span class="n">A</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>		<span class="c1">//处理序号为偶数节点</span>
        <span class="p">{</span>
            <span class="n">rb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span><span class="c1">//表尾插入</span>
            <span class="n">rb</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span><span class="c1">//尾指针移动</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">ra</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ra</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">rb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">B</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="12删除递增单链表相同元素"><span class="mr-2">12.删除递增单链表相同元素</span><a href="#12删除递增单链表相同元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">//(7,10,10,21,30,42,42,42,51,70) -&gt;(7,10,21,30,42,51,70)</span>
<span class="kt">void</span> <span class="nf">Del_Same</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="o">*</span><span class="n">q</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">q</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">==</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);{</span> 	<span class="c1">//找到重复节点</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	<span class="c1">//释放*q节点</span>
            <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>			<span class="c1">//释放相同元素节点</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        	
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="14产生公共元素-canb"><span class="mr-2">14.产生公共元素 C=AnB</span><a href="#14产生公共元素-canb" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Get_Common</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">A</span><span class="p">,</span><span class="n">LinkList</span> <span class="n">B</span><span class="p">){</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">A</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="o">*</span><span class="n">q</span><span class="o">=</span><span class="n">B</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="o">*</span><span class="n">r</span><span class="p">,</span><span class="o">*</span><span class="n">s</span><span class="p">;</span>
    <span class="n">LinkList</span> <span class="n">C</span><span class="o">=</span><span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
    <span class="n">LNode</span> <span class="o">*</span> <span class="n">r</span><span class="o">=</span><span class="n">C</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">q</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//A的元素较小后移指针</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&gt;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
            <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//B的元素较小后移指针</span>
        <span class="k">else</span><span class="p">{</span><span class="c1">//相等</span>
            <span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">LNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNOde</span><span class="p">));</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span> 				<span class="c1">//尾插法将*s链接到C</span>
            <span class="n">r</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//同时下一个</span>
            <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="栈和队列"><span class="mr-2">栈和队列</span><a href="#栈和队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="顺序栈类型定义"><span class="mr-2">顺序栈类型定义</span><a href="#顺序栈类型定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="n">ElemType</span> 
<span class="cp">#define MaxSize 10         //定义栈中元素的最大个数
</span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">ElemType</span> <span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span>       <span class="c1">//静态数组存放栈中元素</span>
    <span class="kt">int</span> <span class="n">top</span><span class="p">;</span>                      <span class="c1">//栈顶元素</span>
<span class="p">}</span><span class="n">SqStack</span><span class="p">;</span>

<span class="c1">//初始化栈</span>
<span class="kt">void</span> <span class="nf">InitStack</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">){</span>
    <span class="n">S</span><span class="p">.</span><span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>                   <span class="c1">//初始化栈顶指针</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="顺序栈进出栈"><span class="mr-2">顺序栈进出栈</span><a href="#顺序栈进出栈" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">//入栈</span>
<span class="n">bool</span> <span class="nf">Push</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span> <span class="n">ElemType</span> <span class="n">x</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">top</span> <span class="o">==</span> <span class="n">MaxSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">//栈满</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">S</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="o">++</span><span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">////指针再加1 再入栈 </span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//出栈</span>
<span class="n">bool</span> <span class="nf">Pop</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">ElemType</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">top</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>          <span class="c1">//栈空</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="o">--</span><span class="p">];</span>     <span class="c1">//先出栈 指针再减1</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="链栈类型定义"><span class="mr-2">链栈类型定义📚</span><a href="#链栈类型定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">//栈的链式存储</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Linknode</span><span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Linknode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">Linknode</span><span class="p">,</span><span class="o">*</span><span class="n">LiStack</span><span class="p">;</span> 
 
<span class="c1">//初始化栈 </span>
<span class="kt">void</span> <span class="nf">InitStack</span><span class="p">(</span><span class="n">LiStack</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
	<span class="n">L</span> <span class="o">=</span><span class="p">(</span><span class="n">Linknode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Linknode</span><span class="p">));</span><span class="c1">//创建头节点 </span>
	<span class="c1">//L=new Linknode;</span>
	<span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>	<span class="c1">//初始化为空	</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="链栈进出栈"><span class="mr-2">链栈进出栈✨📚</span><a href="#链栈进出栈" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">//入栈    链表头插法插入一个节点</span>
<span class="n">bool</span> <span class="nf">pushStack</span><span class="p">(</span><span class="n">LiStack</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">e</span><span class="p">){</span>
	<span class="n">Linknode</span> <span class="o">*</span><span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">Linknode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Linknode</span><span class="p">));</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">//头插法</span>
	<span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">s</span><span class="p">;</span> 
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="c1">//出栈 </span>
<span class="n">bool</span> <span class="nf">popStack</span><span class="p">(</span><span class="n">LiStack</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span> <span class="c1">//栈空</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">Linknode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">e</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span> 
</pre></table></code></div></div><h3 id="顺序队列"><span class="mr-2">顺序队列</span><a href="#顺序队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">//队列的顺序存储类型</span>
<span class="cp"># define MaxSize 10;     //定义队列中元素的最大个数
</span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span> <span class="c1">//大小为MaxSize*sizeof(ElemType)</span>
    <span class="n">ElemType</span> <span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span>   <span class="c1">//用静态数组存放队列元素                       </span>
    <span class="kt">int</span> <span class="n">front</span><span class="p">,</span> <span class="n">rear</span><span class="p">;</span>          <span class="c1">//队头指针和队尾指针</span>
<span class="p">}</span><span class="n">SqQueue</span><span class="p">;</span>
<span class="c1">//初始化队列</span>
<span class="kt">void</span> <span class="nf">InitQueue</span><span class="p">(</span><span class="n">SqQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">){</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">rear</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">front</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//初始化时，队头、队尾指针指向0</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="链队存储类型"><span class="mr-2">链队存储类型</span><a href="#链队存储类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>      <span class="c1">//链式队列结点</span>
    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">LinkNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">LinkNode</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>               <span class="c1">//链式队列</span>
    <span class="n">LinkNode</span> <span class="o">*</span><span class="n">front</span><span class="p">,</span> <span class="o">*</span><span class="n">rear</span><span class="p">;</span>   <span class="c1">//队列的队头和队尾指针</span>
<span class="p">}</span><span class="n">LinkQueue</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">InitQueue</span><span class="p">(</span><span class="n">LinkQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">){</span>
    <span class="c1">//初始化时，front、rear都指向头结点</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">front</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LinkNode</span><span class="p">));</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">front</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="链式入队出队"><span class="mr-2">链式入队出队</span><a href="#链式入队出队" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1">//新元素入队 </span>
<span class="cm">/*尾插法插入一个节点*/</span>
<span class="kt">void</span> <span class="nf">EnQueue</span><span class="p">(</span><span class="n">LinkQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span> <span class="n">ElemType</span> <span class="n">x</span><span class="p">){</span>
    <span class="n">LinkNode</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LinkNode</span><span class="p">));</span> <span class="c1">//申请一个新结点</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>     <span class="c1">//s作为最后一个结点，指针域指向NULL</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>   <span class="c1">//新结点插入到当前的rear之后</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">rear</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>         <span class="c1">//表尾指针指向新的表尾</span>
<span class="p">}</span>
<span class="c1">//队头元素出队</span>
<span class="cm">/*删除链表第一个节点，最后判断是不是尾节点*/</span>
<span class="n">bool</span> <span class="nf">DeQueue</span><span class="p">(</span><span class="n">LinkQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span> <span class="n">ElemType</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span> <span class="o">==</span> <span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>             <span class="c1">//空队</span>
    <span class="n">LinkNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>  <span class="c1">//p指针指向即将删除的结点(头结点所指向的结点)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>   <span class="c1">//修改头结点的next指针     先修改好了头</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>            <span class="c1">//此次是最后一个结点出队</span>
        <span class="n">Q</span><span class="p">.</span><span class="n">rear</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">;</span>      <span class="c1">//修改rear指针</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>                   <span class="c1">//释放结点空间</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="循环链队入队出队"><span class="mr-2">循环链队入队出队🚦</span><a href="#循环链队入队出队" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">//循环队列入队 队尾插入（判满）</span>
<span class="n">bool</span> <span class="nf">EnQueue</span><span class="p">(</span><span class="n">SqQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span> <span class="n">ElemType</span> <span class="n">x</span><span class="p">){</span>
    <span class="k">if</span><span class="p">((</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MaxSize</span> <span class="o">==</span> <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">)</span>   <span class="c1">//队满</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>                 <span class="c1">//将x插入队尾</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MaxSize</span><span class="p">;</span>   <span class="c1">//队尾指针加1取模</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//出队，删除一个队头元素，用x返回</span>
<span class="n">bool</span> <span class="nf">DeQueue</span><span class="p">(</span><span class="n">SqQueue</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span> <span class="n">ElemType</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">rear</span> <span class="o">==</span> <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">)</span>              <span class="c1">//队空报错</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>  
    <span class="n">x</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">];</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MaxSize</span><span class="p">;</span> <span class="c1">//队头指针后移动</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="习题-2"><span class="mr-2">习题</span><a href="#习题-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="判断链表是否中心对称"><span class="mr-2">判断链表是否中心对称📝</span><a href="#判断链表是否中心对称" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">//判断链表是否中心对称</span>
<span class="kt">int</span> <span class="nf">dc</span><span class="p">(</span><span class="n">Linklist</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">];</span><span class="c1">//字符栈</span>
    <span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//工作指针</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="c1">//链表前一半元素进栈</span>
        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">i</span><span class="o">--</span><span class="p">;</span><span class="c1">//恢复最后i值</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	<span class="c1">//若n是奇数后移过中心节点</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">){</span><span class="c1">//检查是否中心对称</span>
        <span class="n">i</span><span class="o">--</span><span class="p">;</span>	<span class="c1">//i当栈顶指针</span>
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">//栈为空</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="十进制转八进制"><span class="mr-2">十进制转八进制🚦📝</span><a href="#十进制转八进制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Convert</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">B</span><span class="p">[]){</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="p">,</span><span class="n">p</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">p</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">clearstack</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="c1">//InitStack(S);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="mi">0</span><span class="p">){</span>
            <span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">p</span><span class="o">%</span><span class="mi">8</span><span class="p">);</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">EmptyStack</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">pop</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="串"><span class="mr-2">串</span><a href="#串" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">BF</span><span class="p">(</span><span class="n">SString</span> <span class="n">s</span><span class="p">,</span><span class="n">SString</span> <span class="n">t</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">s</span><span class="p">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">t</span><span class="p">.</span><span class="n">length</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">t</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">j</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i</span><span class="o">-</span><span class="n">t</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="树与二叉树"><span class="mr-2">树与二叉树</span><a href="#树与二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="数结构体类型定义"><span class="mr-2">数结构体类型定义</span><a href="#数结构体类型定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">//数结构体类型定义</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">BTNode</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">data</span><span class="p">;</span><span class="c1">// 这里默认结点data域为char类型</span>
	<span class="k">struct</span> <span class="n">BTNode</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span><span class="c1">// 左指针域  指针域</span>
<span class="p">}</span> <span class="n">BTNode</span><span class="p">,</span><span class="o">*</span><span class="n">BiTree</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="遍历"><span class="mr-2">遍历✨</span><a href="#遍历" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre><td class="rouge-code"><pre><span class="c1">//未运行</span>
<span class="c1">//中序非递归🚦   递归📝</span>
<span class="kt">void</span> <span class="nf">InOrder</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="n">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="c1">//BiTree* stack[MaxSize]</span>
    <span class="n">BiTree</span> <span class="n">p</span><span class="o">=</span><span class="n">T</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">||!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)){</span><span class="c1">//top != -1)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span>
            <span class="n">Push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">P</span><span class="p">);</span><span class="c1">//stack[++top]</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="n">Pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">P</span><span class="p">);</span><span class="c1">//stack[top--]</span>
            <span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="err">}</span>
<span class="c1">//先序非递归（深度遍历）</span>
<span class="kt">void</span> <span class="nf">PreOrder</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="n">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
    <span class="n">BiTree</span> <span class="n">p</span><span class="o">=</span><span class="n">T</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">||!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span>
            <span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="n">Push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">P</span><span class="p">);</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">Pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">P</span><span class="p">);</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span><span class="c1">//向右子树走</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//后序非递归🚦</span>
<span class="kt">void</span> <span class="nf">PostOrder</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="n">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
    <span class="n">BiTree</span> <span class="n">p</span><span class="o">=</span><span class="n">T</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">||!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span>
            <span class="n">Push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">GetTop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">&amp;&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">!=</span><span class="n">r</span><span class="p">)</span><span class="c1">//若存在右子树且没有被访问过</span>
                <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span><span class="c1">//转向右子树</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="n">pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
                <span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
                <span class="n">r</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>	<span class="c1">//记录最近访问过的节点</span>
                <span class="n">p</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">//每次出栈访问完一个节点相当于遍历完以该节点为根的子树</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="层次遍历"><span class="mr-2">层次遍历</span><a href="#层次遍历" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="cm">/*初始将根入队并访问根结点;
若有左子树，则将左子树的根入队;若有右子树，则将右子树的根入队;
然后出队，访问该结点;反复该过程直到队列空为止*/</span>
<span class="c1">//二叉树的结点(链式存储)</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">BiTnode</span><span class="p">{</span>
   <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>          
   <span class="k">struct</span> <span class="n">BiTNode</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span> <span class="o">*</span><span class="n">rchild</span><span class="p">;</span> 
<span class="p">}</span><span class="n">BiTNode</span><span class="p">,</span> <span class="o">*</span><span class="n">BiTree</span><span class="p">;</span>

<span class="c1">//链式队列结点</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">LinkNode</span><span class="p">{</span>
   <span class="n">BiTNode</span> <span class="o">*</span> <span class="n">data</span><span class="p">;</span>
   <span class="k">struct</span> <span class="n">LinkNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">LinkNode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
   <span class="n">LinkNode</span> <span class="o">*</span><span class="n">front</span><span class="p">,</span> <span class="o">*</span><span class="n">rear</span><span class="p">;</span>  
<span class="p">}</span><span class="n">LinkQueue</span><span class="p">;</span>

<span class="c1">//层序遍历</span>
<span class="kt">void</span> <span class="nf">LevelOrder</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
   <span class="n">LinkQueue</span> <span class="n">Q</span><span class="p">;</span>
   <span class="n">InitQueue</span> <span class="p">(</span><span class="n">Q</span><span class="p">);</span>          <span class="c1">//初始化辅助队列</span>
   <span class="n">BiTree</span> <span class="n">p</span><span class="p">;</span>
   <span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">T</span><span class="p">);</span>           <span class="c1">//将根节点入队</span>
   <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">)){</span>     <span class="c1">//队列不空则循环</span>
      <span class="n">DeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>        <span class="c1">//队头结点出队</span>
      <span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>            <span class="c1">//访问出队结点</span>
      <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
         <span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>   <span class="c1">//左孩子入队</span>
      <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
         <span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>   <span class="c1">//右孩子入队</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="线索化"><span class="mr-2">线索化</span><a href="#线索化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>中序线索化</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">//中序线索化节点</span>
<span class="k">typedef</span> <span class="n">sturct</span> <span class="n">ThreadNOde</span><span class="p">{</span>
    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ThreadNOde</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ltag</span><span class="p">,</span><span class="n">rtag</span><span class="p">;</span>
<span class="p">}</span><span class="n">ThreadNOde</span><span class="p">,</span><span class="o">*</span><span class="n">ThreadTree</span><span class="p">;</span>
<span class="c1">//中序遍历二叉树，一边遍历一遍线索化</span>
<span class="kt">void</span> <span class="nf">InThread</span><span class="p">(</span><span class="n">ThreadTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">InThread</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
        <span class="n">visit</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
        <span class="n">Inthread</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">visit</span><span class="p">(</span><span class="n">ThreadNode</span> <span class="o">*</span><span class="n">q</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">==</span><span class="n">NUll</span><span class="p">){</span><span class="c1">//左子树为空建立前驱线索</span>
        <span class="n">q</span><span class="o">-</span><span class="n">lchild</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">ltag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="n">q</span><span class="p">;</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">pre</span><span class="o">=</span><span class="n">q</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">ThreadNode</span> <span class="o">*</span><span class="n">pre</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
<span class="c1">//中序线索化二叉树T</span>
<span class="kt">void</span> <span class="nf">CreateInThread</span><span class="p">(</span><span class="n">ThreadTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="n">pre</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>		<span class="c1">//非空二叉树才能线索化</span>
        <span class="n">Inthread</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>	<span class="c1">//中序线索化二叉树</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="c1">//处理最后一个节点</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>中序线索化2</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cm">/*
左子树为空建立前驱线索，前驱右子树为空建立后继线索
*/</span>
<span class="kt">void</span> <span class="nf">Inthread</span><span class="p">(</span><span class="n">ThreadTree</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span><span class="n">ThreadTree</span> <span class="o">&amp;</span><span class="n">pre</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">InThread</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span><span class="n">pre</span><span class="p">);</span>
   		<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">==</span><span class="n">NUll</span><span class="p">){</span>						<span class="c1">//左子树为空建立前驱线索</span>
        	<span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
       	 	<span class="n">p</span><span class="o">-&gt;</span><span class="n">ltag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>			<span class="c1">//后继线索</span>
        	<span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
        	<span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="n">pre</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
        <span class="n">Inthread</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span><span class="n">pre</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//中序线索化二叉树T</span>
<span class="kt">void</span> <span class="nf">CreateInThread</span><span class="p">(</span><span class="n">ThreadTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="n">ThreadNode</span> <span class="n">pre</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>		<span class="c1">//非空二叉树才能线索化</span>
        <span class="n">Inthread</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">pre</span><span class="p">);</span>	<span class="c1">//中序线索化二叉树</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">//处理最后一个节点</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>先序线索化</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">preThread</span><span class="p">(</span><span class="n">ThreadTree</span> <span class="n">p</span><span class="p">,</span><span class="n">ThreadTree</span> <span class="o">&amp;</span><span class="n">pre</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">==</span><span class="n">NUll</span><span class="p">){</span><span class="c1">//左子树为空建立前驱线索</span>
       		<span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
       		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ltag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>
        	<span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
        	<span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="n">pre</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ltag</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span><span class="c1">//防止转圈	</span>
            <span class="n">PreThread</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span><span class="n">pre</span><span class="p">);</span>	<span class="c1">//左子树</span>
        <span class="p">}</span>
        <span class="n">PreThread</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span><span class="n">pre</span><span class="p">);</span>		<span class="c1">//右子树</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//先序线索化二叉树T</span>
<span class="kt">void</span> <span class="nf">CreateInThread</span><span class="p">(</span><span class="n">ThreadTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="n">ThreadNode</span> <span class="n">pre</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>		<span class="c1">//非空二叉树才能线索化</span>
        <span class="n">Inthread</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">pre</span><span class="p">);</span>	<span class="c1">//中序线索化二叉树</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">//处理最后一个节点</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>后序线索化</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">//后序线索化</span>
<span class="kt">void</span> <span class="nf">PostThread</span><span class="p">(</span><span class="n">BiThrTree</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PostThread</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>           <span class="c1">//左子树线索化</span>
        <span class="n">PostThread</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>           <span class="c1">//右子树线索化</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">==</span><span class="n">NUll</span><span class="p">)</span>                     <span class="c1">//前驱线索</span>
        <span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
       		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ltag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>
        	<span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
        	<span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="n">pre</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
        <span class="c1">//visit(pre-&gt;data);</span>
    <span class="p">}</span>
    
<span class="kt">void</span> <span class="n">CreateInThread</span><span class="p">(</span><span class="n">ThreadTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="n">ThreadNode</span> <span class="n">pre</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>		<span class="c1">//非空二叉树才能线索化</span>
        <span class="n">PostThread</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">pre</span><span class="p">);</span>	<span class="c1">//中序线索化二叉树</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="c1">//处理最后一个节点</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="输入创建二叉树"><span class="mr-2">输入创建二叉树</span><a href="#输入创建二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="c1">//ABC##DE##F##GH### </span>
<span class="kt">void</span> <span class="nf">CreatBiNode</span><span class="p">(</span><span class="n">BTNode</span> <span class="o">**</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//此处应注意传递的参数（二重指针）</span>
	<span class="kt">char</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%c"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="o">*</span><span class="n">Node</span> <span class="o">=</span> <span class="p">(</span><span class="n">BiTree</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BTNode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="sc">'#'</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">Node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">!=</span> <span class="sc">'#'</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">Node</span><span class="p">))</span> <span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="n">Node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">Node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">Node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">CreatBiNode</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">Node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
		<span class="n">CreatBiNode</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">Node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//构建二叉排序树，通过逐个插入法</span>
<span class="kt">int</span> <span class="n">BST_Insert</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">k</span><span class="p">){</span>   <span class="c1">//注意T前面要有引用&amp;。 </span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">T</span><span class="o">=</span><span class="p">(</span><span class="n">BiTree</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BiTNode</span><span class="p">));</span>
        <span class="n">T</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">k</span><span class="p">;</span>
        <span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">==</span><span class="n">k</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">&lt;</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="k">return</span> <span class="n">BST_Insert</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">BST_Insert</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">BST_Create</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="n">T</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">BST_Insert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

</pre></table></code></div></div><h3 id="二叉排序树插入"><span class="mr-2">二叉排序树插入📝</span><a href="#二叉排序树插入" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">BST_Insert</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="n">KeyType</span> <span class="n">k</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">T</span><span class="o">=</span><span class="p">(</span><span class="n">BiTree</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BSTNode</span><span class="p">));</span>
        <span class="n">T</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">=</span><span class="n">k</span><span class="p">;</span>
        <span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">&lt;</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BST_Insert</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">BST_Insert</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="删除"><span class="mr-2">删除🚦</span><a href="#删除" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="c1">//删除二叉排序树不小于x的节点（大于等于）</span>
<span class="kt">void</span> <span class="nf">Delete</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span><span class="c1">//右子树</span>
        <span class="n">Delelte</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchlid</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">x</span><span class="p">)</span> <span class="n">exit</span><span class="p">();</span><span class="c1">//</span>
    <span class="n">q</span><span class="o">=</span><span class="n">T</span><span class="p">;</span>
    <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>	<span class="c1">//如果树根不小于x,删除树根，并以左子树的根作为新的树根</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="n">Delete</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>  <span class="c1">//左子树</span>
<span class="p">}</span>




<span class="c1">// 非递归删除以T为根的二叉排序树</span>
<span class="kt">void</span> <span class="nf">DelTree</span><span class="p">(</span><span class="n">BSTree</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">BSTree</span> <span class="n">S</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span><span class="c1">// 栈, 容量足够大, 栈中元素是二叉排序树结点的指针</span>
    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">T</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">top</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 沿左分枝向下</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">T</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">S</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">T</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 退栈, 沿栈顶结点的右子树向下删除, 释放被删除结点空间</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">top</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">BSTree</span> <span class="n">p</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">top</span><span class="o">--</span><span class="p">];</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c1">// DelTree</span>


<span class="c1">//在二叉排序树T中, 删除所有小于等于x的结点</span>
<span class="kt">void</span> <span class="nf">DeleteAllx</span><span class="p">(</span><span class="n">BSTree</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">BSTree</span> <span class="n">p</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="c1">//根结点的值小于等于x</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span> <span class="n">T</span> <span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">T</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">DelTree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span> <span class="c1">//删除二叉树p,删除持续到“根”结点值大于x或T为空树为止</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">T</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="c1">// 沿根结点左分枝向下, 查小于等于x的结点</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// p 结点的值小于等于 x</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">q</span> <span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">DelTree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span><span class="c1">// DeleteAllx</span>

</pre></table></code></div></div><h3 id="二叉树的高度层次遍历"><span class="mr-2">二叉树的高度(层次遍历)🎉</span><a href="#二叉树的高度层次遍历" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">//递归求二叉树的高度</span>
<span class="kt">int</span> <span class="nf">Height</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">T</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">h1</span><span class="o">=</span><span class="n">Height</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">h2</span><span class="o">=</span><span class="n">Height</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">h2</span><span class="o">?</span><span class="n">h1</span><span class="o">:</span><span class="n">h2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> 

<span class="c1">//非递归求二叉树的高度，用层次遍历</span>
<span class="kt">int</span> <span class="nf">Height1</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">BiTree</span> <span class="n">Q</span><span class="p">[</span><span class="n">maxSize</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">front</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">rear</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">last</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  <span class="c1">//last=0是因为第一个元素入队后，front的值为0； </span>
        <span class="n">BiTree</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">rear</span><span class="p">]</span><span class="o">=</span><span class="n">T</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">front</span><span class="o">&lt;</span><span class="n">rear</span><span class="p">){</span>
            <span class="n">p</span><span class="o">=</span><span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">front</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">rear</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">rear</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>    
            <span class="k">if</span><span class="p">(</span><span class="n">front</span><span class="o">==</span><span class="n">last</span><span class="p">){</span>   <span class="c1">//出队元素如果是最后一个元素，层次+1，且更新last指向下一层的最后一个元素。 </span>
                <span class="n">level</span><span class="o">++</span><span class="p">;</span>
                <span class="n">last</span><span class="o">=</span><span class="n">rear</span><span class="p">;</span>    <span class="c1">//last指向下一层的最后一个结点。 </span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="n">level</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="二叉树宽度"><span class="mr-2">二叉树宽度</span><a href="#二叉树宽度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="c1">//递归</span>
<span class="kt">int</span> <span class="n">Max</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">conut_</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span><span class="c1">//count[k]数组用来储存每一层的宽度，每次递归k+1代表层次+1，</span>
<span class="kt">int</span> <span class="nf">getWidth</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">){</span> <span class="c1">//k变量为当前层数 默认从第一层开始</span>
	<span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span><span class="c1">// T为空直接返回</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">else</span>
	   <span class="n">conut_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="c1">// T不为空conut_[k]++</span>
	<span class="k">if</span><span class="p">(</span><span class="n">conut_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&gt;</span><span class="n">Max</span><span class="p">)</span>
		<span class="n">Max</span><span class="o">=</span><span class="n">conut_</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>	<span class="c1">//Max为数组的最大值</span>
	<span class="n">getWidth</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">getWidth</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Rchild</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">Max</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//非递归</span>
<span class="kt">int</span> <span class="nf">Btdepth2</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">T</span><span class="p">)</span>
	   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">font</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">rear</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">last</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">ever</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//last指向当前层的最右结点</span>
    <span class="kt">int</span> <span class="n">max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//max 保存上一层宽度，width保存本层宽度</span>
    <span class="n">BiTree</span> <span class="n">Q</span><span class="p">[</span><span class="n">Maxsize</span><span class="p">];</span><span class="c1">//初始化队列Q,元素是二叉树结点指针</span>
    <span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">rear</span><span class="p">]</span><span class="o">=</span><span class="n">T</span><span class="err">；</span>   <span class="c1">//根结点入队</span>
    <span class="n">BiTree</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">front</span><span class="o">&lt;</span><span class="n">rear</span><span class="p">){</span><span class="c1">//队不空循环</span>
    	<span class="n">p</span><span class="o">=</span><span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">front</span><span class="p">];</span>  <span class="n">width</span><span class="o">++</span>  
    	<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span>
    	   <span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">rear</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
 	    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span>
 	       <span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">rear</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">front</span><span class="o">==</span><span class="n">last</span><span class="p">){</span><span class="c1">//处理该层的最右结点</span>
		   <span class="k">if</span><span class="p">(</span><span class="n">max</span><span class="o">&lt;</span><span class="n">width</span><span class="p">)</span>
		      <span class="n">max</span><span class="o">=</span><span class="n">width</span><span class="p">;</span> <span class="c1">//若该层的宽度大于max，赋值</span>
		   <span class="n">last</span><span class="o">=</span><span class="n">rear</span><span class="p">;</span><span class="c1">//</span>
		   <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//每一层宽度置空一次</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h3 id="判断是否是完全二叉树"><span class="mr-2">判断是否是完全二叉树</span><a href="#判断是否是完全二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">isCompleted</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">T</span><span class="p">)</span><span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">BiTree</span> <span class="n">Q</span><span class="p">[</span><span class="n">maxSize</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">front</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">rear</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">BiTree</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">rear</span><span class="p">]</span><span class="o">=</span><span class="n">T</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">front</span><span class="o">&lt;</span><span class="n">rear</span><span class="p">){</span>
            <span class="n">p</span><span class="o">=</span><span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">front</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span>              <span class="c1">//结点非空，左右子树的都入队，空结点也要。 </span>
                <span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">rear</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
                <span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">rear</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="k">while</span><span class="p">(</span><span class="n">front</span><span class="o">&lt;</span><span class="n">rear</span><span class="p">){</span><span class="c1">//只要出现空结点则循环检查后面的结点是否有非空结点。 </span>
                    <span class="n">p</span><span class="o">=</span><span class="n">Q</span><span class="p">[</span><span class="o">++</span><span class="n">front</span><span class="p">];</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span><span class="c1">//后面出现不为空的则不是</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>    
<span class="p">}</span>
</pre></table></code></div></div><h3 id="以x节点为根的子树高度"><span class="mr-2">以x节点为根的子树高度🚦🎉</span><a href="#以x节点为根的子树高度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">Get_Sub_Depth</span><span class="p">(</span><span class="n">Bitree</span> <span class="n">t</span><span class="p">,</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">==</span><span class="n">x</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">Get_depth</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
        <span class="n">exit</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span> <span class="n">Get_depth</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span> <span class="n">get_depth</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">Get_Depth</span><span class="p">(</span><span class="n">Bitree</span> <span class="n">T</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">T</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">m</span><span class="o">=</span><span class="n">Get_Depth</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
        <span class="n">n</span><span class="o">=</span><span class="n">Get_Depth</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
        <span class="k">return</span><span class="p">(</span><span class="n">m</span><span class="o">&gt;</span><span class="n">n</span><span class="o">?</span> <span class="n">m</span><span class="o">:</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="判断是否是平衡二叉树"><span class="mr-2">判断是否是平衡二叉树</span><a href="#判断是否是平衡二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">//未运行</span>
<span class="kt">void</span> <span class="nf">Judge_AVL</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">bt</span> <span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">balance</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">){</span><span class="c1">//h为二叉树bt高度</span>
    <span class="kt">int</span> <span class="n">bl</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">br</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">hl</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">hr</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bt</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span><span class="c1">//bt为空树</span>
        <span class="n">h</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">balance</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">==</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span><span class="c1">//仅有根节点</span>
        <span class="n">h</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">balance</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">Judge_AVL</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span><span class="n">bl</span><span class="p">,</span><span class="n">hl</span><span class="p">);</span><span class="c1">//递归判断左子树</span>
        <span class="n">Judge_AVL</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span><span class="n">br</span><span class="p">,</span><span class="n">hr</span><span class="p">);</span><span class="c1">//递归判断右子树</span>
        <span class="n">h</span><span class="o">=</span><span class="p">(</span><span class="n">hl</span><span class="o">&gt;</span><span class="n">hr</span><span class="o">?</span> <span class="n">hl</span><span class="o">:</span><span class="n">hr</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="c1">//bt的高度为最高子树的高度+1</span>
        <span class="k">if</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">hl</span><span class="o">-</span><span class="n">hr</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">balance</span><span class="o">=</span><span class="n">br</span><span class="o">&amp;&amp;</span><span class="n">bl</span><span class="p">;</span><span class="c1">//左右子树都平衡</span>
        <span class="k">else</span>
            <span class="n">balance</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>            
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="交换左右子树"><span class="mr-2">交换左右子树🚦📝</span><a href="#交换左右子树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="c1">//把二叉树所有结点的左右子树进行交换,如果用中序遍历，恰好反序。 </span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">BiTree</span> <span class="n">temp</span><span class="p">;</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
        <span class="n">temp</span><span class="o">=</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
        <span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
        <span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> 
<span class="c1">//层次遍历互换📝</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
   <span class="n">LinkQueue</span> <span class="n">Q</span><span class="p">;</span>
   <span class="n">InitQueue</span> <span class="p">(</span><span class="n">Q</span><span class="p">);</span>          <span class="c1">//初始化辅助队列</span>
   <span class="n">BiTree</span> <span class="n">p</span><span class="p">;</span>
   <span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">T</span><span class="p">);</span>           <span class="c1">//将根节点入队</span>
   <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">)){</span>     <span class="c1">//队列不空则循环</span>
      <span class="n">DeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>        <span class="c1">//队头结点出队</span>
      <span class="c1">//visit(p);            //访问出队结点</span>
      <span class="n">BiTree</span> <span class="n">temp</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
         <span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>   <span class="c1">//左孩子入队</span>
      <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
         <span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>   <span class="c1">//右孩子入队</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="叶子节点个数"><span class="mr-2">叶子节点个数✨🚦📚🎉</span><a href="#叶子节点个数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre> <span class="c1">//叶子节点个数📚📝</span>
<span class="kt">int</span> <span class="nf">Leafcount</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">)</span>
<span class="p">{</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">T</span><span class="p">)</span> <span class="c1">//if (T == NULL)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span> <span class="c1">//tree-&gt;lchild == NULL&amp;&amp;tree-&gt;rchild == NULL</span>
	   <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">else</span>
	   <span class="k">return</span> <span class="n">Leafcount</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span> <span class="o">+</span> <span class="n">Leafcount</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//节点个数</span>
<span class="kt">int</span> <span class="nf">Nodecount1</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">)</span>
<span class="p">{</span>  <span class="k">if</span> <span class="p">(</span><span class="n">T</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
   <span class="k">else</span>
	   <span class="k">return</span> <span class="n">Nodecount1</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span> <span class="o">+</span> <span class="n">Nodecount1</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">count</span><span class="p">(</span><span class="n">blink</span> <span class="n">bt</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span><span class="n">leaf</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span>
<span class="p">{</span><span class="c1">//求二叉树的节点数和叶子数，使用传地址的方法，调用程序前，叶子数和节点数要初始化为0</span>
	<span class="k">if</span><span class="p">(</span><span class="n">bt</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="c1">//节点数增加</span>
		<span class="k">if</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">==</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">leaf</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="c1">//叶子数增加</span>
		<span class="n">count</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span><span class="n">leaf</span><span class="p">,</span><span class="n">node</span><span class="p">);</span><span class="c1">//计算左子数</span>
		<span class="n">count</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span><span class="n">leaf</span><span class="p">,</span><span class="n">node</span><span class="p">);</span><span class="c1">//计算右子树</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="c1">//双分支结点数 （递归） </span>
<span class="kt">int</span> <span class="nf">TwoBranchNum</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>         <span class="c1">//此处把n的初值设为0非常重要。！！！ </span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">T</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num1</span><span class="o">=</span><span class="n">TwoBranchNum</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">num2</span><span class="o">=</span><span class="n">TwoBranchNum</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">num1</span><span class="o">+</span><span class="n">num2</span><span class="o">+</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="判断是否是二叉排序树"><span class="mr-2">判断是否是二叉排序树✨🚦📚</span><a href="#判断是否是二叉排序树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="c1">//递归</span>
<span class="cm">/*如果二叉树为二叉排序树，那么中序遍历该树应该输出有序结果，
  每次输出的值应该比其前驱的值要大，否则不是二叉排序树 */</span>

<span class="n">KeyType</span> <span class="n">predt</span><span class="o">=-</span><span class="mi">32767</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">JudgeBST</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">bt</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">b1</span><span class="p">,</span><span class="n">b2</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bt</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span><span class="p">{</span><span class="c1">//中序遍历</span>
        <span class="n">b1</span><span class="o">=</span><span class="n">JudgeBST</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">b1</span><span class="o">==</span><span class="mi">0</span><span class="o">||</span><span class="n">predt</span><span class="o">&gt;=</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="c1">//前驱大于后面一个则不是</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">predt</span><span class="o">=</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span><span class="c1">//保留当前节点的关键字</span>
        <span class="n">b2</span><span class="o">=</span><span class="n">JudgeBST</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">b2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//非递归</span>
<span class="cp">#define max 999
#define min -999
</span><span class="kt">int</span> <span class="nf">judge</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">bt</span><span class="p">){</span>
    <span class="n">BiTNode</span> <span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="n">max</span><span class="p">],</span><span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">bt</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">top</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">preval</span><span class="o">=</span><span class="n">min</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">||</span><span class="n">top</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span>					<span class="c1">//左</span>
            <span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">p</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="n">top</span><span class="o">--</span><span class="p">];</span>
            <span class="c1">//visit(p);			//中</span>
            <span class="k">if</span><span class="p">(</span><span class="n">preval</span><span class="o">&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">preval</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>			<span class="c1">//右</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="复制一颗二叉树"><span class="mr-2">复制一颗二叉树🚦</span><a href="#复制一颗二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">btree</span> <span class="o">*</span><span class="nf">copy</span><span class="p">(</span><span class="n">btree</span> <span class="o">*</span><span class="n">b</span><span class="p">){</span>
    <span class="n">btree</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="n">btree</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">btree</span><span class="p">));</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">=</span><span class="n">copy</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">=</span><span class="n">copy</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">return</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">return</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="二颗二叉排序树合并一颗"><span class="mr-2">二颗二叉排序树合并一颗🚦</span><a href="#二颗二叉排序树合并一颗" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">//二颗二叉排序树合并一颗</span>
<span class="c1">//按照后序遍历逐个连接到另外一颗树上</span>
<span class="kt">void</span> <span class="nf">BSTreeMerge</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="n">BiTree</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">){</span>
    <span class="k">if</span><span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">))</span> <span class="n">BSTreeMerge</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span><span class="c1">//合并左子树</span>
    <span class="k">if</span><span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">))</span> <span class="n">BSTreeMerge</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span><span class="c1">//合并右子树</span>
    <span class="n">insertNode</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">S</span><span class="p">);</span>						<span class="c1">//根</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">insertNode</span><span class="p">(</span><span class="n">BiTree</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="n">BTNode</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">){</span><span class="c1">//把树节点S插入到T</span>
    <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&gt;</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span> <span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="n">S</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">insertNode</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span><span class="n">S</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span> <span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="n">S</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">insertNode</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span><span class="n">S</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">S</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="n">S</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>
</pre></table></code></div></div><h3 id="查找节点"><span class="mr-2">查找节点📚</span><a href="#查找节点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span>  <span class="n">node</span>
<span class="p">{</span>
    <span class="n">KeyType</span>  <span class="n">key</span> <span class="p">;</span> <span class="cm">/*关键字的值*/</span>
    <span class="k">struct</span> <span class="n">node</span>  <span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span><span class="cm">/*左右指针*/</span>
<span class="p">}</span><span class="n">BSTNode</span><span class="p">,</span> <span class="o">*</span><span class="n">BSTree</span><span class="p">;</span>
<span class="cm">/*在根指针bst所指二叉排序树bst上，查找关键字等于key的结点，
若查找成功，返回指向该元素结点指针，否则返回空指针*/</span>
<span class="n">BSTree</span>  <span class="nf">SearchBST</span><span class="p">(</span><span class="n">BSTree</span> <span class="n">bst</span><span class="p">,</span> <span class="n">KeyType</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="n">BSTree</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="o">=</span><span class="n">bst</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> 
            <span class="k">return</span> <span class="n">q</span><span class="p">;</span>  <span class="cm">/*查找成功*/</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">)</span>  
            <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>  <span class="cm">/*在左子树中查找*/</span>
        <span class="k">else</span>  
            <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>  <span class="cm">/*在右子树中查找*/</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/*查找失败*/</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="二叉排序树最大最小节点"><span class="mr-2">二叉排序树最大最小节点</span><a href="#二叉排序树最大最小节点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">//二叉排序树，最左下节点最小，最右下最大</span>
<span class="c1">//最小</span>
<span class="n">KeyType</span> <span class="nf">MinKey</span><span class="p">(</span><span class="n">BSTNode</span> <span class="o">*</span><span class="n">bt</span><span class="p">){</span>
    <span class="k">while</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="n">bt</span><span class="o">=</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">bt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//最大</span>
<span class="n">KeyType</span> <span class="nf">MinKey</span><span class="p">(</span><span class="n">BSTNode</span> <span class="o">*</span><span class="n">bt</span><span class="p">){</span>
    <span class="k">while</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="n">bt</span><span class="o">=</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">bt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="输出二叉排序树不小于k的关键字"><span class="mr-2">输出二叉排序树不小于k的关键字🚦</span><a href="#输出二叉排序树不小于k的关键字" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">//输出二叉排序树不小于k的关键字 未测试</span>
<span class="kt">void</span> <span class="nf">OutPut</span><span class="p">(</span><span class="n">SBTNode</span> <span class="o">*</span><span class="n">bt</span><span class="p">,</span><span class="n">KeyType</span> <span class="n">k</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bt</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="n">OutPut</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">rchlid</span><span class="p">,</span><span class="n">k</span><span class="p">);</span><span class="c1">//递归输出右子树节点</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&gt;=</span><span class="n">k</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span><span class="c1">//只输出大于等于k的节点</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="n">OutPut</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchlid</span><span class="p">,</span><span class="n">k</span><span class="p">);</span><span class="c1">//递归输出左子树节点</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="打印x节点的所有祖先路径"><span class="mr-2">打印X节点的所有祖先（路径）🚦</span><a href="#打印x节点的所有祖先路径" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="cm">/*（考几率不大）
算法思想：非递归后续遍历，最后访问根节点，访问到值为X的节点时栈中所有元素都是该节点的祖先，依次出栈打印
*/</span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">BiTree</span> <span class="n">t</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>
<span class="p">}</span><span class="n">stack</span><span class="p">;</span>	<span class="c1">//	tag=0表示左子女被访问，tag=1表示右子女被访问</span>
<span class="kt">void</span> <span class="nf">Search</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">bt</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">x</span><span class="p">){</span>
    <span class="n">stack</span> <span class="n">s</span><span class="p">[];</span>
    <span class="n">top</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">bt</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">||</span><span class="n">top</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="n">bt</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">!=</span><span class="n">x</span><span class="p">){</span>	<span class="c1">//节点入栈</span>
            <span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">].</span><span class="n">t</span><span class="o">=</span><span class="n">bt</span><span class="p">;</span>
            <span class="n">s</span><span class="p">[</span><span class="n">top</span><span class="p">].</span><span class="n">tag</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>	<span class="c1">//沿左分支向下</span>
            <span class="n">bt</span><span class="o">=</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">==</span><span class="n">x</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">top</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>	<span class="c1">//输出结束</span>
        <span class="p">}</span>
        <span class="k">while</span><span class="p">(</span><span class="n">top</span><span class="o">!=</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">top</span><span class="p">].</span><span class="n">tag</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">top</span><span class="o">--</span><span class="p">;</span>	<span class="c1">//退栈空遍历</span>
        <span class="k">if</span><span class="p">(</span><span class="n">top</span><span class="o">!=</span><span class="mi">0</span><span class="p">){</span>
            <span class="n">s</span><span class="p">[</span><span class="n">top</span><span class="p">].</span><span class="n">tag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">bt</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="n">top</span><span class="p">].</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>	<span class="c1">//沿右分支向下</span>
        <span class="p">}</span>
            
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//递归 遇到x返回true，左右子树有一方为true，返回上一层为true</span>
<span class="n">initial</span> <span class="n">stack</span><span class="p">;</span><span class="c1">//只是为了从根到节点,不要也可以</span>
<span class="n">bool</span> <span class="nf">Ancesstors</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">==</span><span class="n">x</span><span class="p">)</span><span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Ancesstors</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">||</span> <span class="n">Ancesstors</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span><span class="n">x</span><span class="p">)){</span>
        <span class="c1">//非空非x压栈</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//返回上一层</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//没找到</span>
<span class="p">}</span>
<span class="c1">//最近公共祖先</span>
<span class="n">BiTree</span> <span class="nf">getLCA</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">,</span><span class="n">BiTNode</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="n">BiTNode</span> <span class="o">*</span><span class="n">q</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="c1">//如果T为空，返回NULL</span>
	   <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">==</span><span class="n">p</span><span class="o">||</span><span class="n">T</span><span class="o">==</span><span class="n">q</span><span class="p">)</span><span class="c1">//如果T等于p或q，返回该结点</span>
       <span class="k">return</span> <span class="n">T</span><span class="p">;</span>
   	<span class="n">BiTNode</span> <span class="o">*</span><span class="n">left</span><span class="o">=</span><span class="n">getLCA</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">);</span><span class="c1">//沿着左子树遍历</span>
   	<span class="n">BiTNode</span> <span class="o">*</span><span class="n">right</span><span class="o">=</span><span class="n">getLCA</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">);</span><span class="c1">//沿着右子树遍历</span>
	<span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="o">&amp;&amp;</span><span class="n">right</span><span class="p">)</span><span class="c1">//如果左右结点都不空，找到，返回T</span>
	   <span class="k">return</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span><span class="c1">//如果左子树为空，返回右子树的查找结果</span>
       <span class="k">return</span> <span class="n">right</span><span class="p">;</span>
    <span class="k">else</span>               <span class="c1">//否则，返回左子树的查找结果</span>
       <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>根到路径</p><h3 id="19二叉树带权路径长度wpl"><span class="mr-2">19.二叉树带权路径长度WPL</span><a href="#19二叉树带权路径长度wpl" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">//类型定义</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">BiTNode</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">BiTNode</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span>
<span class="p">}</span><span class="n">BiTNode</span><span class="p">,</span><span class="o">*</span><span class="n">BiTree</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">WPL</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">root</span><span class="p">){</span>
    <span class="n">reruen</span> <span class="n">wpl_PreOrder</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">wpl_PreOrder</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">root</span><span class="p">,</span><span class="kt">int</span> <span class="n">deep</span><span class="p">){</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">wpl</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">==</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="n">wpl</span><span class="o">+=</span><span class="n">deep</span><span class="o">*</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">weigth</span><span class="p">;</span><span class="c1">//若为叶节点累积wpl</span>
    <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="n">wpl_PreOrder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span><span class="n">deep</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="n">wpl_PreOrder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span><span class="n">deep</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">wpl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="定义huffman编码的结构"><span class="mr-2">定义huffman编码的结构</span><a href="#定义huffman编码的结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">//定义huffman编码的结构 </span>
<span class="k">struct</span> <span class="nc">HuffManCode</span> <span class="p">{</span>
	<span class="err">参考树结构和遍历</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="查找"><span class="mr-2">查找</span><a href="#查找" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h4 id="顺序查找算法"><span class="mr-2">顺序查找算法</span><a href="#顺序查找算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">grade</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
<span class="p">}</span><span class="n">node</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">SeqSearch</span><span class="p">(</span><span class="n">SeqList</span> <span class="n">R</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">KeyType</span> <span class="n">k</span><span class="p">)</span> <span class="c1">//顺序查找算法</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="o">!=</span><span class="n">k</span><span class="p">)</span> 
 <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
  <span class="n">i</span><span class="o">++</span><span class="p">;</span>     <span class="c1">//从表头往后找</span>
 <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">n</span><span class="p">)</span> 
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> 
 <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
 <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="折半查找"><span class="mr-2">折半查找✨📚📝</span><a href="#折半查找" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">Binsearch</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> 
    <span class="kt">int</span> <span class="n">mid</span><span class="p">;</span> 
    <span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> 
            <span class="k">return</span> <span class="n">mid</span><span class="p">;</span> 
        <span class="p">}</span> 
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> 
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span> 
            <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> 
        <span class="p">}</span> 
    <span class="p">}</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>

<span class="c1">//递归</span>
<span class="kt">int</span> <span class="nf">Besearch</span><span class="p">(</span><span class="n">sqlist</span> <span class="n">r</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">j</span><span class="p">)</span> <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">m</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">key</span><span class="o">==</span><span class="n">k</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">key</span><span class="o">&gt;</span><span class="n">k</span><span class="p">)</span>
            <span class="k">return</span><span class="p">(</span><span class="n">Besearch</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">(</span><span class="n">Bserach</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">));</span>  
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="排序"><span class="mr-2">排序</span><a href="#排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="类型定义"><span class="mr-2">类型定义</span><a href="#类型定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#define n 10
</span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">Element</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">Element</span> <span class="n">key</span><span class="p">;</span>  <span class="c1">//主关键字</span>
<span class="p">}</span><span class="n">node</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">show</span><span class="p">(</span><span class="n">node</span> <span class="n">A</span><span class="p">[]){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%3d"</span><span class="p">,</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="插入排序"><span class="mr-2">插入排序</span><a href="#插入排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="直接插入"><span class="mr-2">直接插入✨📚</span><a href="#直接插入" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="c1">//********************************************</span>
<span class="c1">//直接插入排序    &amp;&amp;写过程</span>
<span class="c1">//********************************************</span>
<span class="kt">void</span> <span class="nf">InsertSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[])</span> <span class="p">{</span> 
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span><span class="n">temp</span><span class="p">;</span> 
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> 
		<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span> <span class="c1">//若A[i]小于前驱移到</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//有序表里</span>
				<span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="c1">//向后挪位 j的值temp保存</span>
			<span class="p">}</span>
			<span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span> 
		<span class="p">}</span>
	<span class="p">}</span> 
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Sort</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="o">*</span><span class="n">pre</span><span class="p">;</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">r</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>		<span class="c1">//r保持*p后继指针保证不断链</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>			<span class="c1">//构造只含一个数据节点的有序表</span>
    <span class="n">p</span><span class="o">=</span><span class="n">r</span><span class="p">;</span>					<span class="c1">//断开一个后拿到其后面</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">r</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> 			<span class="c1">//保存*p的后继指针</span>
        <span class="n">pre</span><span class="o">=</span><span class="n">L</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
            <span class="n">pre</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	<span class="c1">//在有序表中查找插入*p的前驱节点*pre</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	<span class="c1">//将*p插入到*pre之后</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
        <span class="n">p</span><span class="o">=</span><span class="n">r</span><span class="p">;</span>				<span class="c1">//扫描原单链表中剩下的节点</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">InsertSort</span><span class="p">(</span><span class="n">node</span> <span class="n">a</span><span class="p">[])</span> <span class="p">{</span> 
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span> 
	<span class="n">node</span> <span class="n">temp</span><span class="p">;</span> 
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> 
		<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span> 
			<span class="n">temp</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">;</span> 
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">.</span><span class="n">key</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span> 
				<span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">;</span> 
			<span class="p">}</span>
			<span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">key</span><span class="p">;</span> <span class="c1">//减后的j</span>
		<span class="p">}</span>
	<span class="p">}</span> 
<span class="p">}</span>
</pre></table></code></div></div><h4 id="折半插入"><span class="mr-2">折半插入✨📚</span><a href="#折半插入" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">//********************************************</span>
<span class="c1">//折半/二分插入排序</span>
<span class="c1">//********************************************</span>
<span class="kt">void</span> <span class="nf">BinInsertSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[]){</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">high</span><span class="p">,</span><span class="n">temp</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>		<span class="c1">//	如果采用哨兵将A[0]给哨兵循环向后加1</span>
		<span class="n">temp</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">high</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>		<span class="c1">//二分查找</span>
		<span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">){</span>
			<span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">temp</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span> 
				<span class="n">high</span><span class="o">=</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">low</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">high</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="c1">//    想象  high j| low i 停</span>
			<span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>  <span class="c1">//后移</span>
		<span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>	  <span class="c1">//插入 j和high相等</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="希尔排序"><span class="mr-2">希尔排序</span><a href="#希尔排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">//********************************************</span>
<span class="c1">//希尔排序</span>
<span class="c1">//********************************************</span>
<span class="kt">void</span> <span class="nf">ShellSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[])</span> <span class="p">{</span> 
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span><span class="n">temp</span><span class="p">,</span><span class="n">d</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">d</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">d</span><span class="o">/=</span><span class="mi">2</span><span class="p">){</span>
        <span class="c1">//// 下面的内容就是插入排序中所有的1改为d，一共有5处修改，别忘了j-=d也要改</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> 
			<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">])</span> <span class="p">{</span> 
				<span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="p">;</span> <span class="n">j</span><span class="o">-=</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span> 
					<span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">d</span><span class="p">];</span> 
				<span class="p">}</span>
				<span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span> 
			<span class="p">}</span>
		<span class="p">}</span> 
	<span class="p">}</span>
	
<span class="p">}</span>
</pre></table></code></div></div><h3 id="交换排序"><span class="mr-2">交换排序</span><a href="#交换排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="冒泡排序"><span class="mr-2">冒泡排序✨</span><a href="#冒泡排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="c1">//********************************************</span>
<span class="c1">//冒泡排序</span>
<span class="c1">//********************************************</span>
<span class="kt">void</span> <span class="nf">Bubblesort</span><span class="p">(</span><span class="n">node</span> <span class="n">A</span><span class="p">[]){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="n">node</span> <span class="n">t</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>	<span class="kt">int</span> <span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> 
                <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
				<span class="n">flag</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">show</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//双向冒泡</span>
<span class="kt">void</span> <span class="nf">BubbleSort</span><span class="p">(</span><span class="n">ElemType</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">hight</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">flag</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">&amp;&amp;</span><span class="n">flag</span><span class="p">){</span>
        <span class="n">flag</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">high</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//从前向后冒泡</span>
            <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]){</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
                <span class="n">flag</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="n">high</span><span class="o">--</span><span class="p">;</span><span class="c1">//更新上界</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">high</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="n">low</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="c1">//从后往前冒泡</span>
            <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]){</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
                <span class="n">flag</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="n">low</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="快速排序"><span class="mr-2">快速排序✨📚📝</span><a href="#快速排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre><td class="rouge-code"><pre><span class="c1">//********************************************</span>
<span class="c1">//快速排序1   要求写时间复杂度</span>
<span class="c1">//********************************************</span>
<span class="kt">int</span> <span class="nf">Partition</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">pivot</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">];</span>   <span class="c1">//枢轴</span>
	<span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span>
		<span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">pivot</span><span class="p">)</span>
			<span class="n">high</span><span class="o">--</span><span class="p">;</span>				<span class="c1">//--high</span>
		<span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">];</span> <span class="c1">//比枢轴小的元素移到左端</span>
		<span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">pivot</span><span class="p">)</span>
			<span class="n">low</span><span class="o">++</span><span class="p">;</span>				<span class="c1">//++low</span>
		<span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">];</span> <span class="c1">//比枢轴大的元素移到右端</span>
	<span class="p">}</span>
	<span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="o">=</span><span class="n">pivot</span><span class="p">;</span>  		<span class="c1">//将枢轴元素存放到最终位置</span>
	<span class="k">return</span> <span class="n">low</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span>
    <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pivotpos</span><span class="o">=</span><span class="n">Partition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
		<span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">pivotpos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//递归地对temp左边的关键字进行排序</span>
        <span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">pivotpos</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span><span class="c1">//递归地对temp右边的关键字进行排序</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//要求改变遍历方向枢轴的情况下建议用这个改</span>
<span class="c1">//********************************************</span>
<span class="c1">//快速排序2</span>
<span class="c1">//********************************************</span>
<span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="n">node</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">node</span> <span class="n">temp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">high</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">temp</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">low</span><span class="p">].</span><span class="n">key</span><span class="p">;</span><span class="c1">//记录第一个数作为枢轴</span>
        <span class="c1">//将小于枢轴的关键字放在枢轴左边，将大于枢轴的关键字放在枢轴右边</span>
        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//从右向左扫描，如果右边的数比枢轴大，位置不变，j向左移动</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="n">temp</span><span class="p">.</span><span class="n">key</span><span class="p">)</span><span class="c1">//一趟时&gt;=0</span>
                <span class="o">--</span><span class="n">j</span><span class="p">;</span>
            <span class="c1">//把要交换的关键字覆盖掉枢轴所对应的i的位置，i右移一位</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span><span class="c1">//一趟时省略</span>
            <span class="p">{</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
                <span class="o">++</span><span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">//从左往右扫描，如果左边的数枢轴小，位置不变，i向右移动</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;=</span> <span class="n">temp</span><span class="p">.</span><span class="n">key</span><span class="p">)</span><span class="c1">//一趟时&lt;0</span>
                <span class="o">++</span><span class="n">i</span><span class="p">;</span>
            <span class="c1">//把要交换的关键字覆盖掉枢轴所对应的j的位置，j左移一位</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span><span class="c1">//一趟时a[i],a[j]交换</span>
            <span class="p">{</span>
                <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
                <span class="o">--</span><span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">key</span><span class="p">;</span><span class="c1">//把枢轴的空缺补上</span>
            <span class="n">QuickSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//递归地对temp左边的关键字进行排序</span>
            <span class="n">QuickSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span><span class="c1">//递归地对temp右边的关键字进行排序</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="选择排序"><span class="mr-2">选择排序</span><a href="#选择排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="选择排序-1"><span class="mr-2">选择排序🚦📝</span><a href="#选择排序-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre><td class="rouge-code"><pre><span class="c1">//********************************************</span>
<span class="c1">//直接选择排序</span>
<span class="c1">//********************************************</span>
<span class="kt">void</span> <span class="nf">selectsort</span><span class="p">(</span><span class="n">node</span> <span class="n">A</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">min</span><span class="p">;</span>
    <span class="n">node</span> <span class="n">t</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">min</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="c1">//寻找本轮中的最小值</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">].</span><span class="n">key</span><span class="o">&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="c1">//记下最小值的位置</span>
                <span class="n">min</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//把DATA[i]和最小值DATA[k]交换</span>
        <span class="k">if</span><span class="p">(</span><span class="n">min</span><span class="o">!=</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span><span class="n">t</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">];</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">]</span><span class="o">=</span><span class="n">t</span><span class="p">;}</span>
    <span class="p">}</span>
    <span class="n">show</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">Lnode</span><span class="p">,</span><span class="o">*</span><span class="n">link</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">Selctsort</span><span class="p">(</span><span class="n">link</span> <span class="n">L</span><span class="p">){</span>
    <span class="n">link</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">minp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
    <span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">minp</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
        <span class="n">q</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">minp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
                <span class="n">minp</span><span class="o">=</span><span class="n">q</span><span class="p">;</span>
            <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&gt;</span><span class="n">minp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">){</span><span class="c1">//换值</span>
            <span class="n">temp</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">minp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">mip</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>





<span class="c1">//每次找出最大节点，头插法到头部 -&gt;升序排序 或每次找出最小节点，尾插法</span>
<span class="kt">void</span> <span class="nf">selectSort</span><span class="p">(</span><span class="n">LinkedList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
    <span class="c1">//对不带头结点的单链表L执行简单选择排序</span>
    <span class="n">LinkNode</span> <span class="o">*</span><span class="n">h</span><span class="o">=</span><span class="n">L</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="o">*</span><span class="n">pre</span><span class="p">,</span><span class="o">*</span><span class="n">maxp</span><span class="p">,</span><span class="o">*</span><span class="n">maxpre</span><span class="p">;</span>
    <span class="n">L</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">h</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">p</span><span class="o">=</span><span class="n">maxp</span><span class="o">=</span><span class="n">h</span><span class="p">;</span><span class="n">pre</span><span class="o">=</span><span class="n">maxpre</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="c1">//maxp和maxpre记忆最大节点和其前驱 p为工作指针，pre为前驱</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&gt;</span><span class="n">maxp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">){</span><span class="c1">//找最大节点</span>
                <span class="n">maxp</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
                <span class="n">maxpre</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">pre</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">maxp</span><span class="o">==</span><span class="n">h</span><span class="p">)</span>					<span class="c1">//	换节点</span>
            <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>				<span class="c1">//最大节点在原链表前端无序第一个</span>
        <span class="k">else</span>
            <span class="n">maxpre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">maxp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	<span class="c1">//最大节点在原链表表内，断开P节点</span>
        <span class="n">maxp</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">L</span><span class="p">;</span>					<span class="c1">//节点s头插法插入结果链前端</span>
        <span class="n">L</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="堆排序"><span class="mr-2">堆排序</span><a href="#堆排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="c1">//手写过程p315</span>
<span class="c1">//对初始序列建立大根堆</span>
<span class="kt">void</span> <span class="nf">BuildMaxHeap</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>   <span class="c1">//从后往前调整所有非终端结点</span>
        <span class="n">HeadAdjust</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*将以k为根的子树调整为大根堆
从最底层的分支结点开始调整*/</span>
<span class="kt">void</span> <span class="nf">HeadAdjust</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>                      <span class="c1">//A[0]暂存子树的根结点</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">*=</span><span class="mi">2</span><span class="p">){</span>     <span class="c1">//沿key较大的子结点向下筛选</span>
                                      <span class="c1">// i为当前所选根结点的左孩子</span>
                                      <span class="c1">//i*=2是为了判断调整后再下一层是否满足大根堆</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>      <span class="c1">//判断：当前所选根结点的左、右结点哪个更大</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>                      <span class="c1">//取key较大的子结点的下标</span>
        <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
            <span class="k">break</span><span class="p">;</span>                    <span class="c1">//筛选结束：i指向更大的子结点</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>              <span class="c1">//将A[i]调整至双亲结点上</span>
            <span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>                      <span class="c1">//修改k值，以便继续向下筛选</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>                      <span class="c1">//被筛选的结点的值放入最终位置</span>
<span class="p">}</span>

<span class="c1">//交换</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//基于大根堆进行排序</span>
<span class="kt">void</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
    <span class="n">BuildMaxHeap</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>          <span class="c1">//初始建堆</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>      <span class="c1">//n-1趟的交换和建堆过程</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>          <span class="c1">//堆顶元素和堆底元素交换</span>
        <span class="n">HeadAdjust</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>       <span class="c1">//把剩余的待排序元素整理成堆</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="归并排序"><span class="mr-2">归并排序✨📚📝</span><a href="#归并排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">//********************************************</span>
<span class="c1">//归并排序 </span>
<span class="c1">//********************************************</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">B</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  <span class="kt">void</span> <span class="nf">Merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="kt">int</span> <span class="n">mid</span><span class="p">,</span><span class="kt">int</span> <span class="n">high</span><span class="p">){</span>
	  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
	  <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">low</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
		  <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>       <span class="c1">//将A元素复制到B</span>
	  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
		  <span class="k">if</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>   <span class="c1">//比较B左右两段</span>
			  <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span> <span class="c1">//将较小值复制到A中</span>
		  <span class="k">else</span>
			  <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
	  <span class="p">}</span>
	  <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">)</span>   <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span><span class="c1">//检测第一个表</span>
	  <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">)</span>  <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span> <span class="c1">//检测第二个表</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="kt">int</span> <span class="n">high</span><span class="p">){</span>
	  <span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span>
		  <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
		  <span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span>
		  <span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
		  <span class="n">Merge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>

	  <span class="p">}</span>
  <span class="p">}</span>
</pre></table></code></div></div><h3 id="2020"><span class="mr-2">2020</span><a href="#2020" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>一、算法分析题(70 分)</p><p>1、一个栈 s 进行如下操作, push(1), push(2), pop(), push(3), pop(), push(4),</p><p>pop(), push(5), pop().求最终输出的序列。(10 分)</p><p>```2,3,4,5 栈中留有1 2,3,4,5 栈中留有1</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
</pre><td class="rouge-code"><pre>
2、某二叉树的先序遍历为 ABHFDECKG，中序遍历为 HBDFAEKCG，画出该二叉 

树。(10 分)

 &lt;img src="D:\数据结构\IMG\1png" alt="1634296582293" style="zoom:50%;" /&gt;

3、给出一个图，根据图采j用 Prim 算法画出一个生成子图，要求给出每一步的执 

行过程。(10 分)

 &lt;img src="D:\数据结构\IMG\3.png" style="zoom:80%;" /&gt;

&lt;img src="D:\数据结构\IMG\3.1.png" alt="3.1" style="zoom:50%;" /&gt;

4、将给定的关键字集{47,7,29,11,16,92,22,8,3,18,27,25,40}用长度为 13 的哈希  p&lt;=13 

表存储，用线性探测法处理冲突。画出该哈希表，并求出该表的 ASL。(10 分)

5、根据给定的 a-g 的概率构造霍夫曼树并求其编码（权值小的在左边）。(10 分) &lt;img src="D:\数据结构\IMG\2.PNG" style="zoom: 67%;" /&gt;

6、记录的关键字序列为{63,90,70,55,67,42,98,83,10,45,58}，画出给定序列的二 

叉排序树，并画出删除结点 70 之后的排序树。(10 分) 

&lt;img src="D:\数据结构\IMG\4.png" alt="4" style="zoom:50%;" /&gt;

&lt;img src="D:\数据结构\IMG\5.png" style="zoom:50%;" /&gt;

7、写出给定序列{67,38,29,56,53,95,48,12}的递增快速排序的每一趟排序的结果。 

(10 分) 

​      67,38,29,56,53,95,48,12

1️⃣	[12,38,29,56,53,48],67,[95]

2️⃣	12,[38,29,56,53,48],67,[95]

3️⃣	12,29,[38],[56,53,48],67,[95]

4️⃣	12,29,38,[56,53,48],67,[95]

5️⃣	12,29,38,[48,53],56,67,[95]

6️⃣	12,29,38,48,[53],56,67,[95]

7️⃣	12,29,38,48,53,56,67,[95]

8️⃣	12,29,38,48,53,56,67,95

二、算法设计题(80 分) 

1.、写出顺序表的结构体，并设计在顺序表 L 中第 pos 位置上插入一个元素 e 的 

算法，默认数据类型为整型。(15 分) 

```c
#define MaxSize 10      //定义最大长度 
typedef struct{
    ElemType data[MaxSize];  //用静态的“数组”存放数据元素 
    int Length;         //顺序表的当前长度
}SqList; 
//在L位序为i处插入元素e
bool ListInsert(SqList &amp;L, int i, int e){ 
    //判断i的范围是否有效
    if(i&lt;1||i&gt;L.length+1) 
        return false;
    if(L.length&gt;MaxSize) //当前存储空间已满，不能插入  
        return false;
     
    for(int j=L.length; j&gt;i; j--){    //将第i个元素及其之后的元素后移
        L.data[j]=L.data[j-1];
    }
    L.data[i-1]=e;  //在位置i处放入e
    L.length++;      //长度加1
    return true;
}
</pre></table></code></div></div><p>2、写出链表的结构体，并设计在链表中删除指定元素 e 的算法，假设元素 e 在链</p><p>表之中，默认数据类型为整型。(15 分)</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">LNode</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">LNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">LNode</span><span class="p">,</span> <span class="o">*</span><span class="n">LinkList</span><span class="p">;</span>
<span class="c1">//删除带头结点的单链表中值为x的结点</span>
<span class="kt">void</span> <span class="nf">delX</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">e</span><span class="p">){</span>
    <span class="n">LNode</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="o">*</span><span class="n">pre</span><span class="o">=</span><span class="n">L</span><span class="p">,</span><span class="o">*</span><span class="n">q</span><span class="p">;</span><span class="c1">//pre指向p的前驱</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">==</span><span class="n">e</span><span class="p">){</span>
				<span class="n">q</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
                <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//注意这里删除分开是保留p</span>
                <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">p</span><span class="p">;</span> <span class="c1">//删除q节点</span>
                <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>      
           <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>			 
				<span class="n">pre</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>      <span class="c1">// pre 和 p 同步后移</span>
                <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> 
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>3、设计一个算法将给定的十进制数转化为二进制数。给定默认操作 Initial_stack()；</p><p>Is_ empty_stack(s)；Push()；Pop()，利用这几个栈操作实现。(15 分)</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Convert</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="n">Initial_stack</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">Push</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">p</span><span class="o">%</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">Is_</span> <span class="n">empty_stack</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
          <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">Pop</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>4、设计在二叉排序树中查找结点值为 e 的算法。(15 分)</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span>  <span class="n">node</span>
<span class="p">{</span>
    <span class="n">KeyType</span>  <span class="n">key</span> <span class="p">;</span> <span class="cm">/*关键字的值*/</span>
    <span class="k">struct</span> <span class="n">node</span>  <span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span><span class="cm">/*左右指针*/</span>
<span class="p">}</span><span class="n">BSTNode</span><span class="p">,</span> <span class="o">*</span><span class="n">BSTree</span><span class="p">;</span>

<span class="n">BSTree</span>  <span class="nf">SearchBST</span><span class="p">(</span><span class="n">BSTree</span> <span class="n">T</span><span class="p">,</span> <span class="n">KeyType</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="n">BSTree</span> <span class="n">p</span><span class="o">=</span><span class="n">T</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> 
            <span class="k">return</span> <span class="n">q</span><span class="p">;</span>  <span class="cm">/*查找成功*/</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">)</span>  
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>  <span class="cm">/*在左子树中查找*/</span>
        <span class="k">else</span>  
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>  <span class="cm">/*在右子树中查找*/</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/*查找失败*/</span>
<span class="p">}</span>
</pre></table></code></div></div><p>5、设计将 a[n]数组采用归并方式排序的算法。(20 分)</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">//********************************************</span>
<span class="c1">//归并排序 </span>
<span class="c1">//********************************************</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">B</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  <span class="kt">void</span> <span class="nf">Merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="kt">int</span> <span class="n">mid</span><span class="p">,</span><span class="kt">int</span> <span class="n">high</span><span class="p">){</span>
	  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
	  <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">low</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
		  <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>       <span class="c1">//将A元素复制到B</span>
	  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
		  <span class="k">if</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>   <span class="c1">//比较B左右两段</span>
			  <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span> <span class="c1">//将较小值复制到A中</span>
		  <span class="k">else</span>
			  <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
	  <span class="p">}</span>
	  <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">)</span>   <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span><span class="c1">//检测第一个表</span>
	  <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">)</span>  <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span> <span class="c1">//检测第二个表</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="kt">int</span> <span class="n">high</span><span class="p">){</span>
	  <span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span>
		  <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
		  <span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span>
		  <span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
		  <span class="n">Merge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>

	  <span class="p">}</span>
  <span class="p">}</span>
</pre></table></code></div></div><h3 id="2021"><span class="mr-2">2021</span><a href="#2021" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>1.写顺序表类型定义，顺序表的插入和删除。</p><p>2.写链式堆栈类型定义，编程写出入栈和出栈。</p><p>3.给定权集，构造哈夫曼树，求加权路径长度。</p><p>4.给出序列，构造画出二叉排序树，删除其中一个节点后的二叉排序树。</p><p><strong>中序前驱或者后继补</strong></p><p>5.有图，邻接矩阵，画图。利用普里姆算法写出最小生成树，利用 Dijkstra 算法求各 结点的最短路径。</p><p>6.有向图，画图写出所有拓扑结构。例</p><p><img data-src="D:\数据结构\IMG\拓扑排序.png" style="zoom:50%;" data-proofer-ignore></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>拓扑序列 
ABCFDEG,ABCDFEG,ABCDEFG,ABDCFEG,ABDCEFG
</pre></table></code></div></div><p>7.给出序列，利用归并排序和插入排序，在序列中进行升序排序。写过程。</p><p>8.写快排的代码，求时间复杂度。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>把n个元素组织成二叉树，二叉树的层数就是递归调用的层数，n个结点的二叉树最小高度 = ⌊log₂n⌋ + 1, 最大高度 = n

时间复杂度 = O(n×递归层数) （递归层数最大为n）

最好 = O(nlog₂n) : 每次选的枢轴元素都能将序列划分成均匀的两部分；
最坏 = O(n²) ：序列本就有序或逆序，此时时间、空间复杂度最高；
平均时间复杂度 = O(nlog₂n) （接近最好而不是最坏）
</pre></table></code></div></div><p>9.给出哈希表，哈希函数，权值序列，求利用线性探测法处理冲突的哈希表，求成功查找情况下平均最短路径。</p><p>2022</p><p>1.时间复杂度</p><p>2.插入算法</p><p>3.遍历序列</p><p>4.二叉树转森林</p><p>5.哈夫曼树和路径编码</p><p>6.普里姆和克鲁斯卡尔</p><p>7.线性探测成功概率</p><p>8.快速排序</p><h1 id="2022">2022</h1><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>1.时间复杂度
2.在线性表某个位置出入一个元素（好像是找到一个然后后移进行插入）
3.二叉树遍历序列（前中后层次）  二叉树转森林和二叉树转树的互相转化
4.构造哈夫曼树，哈夫曼编码
8.求最小生成树 克鲁斯卡尔和普里姆，最短路径 迪杰斯特拉和弗洛伊德（一般没代码）
9.线性探测构造 求成功和不成功概率
10.快速排序
</pre></table></code></div></div><h2 id="图例"><span class="mr-2">图例</span><a href="#图例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>✨ 考过</p><p>🚦参考书习题有</p><p>📚改后考过</p><p>📝期末考试出现过</p></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84+-+%E7%95%AA%E8%8C%84%E6%99%BA&url=https%3A%2F%2Fliudezhiya.github.io%2F%2Fposts%2F%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84+-+%E7%95%AA%E8%8C%84%E6%99%BA&u=https%3A%2F%2Fliudezhiya.github.io%2F%2Fposts%2F%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fliudezhiya.github.io%2F%2Fposts%2F%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%2F&text=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84+-+%E7%95%AA%E8%8C%84%E6%99%BA" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/gephi%E4%BD%9C%E8%80%85%E7%BD%91%E7%BB%9C%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96/">java基础总结</a><li><a href="/posts/hello/">复杂网络概念</a><li><a href="/posts/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">java基础总结</a><li><a href="/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><li><a href="/posts/matlab/">matlab</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%88%86%E7%B1%BB/">分类</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/matlab/"><div class="card-body"> <em class="small" data-ts="1658370840" data-df="YYYY/MM/DD" > 2022/07/21 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>matlab</h3><div class="text-muted small"><p> python绘图 1 ‘r - o’ 和 ‘g - -’。字母 ‘r’ 和 ‘g’ 代表线条的颜色，后面的符号代表线和点标记的类型。 颜色： 蓝色 - ‘b’ 绿色 - ‘g’ 红色 - ‘r’ 青色 - ‘c’ 品红 - ‘m’ 黄色 - ‘y’ 黑色 - ‘k’（’b’代表蓝色，所以这里用黑色的最后一个字母） 白色 - ‘w’ 线： 直线 ‘-’ 虚线 ‘–’...</p></div></div></a></div><div class="card"> <a href="/posts/DataFrame%E6%93%8D%E4%BD%9C/"><div class="card-body"> <em class="small" data-ts="1658288040" data-df="YYYY/MM/DD" > 2022/07/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DataFrame操作</h3><div class="text-muted small"><p> ### [TOC] pandas常用的数据查看方法有 方法 操作 结果 head(n) 查看数据集对象的前n行 Series或DataFrame tail(n) 查看数据集的最后n行 Series或DataFr...</p></div></div></a></div><div class="card"> <a href="/posts/networkx%E7%BB%98%E5%9B%BE/"><div class="card-body"> <em class="small" data-ts="1657929600" data-df="YYYY/MM/DD" > 2022/07/16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Networkx绘图</h3><div class="text-muted small"><p> 数据处理 1.提取文件中只含有项目编号的一列数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 &#39;&#39;&#39;提取项目编号&#39;&#39;&#39; #file 文件名字 #row_name 列名 #返回项目编号字典 def fund_number(file,row_name): data = pd.read_csv(file) fund = data[row_name].t...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E5%A4%8D%E8%AF%95C%E8%AF%AD%E8%A8%80/" class="btn btn-outline-primary" prompt="上一篇"><p>复试c语言</p></a> <a href="/posts/Java%E5%9F%BA%E7%A1%80/" class="btn btn-outline-primary" prompt="下一篇"><p>Java基础</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%88%86%E7%B1%BB/">分类</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">liudezhiya</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
