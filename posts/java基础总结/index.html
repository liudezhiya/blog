<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="java基础总结" /><meta name="author" content="刘德智" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="[TOC]" /><meta property="og:description" content="[TOC]" /><link rel="canonical" href="https://liudezhiya.github.io//posts/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" /><meta property="og:url" content="https://liudezhiya.github.io//posts/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" /><meta property="og:site_name" content="番茄智" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-26T02:34:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="java基础总结" /><meta name="twitter:site" content="@liudezhi" /><meta name="twitter:creator" content="@刘德智" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"刘德智"},"dateModified":"2022-11-01T10:35:28+00:00","datePublished":"2022-03-26T02:34:00+00:00","description":"[TOC]","headline":"java基础总结","mainEntityOfPage":{"@type":"WebPage","@id":"https://liudezhiya.github.io//posts/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},"url":"https://liudezhiya.github.io//posts/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"}</script><title>java基础总结 | 番茄智</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="番茄智"><meta name="application-name" content="番茄智"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">番茄智</a></div><div class="site-subtitle font-italic">这里是番茄智的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/liudezhiya" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/liudezhi" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['2451456574','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>java基础总结</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>java基础总结</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1648262040" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/03/26 </em> </span> <span> 更新于 <em class="" data-ts="1667298928" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/11/01 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7352 字"> <em>40 分钟</em>阅读</span></div></div></div><div class="post-content"><p>[TOC]</p><h1 id="位运算符">位运算符</h1><p>位运算符都是操作的都是整形的数据</p><p>«左移一位相当于*2；</p><p>«右移一位相当于/2</p><h1 id="单例设计模式">单例设计模式：</h1><ul><li><ol><li>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</ol><li><li><ol><li>如何实现？</ol><li><p>饿汉式 vs 懒汉式</p><li><li><ol><li>区分饿汉式 和 懒汉式</ol><li><p>饿汉式：</p><li><p>坏处：对象加载时间过长。</p><li><p>好处：饿汉式是线程安全的</p><li><li><p>懒汉式：好处：延迟对象的创建。</p><li><p>目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonTest1</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">//		Bank bank1 = new Bank();</span>
<span class="c1">//		Bank bank2 = new Bank();</span>
   		
		<span class="nc">Bank</span> <span class="n">bank1</span> <span class="o">=</span> <span class="nc">Bank</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
		<span class="nc">Bank</span> <span class="n">bank2</span> <span class="o">=</span> <span class="nc">Bank</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
   		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bank1</span> <span class="o">==</span> <span class="n">bank2</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
   
<span class="c1">//饿汉式</span>
<span class="kd">class</span> <span class="nc">Bank</span><span class="o">{</span>
   	
	<span class="c1">//1.私有化类的构造器</span>
	<span class="kd">private</span> <span class="nf">Bank</span><span class="o">(){</span>
   		
	<span class="o">}</span>
   	
	<span class="c1">//2.内部创建类的对象</span>
	<span class="c1">//4.要求此对象也必须声明为静态的</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">Bank</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Bank</span><span class="o">();</span>
   	
	<span class="c1">//3.提供公共的静态的方法，返回类的对象</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Bank</span> <span class="nf">getInstance</span><span class="o">(){</span>
		<span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
   
   
<span class="cm">/*
 * 单例模式的懒汉式实现
 * 
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonTest2</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
   		
		<span class="nc">Order</span> <span class="n">order1</span> <span class="o">=</span> <span class="nc">Order</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
		<span class="nc">Order</span> <span class="n">order2</span> <span class="o">=</span> <span class="nc">Order</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
   		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">order1</span> <span class="o">==</span> <span class="n">order2</span><span class="o">);</span>
   		
	<span class="o">}</span>
<span class="o">}</span>
   
   
<span class="kd">class</span> <span class="nc">Order</span><span class="o">{</span>
   	
	<span class="c1">//1.私有化类的构造器</span>
	<span class="kd">private</span> <span class="nf">Order</span><span class="o">(){</span>
   		
	<span class="o">}</span>
   	
	<span class="c1">//2.声明当前类对象，没有初始化</span>
	<span class="c1">//4.此对象也必须声明为static的</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">Order</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
   	
	<span class="c1">//3.声明public、static的返回当前类对象的方法</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Order</span> <span class="nf">getInstance</span><span class="o">(){</span>
   		
		<span class="k">if</span><span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
   			
			<span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">();</span>
   			
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
	<span class="o">}</span>
   	
<span class="o">}</span>
</pre></table></code></div></div><h1 id="创建多线程四种方式">创建多线程四种方式</h1><h3 id="方式一-继承thread类"><span class="mr-2">方式一-继承Thread类</span><a href="#方式一-继承thread类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">方式一</span><span class="err">：</span><span class="n">继承Thread类的方式</span><span class="err">：</span>
<span class="o">*</span> <span class="mi">1</span><span class="o">.</span> <span class="n">创建一个继承于Thread类的子类</span>
<span class="o">*</span> <span class="mi">2</span><span class="o">.</span> <span class="n">重写Thread类的run</span><span class="o">()</span> <span class="o">--&gt;</span> <span class="n">将此线程执行的操作声明在run</span><span class="o">()</span><span class="n">中</span>
<span class="o">*</span> <span class="mi">3</span><span class="o">.</span> <span class="n">创建Thread类的子类的对象</span>
<span class="o">*</span> <span class="mi">4</span><span class="o">.</span> <span class="n">通过此对象调用start</span><span class="o">()</span><span class="err">：①</span><span class="n">启动当前线程</span> <span class="err">②</span> <span class="n">调用当前线程的run</span><span class="o">()</span>
       
<span class="n">说明两个问题</span><span class="err">：</span>
<span class="n">问题一</span><span class="err">：</span><span class="n">我们启动一个线程</span><span class="err">，</span><span class="n">必须调用start</span><span class="o">()</span><span class="err">，</span><span class="n">不能调用run</span><span class="o">()</span><span class="n">的方式启动线程</span><span class="err">。</span>
<span class="n">问题二</span><span class="err">：</span><span class="n">如果再启动一个线程</span><span class="err">，</span><span class="n">必须重新创建一个Thread子类的对象</span><span class="err">，</span><span class="n">调用此对象的start</span><span class="o">().</span>
</pre></table></code></div></div><h3 id="方式二-实现runnable接口"><span class="mr-2">方式二-实现Runnable接口</span><a href="#方式二-实现runnable接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>方式二：实现Runnable接口的方式：
* 1. 创建一个实现了Runnable接口的类
* 2. 实现类去实现Runnable中的抽象方法：run()
* 3. 创建实现类的对象
* 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
* 5. 通过Thread类的对象调用start()
   
两种方式的对比：
* 开发中：优先选择：实现Runnable接口的方式
* 原因：1. 实现的方式没类的单继承性的局限性
*      2. 实现的方式更适合来处理多个线程共享数据的情况。
*
* 联系：public class Thread implements Runnable
* 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。
          目前两种方式，要想启动线程，都是调用的Thread类中的start()。
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre>1.背景
例子：创建个窗口卖票，总票数为100张.使用实现Runnable接口的方式
*
* 1.问题：卖票过程中，出现了重票、错票 --&gt;出现了线程的安全问题
* 2.问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。
* 3.如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。
   
2.Java解决方案：同步机制
在Java中，我们通过同步机制，来解决线程的安全问题。
   
方式一：同步代码块
*
*   synchronized(同步监视器){
*      //需要被同步的代码
*
*   }
*  说明：1.操作共享数据的代码，即为需要被同步的代码。  --&gt;不能包含代码多了，也不能包含代码少了。
*       2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。
*       3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。
*          要求：多个线程必须要共用同一把锁。
*
* 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。
       在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。
   
*  方式二：同步方法
*     如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。
   
*  关于同步方法的总结：
*  1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。
*  2. 非静态的同步方法，同步监视器是：this
*     静态的同步方法，同步监视器是：当前类本身
   
   方式三：Lock锁  --- JDK5.0新增
*   
* 1. 面试题：synchronized 与 Lock的异同？
*   相同：二者都可以解决线程安全问题
*   不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器
*        Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）
   
使用的优先顺序：
* Lock ---&gt; 同步代码块（已经进入了方法体，分配了相应资源 ) ---&gt; 同步方法（在方法体之外)
3.利弊
同步的方式，解决了线程的安全问题。---好处
操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。
   
4.
面试题：Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同
   
   
面试题：synchronized和Lock方式解决线程安全问题的对比
   
   
   
</pre></table></code></div></div><h3 id="方式三-实现callable接口"><span class="mr-2">方式三-实现Callable接口</span><a href="#方式三-实现callable接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="n">新增方式一</span><span class="err">：</span><span class="n">实现Callable接口</span><span class="err">。</span> <span class="o">---</span> <span class="no">JDK</span> <span class="mf">5.0</span><span class="n">新增</span>
<span class="c1">//1.创建一个实现Callable的实现类</span>
<span class="kd">class</span> <span class="nc">NumThread</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">{</span>
    <span class="c1">//2.实现call方法，将此线程需要执行的操作声明在call()中</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
   
   
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadNew</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//3.创建Callable接口实现类的对象</span>
        <span class="nc">NumThread</span> <span class="n">numThread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NumThread</span><span class="o">();</span>
        <span class="c1">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span>
        <span class="nc">FutureTask</span> <span class="n">futureTask</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FutureTask</span><span class="o">(</span><span class="n">numThread</span><span class="o">);</span>
        <span class="c1">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">futureTask</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
   
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//6.获取Callable中call方法的返回值</span>
            <span class="c1">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span>
            <span class="nc">Object</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">futureTask</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"总和为："</span> <span class="o">+</span> <span class="n">sum</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
   
<span class="o">}</span>
</pre></table></code></div></div><h3 id="方式四-多线程-使用线程池"><span class="mr-2">方式四-多线程-使用线程池</span><a href="#方式四-多线程-使用线程池" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
</pre><td class="rouge-code"><pre>新增方式一：实现Callable接口。 --- JDK 5.0新增
//1.创建一个实现Callable的实现类
class NumThread implements Callable{
    //2.实现call方法，将此线程需要执行的操作声明在call()中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 1; i &lt;= 100; i++) {
            if(i % 2 == 0){
                System.out.println(i);
                sum += i;
            }
        }
        return sum;
    }
}
   
   
public class ThreadNew {
    public static void main(String[] args) {
        //3.创建Callable接口实现类的对象
        NumThread numThread = new NumThread();
        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(numThread);
        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
        new Thread(futureTask).start();
   
        try {
            //6.获取Callable中call方法的返回值
            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。
            Object sum = futureTask.get();
            System.out.println("总和为：" + sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
   
}
   
说明：
* 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？
* 1. call()可以返回值的。
* 2. call()可以抛出异常，被外面的操作捕获，获取异常的信息
* 3. Callable是支持泛型的
   
新增方式二：使用线程池
class NumberThread implements Runnable{
   
    @Override
    public void run() {
        for(int i = 0;i &lt;= 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}
   
class NumberThread1 implements Runnable{
   
    @Override
    public void run() {
        for(int i = 0;i &lt;= 100;i++){
            if(i % 2 != 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}
   
public class ThreadPool {
   
    public static void main(String[] args) {
        //1. 提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
        //设置线程池的属性
//        System.out.println(service.getClass());
//        service1.setCorePoolSize(15);
//        service1.setKeepAliveTime();
   
   
        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
        service.execute(new NumberThread());//适合适用于Runnable
        service.execute(new NumberThread1());//适合适用于Runnable
   
//        service.submit(Callable callable);//适合使用于Callable
        //3.关闭连接池
        service.shutdown();
    }
   
}
说明：
* 好处：
* 1.提高响应速度（减少了创建新线程的时间）
* 2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）
* 3.便于线程管理
*      corePoolSize：核心池的大小
*      maximumPoolSize：最大线程数
*      keepAliveTime：线程没任务时最多保持多长时间后会终止
   
面试题：Java中多线程的创建有几种方式？四种。
   
   
</pre></table></code></div></div><h1 id="sleep和wait的区别">sleep()和wait()的区别</h1></ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">面试题</span><span class="err">：</span><span class="n">sleep</span><span class="o">()</span> <span class="n">和</span> <span class="n">wait</span><span class="o">()</span><span class="n">的异同</span><span class="err">？</span>
<span class="o">*</span> <span class="mi">1</span><span class="o">.</span><span class="na">相同点</span><span class="err">：</span><span class="n">一旦执行方法</span><span class="err">，</span><span class="n">都可以使得当前的线程进入阻塞状态</span><span class="err">。</span>
<span class="o">*</span> <span class="mi">2</span><span class="o">.</span><span class="na">不同点</span><span class="err">：</span><span class="mi">1</span><span class="err">）</span><span class="n">两个方法声明的位置不同</span><span class="err">：</span><span class="nc">Thread类中声明sleep</span><span class="o">()</span> <span class="o">,</span> <span class="nc">Object类中声明wait</span><span class="o">()</span>
<span class="o">*</span>          <span class="mi">2</span><span class="err">）</span><span class="n">调用的要求不同</span><span class="err">：</span><span class="n">sleep</span><span class="o">()</span><span class="n">可以在任何需要的场景下调用</span><span class="err">。</span> <span class="n">wait</span><span class="o">()</span><span class="n">必须使用在同步代码块或同步方法中</span>
<span class="o">*</span>          <span class="mi">3</span><span class="err">）</span><span class="n">关于是否释放同步监视器</span><span class="err">：</span><span class="n">如果两个方法都使用在同步代码块或同步方法中</span><span class="err">，</span><span class="n">sleep</span><span class="o">()</span><span class="n">不会释放锁</span><span class="err">，</span><span class="n">wait</span><span class="o">()</span><span class="n">会释放锁</span><span class="err">。</span>
</pre></table></code></div></div><h1 id="stringstringbufferstringbuilder三者的对比">String、StringBuffer、StringBuilder三者的对比</h1><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre>1.String、StringBuffer、StringBuilder三者的对比
String:不可变的字符序列；底层使用char[]存储
StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储(涉及多线程，共享数据)
StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储
(线程不安全，不涉及多线程，设计到它不是共享数据)
2.StringBuffer与StringBuilder的内存解析
以StringBuffer为例：
String str = new String();//char[] value = new char[0];
String str1 = new String("abc");//char[] value = new char[]{'a','b','c'};

StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。
System.out.println(sb1.length());//
sb1.append('a');//value[0] = 'a';
sb1.append('b');//value[1] = 'b';

StringBuffer sb2 = new StringBuffer("abc");//char[] value = new char["abc".length() + 16];

//问题1. System.out.println(sb2.length());//3
//问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。
         默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。

        指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)

3.对比String、StringBuffer、StringBuilder三者的执行效率
从高到低排列：StringBuilder 3&gt; StringBuffer 8&gt; String 1023

4.StringBuffer、StringBuilder中的常用方法
增：append(xxx)
删：delete(int start,int end)
改：setCharAt(int n ,char ch) / replace(int start, int end, String str)
查：charAt(int n )
插：insert(int offset, xxx)
长度：length();
*遍历：for() + charAt() / toString()
</pre></table></code></div></div><h1 id="collection子接口list接口">Collection子接口：List接口</h1><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre><td class="rouge-code"><pre><span class="mi">1</span><span class="o">.</span> <span class="n">存储的数据特点</span><span class="err">：</span><span class="n">存储序的</span><span class="err">、</span><span class="n">可重复的数据</span><span class="err">。</span>

<span class="mi">2</span><span class="o">.</span> <span class="n">常用方法</span><span class="err">：</span><span class="o">(</span><span class="n">记住</span><span class="o">)</span>
<span class="n">增</span><span class="err">：</span><span class="n">add</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span>
<span class="n">删</span><span class="err">：</span><span class="n">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">/</span> <span class="n">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span>
<span class="n">改</span><span class="err">：</span><span class="n">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">ele</span><span class="o">)</span>
<span class="n">查</span><span class="err">：</span><span class="n">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span>
<span class="n">插</span><span class="err">：</span><span class="n">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">ele</span><span class="o">)</span>
<span class="n">长度</span><span class="err">：</span><span class="n">size</span><span class="o">()</span>
<span class="n">遍历</span><span class="err">：①</span> <span class="nc">Iterator迭代器方式</span>
     <span class="err">②</span> <span class="n">增强for循环</span>
     <span class="err">③</span> <span class="n">普通的循环</span>


<span class="mi">3</span><span class="o">.</span> <span class="n">常用实现类</span><span class="err">：</span>
<span class="o">|----</span><span class="nc">Collection接口</span><span class="err">：</span><span class="n">单列集合</span><span class="err">，</span><span class="n">用来存储一个一个的对象</span>
<span class="o">*</span>  <span class="o">|----</span><span class="nc">List接口</span><span class="err">：</span><span class="n">存储序的</span><span class="err">、</span><span class="n">可重复的数据</span><span class="err">。</span>  <span class="o">--&gt;</span><span class="err">“</span><span class="n">动态</span><span class="err">”</span><span class="n">数组</span><span class="o">,</span><span class="n">替换原的数组</span>
<span class="o">*</span>      <span class="o">|----</span><span class="nc">ArrayList</span><span class="err">：</span><span class="n">作为List接口的主要实现类</span><span class="err">；</span><span class="n">线程不安全的</span><span class="err">，</span><span class="n">效率高</span><span class="err">；</span><span class="n">底层使用Object</span><span class="o">[]</span> <span class="n">elementData存储</span>
<span class="o">*</span>      <span class="o">|----</span><span class="nc">LinkedList</span><span class="err">：</span><span class="n">对于频繁的插入</span><span class="err">、</span><span class="n">删除操作</span><span class="err">，</span><span class="n">使用此类效率比ArrayList高</span><span class="err">；</span><span class="n">底层使用双向链表存储</span>
<span class="o">*</span>      <span class="o">|----</span><span class="nc">Vector</span><span class="err">：</span><span class="n">作为List接口的古老实现类</span><span class="err">；</span><span class="n">线程安全的</span><span class="err">，</span><span class="n">效率低</span><span class="err">；</span><span class="n">底层使用Object</span><span class="o">[]</span> <span class="n">elementData存储</span>


<span class="mi">4</span><span class="o">.</span> <span class="n">源码分析</span><span class="o">(</span><span class="n">难点</span><span class="o">)</span>
<span class="mf">4.1</span> <span class="nc">ArrayList的源码分析</span><span class="err">：</span>
<span class="o">*</span>   <span class="mf">2.1</span> <span class="n">jdk</span> <span class="mi">7</span><span class="n">情况下</span>
<span class="o">*</span>      <span class="nc">ArrayList</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">();</span><span class="c1">//底层创建了长度是10的Object[]数组elementData</span>
<span class="o">*</span>      <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span><span class="c1">//elementData[0] = new Integer(123);</span>
<span class="o">*</span>      <span class="o">...</span>
<span class="o">*</span>      <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">11</span><span class="o">);</span><span class="c1">//如果此次的添加导致底层elementData数组容量不够，则扩容。</span>
<span class="o">*</span>      <span class="n">默认情况下</span><span class="err">，</span><span class="n">扩容为原来的容量的1</span><span class="o">.</span><span class="mi">5</span><span class="n">倍</span><span class="err">，</span><span class="n">同时需要将原有数组中的数据复制到新的数组中</span><span class="err">。</span>
<span class="o">*</span>
<span class="o">*</span>      <span class="n">结论</span><span class="err">：</span><span class="n">建议开发中使用带参的构造器</span><span class="err">：</span><span class="nc">ArrayList</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span>
<span class="o">*</span>
<span class="o">*</span>   <span class="mf">2.2</span> <span class="n">jdk</span> <span class="mi">8</span><span class="n">中ArrayList的变化</span><span class="err">：</span>
<span class="o">*</span>      <span class="nc">ArrayList</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">();</span><span class="c1">//底层Object[] elementData初始化为{}.并没创建长度为10的数组</span>
<span class="o">*</span>
<span class="o">*</span>      <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span><span class="c1">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span>
<span class="o">*</span>      <span class="o">...</span>
<span class="o">*</span>      <span class="n">后续的添加和扩容操作与jdk</span> <span class="mi">7</span> <span class="n">无异</span><span class="err">。</span>
<span class="o">*</span>   <span class="mf">2.3</span> <span class="n">小结</span><span class="err">：</span><span class="n">jdk7中的ArrayList的对象的创建类似于单例的饿汉式</span><span class="err">，</span><span class="n">而jdk8中的ArrayList的对象</span>
<span class="o">*</span>            <span class="n">的创建类似于单例的懒汉式</span><span class="err">，</span><span class="n">延迟了数组的创建</span><span class="err">，</span><span class="n">节省内存</span><span class="err">。</span>
<span class="o">*</span>

<span class="mf">4.2</span> <span class="nc">LinkedList的源码分析</span><span class="err">：</span>
<span class="o">*</span>      <span class="nc">LinkedList</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">();</span> <span class="n">内部声明了Node类型的first和last属性</span><span class="err">，</span><span class="n">默认值为null</span>
<span class="o">*</span>      <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span><span class="c1">//将123封装到Node中，创建了Node对象。</span>
<span class="o">*</span>
<span class="o">*</span>      <span class="n">其中</span><span class="err">，</span><span class="nc">Node定义为</span><span class="err">：</span><span class="n">体现了LinkedList的双向链表的说法</span>
<span class="o">*</span>      <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
            <span class="no">E</span> <span class="n">item</span><span class="o">;</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">;</span>

            <span class="nc">Node</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">,</span> <span class="no">E</span> <span class="n">element</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">element</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
<span class="mf">4.3</span> <span class="nc">Vector的源码分析</span><span class="err">：</span>
<span class="n">jdk7和jdk8中通过Vector</span><span class="o">()</span><span class="n">构造器创建对象时</span><span class="err">，</span><span class="n">底层都创建了长度为10的数组</span><span class="err">。</span>
<span class="n">在扩容方面</span><span class="err">，</span><span class="n">默认扩容为原来的数组长度的2倍</span><span class="err">。</span>

<span class="mi">5</span><span class="o">.</span> <span class="n">存储的元素的要求</span><span class="err">：</span>
<span class="n">添加的对象</span><span class="err">，</span><span class="n">所在的类要重写equals</span><span class="o">()</span><span class="n">方法</span>
<span class="o">[</span><span class="n">面试题</span><span class="o">]</span>
<span class="o">*</span>  <span class="n">面试题</span><span class="err">：</span><span class="nc">ArrayList</span><span class="err">、</span><span class="nc">LinkedList</span><span class="err">、</span><span class="nc">Vector者的异同</span><span class="err">？</span>
<span class="o">*</span>  <span class="n">同</span><span class="err">：</span><span class="n">三个类都是实现了List接口</span><span class="err">，</span><span class="n">存储数据的特点相同</span><span class="err">：</span><span class="n">存储序的</span><span class="err">、</span><span class="n">可重复的数据</span>
<span class="o">*</span>  <span class="n">不同</span><span class="err">：</span><span class="n">见上</span><span class="err">（</span><span class="n">第3部分</span><span class="o">+</span><span class="n">第4部分</span><span class="err">）</span>

</pre></table></code></div></div><h1 id="map接口">map接口</h1><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
</pre><td class="rouge-code"><pre><span class="n">双列集合框架</span><span class="err">：</span><span class="nc">Map</span>
<span class="mi">1</span><span class="o">.</span><span class="na">常用实现类结构</span>
<span class="o">|----</span><span class="nl">Map:</span><span class="n">双列数据</span><span class="err">，</span><span class="n">存储key</span><span class="o">-</span><span class="n">value对的数据</span>   <span class="o">---</span><span class="n">类似于高中的函数</span><span class="err">：</span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">*</span>       <span class="o">|----</span><span class="nl">HashMap:</span><span class="n">作为Map的主要实现类</span><span class="err">；</span><span class="n">线程不安全的</span><span class="err">，</span><span class="n">效率高</span><span class="err">；</span><span class="n">存储null的key和value</span>
<span class="o">*</span>              <span class="o">|----</span><span class="nl">LinkedHashMap:</span><span class="n">保证在遍历map元素时</span><span class="err">，</span><span class="n">可以照添加的顺序实现遍历</span><span class="err">。</span>
<span class="o">*</span>                    <span class="n">原因</span><span class="err">：</span><span class="n">在原的HashMap底层结构基础上</span><span class="err">，</span><span class="n">添加了一对指针</span><span class="err">，</span><span class="n">指向前一个和后一个元素</span><span class="err">。</span>
<span class="o">*</span>                    <span class="n">对于频繁的遍历操作</span><span class="err">，</span><span class="n">此类执行效率高于HashMap</span><span class="err">。</span>
<span class="o">*</span>       <span class="o">|----</span><span class="nl">TreeMap:</span><span class="n">保证照添加的key</span><span class="o">-</span><span class="n">value对进行排序</span><span class="err">，</span><span class="n">实现排序遍历</span><span class="err">。</span><span class="n">此时考虑key的自然排序或定制排序</span>
<span class="o">*</span>                      <span class="n">底层使用红黑树</span>
<span class="o">*</span>       <span class="o">|----</span><span class="nl">Hashtable:</span><span class="n">作为古老的实现类</span><span class="err">；</span><span class="n">线程安全的</span><span class="err">，</span><span class="n">效率低</span><span class="err">；</span><span class="n">不能存储null的key和value</span>
<span class="o">*</span>              <span class="o">|----</span><span class="nl">Properties:</span><span class="n">常用来处理配置文件</span><span class="err">。</span><span class="n">key和value都是String类型</span>
<span class="o">*</span>
<span class="o">*</span>
<span class="o">*</span>      <span class="nc">HashMap的底层</span><span class="err">：</span><span class="n">数组</span><span class="o">+</span><span class="n">链表</span>  <span class="err">（</span><span class="n">jdk7及之前</span><span class="o">)</span>
<span class="o">*</span>                    <span class="n">数组</span><span class="o">+</span><span class="n">链表</span><span class="o">+</span><span class="n">红黑树</span> <span class="err">（</span><span class="n">jdk</span> <span class="mi">8</span><span class="o">)</span>

<span class="o">[</span><span class="n">面试题</span><span class="o">]</span>
<span class="o">*</span>  <span class="mi">1</span><span class="o">.</span> <span class="nc">HashMap的底层实现原理</span><span class="err">？</span>
<span class="o">*</span>  <span class="mi">2</span><span class="o">.</span> <span class="nc">HashMap</span> <span class="n">和</span> <span class="nc">Hashtable的异同</span><span class="err">？</span>
<span class="o">*</span>  <span class="mi">3</span><span class="o">.</span> <span class="nc">CurrentHashMap</span> <span class="n">与</span> <span class="nc">Hashtable的异同</span><span class="err">？（</span><span class="n">暂时不讲</span><span class="o">)</span>

<span class="mi">2</span><span class="o">.</span><span class="na">存储结构的理解</span><span class="err">：</span>
<span class="o">&gt;</span><span class="nl">Map中的key:</span><span class="n">无序的</span><span class="err">、</span><span class="n">不可重复的</span><span class="err">，</span><span class="n">使用Set存储所的key</span>  <span class="o">---&gt;</span> <span class="n">key所在的类要重写equals</span><span class="o">()</span><span class="n">和hashCode</span><span class="o">()</span> <span class="err">（</span><span class="n">以HashMap为例</span><span class="o">)</span>
<span class="o">&gt;</span><span class="nl">Map中的value:</span><span class="n">无序的</span><span class="err">、</span><span class="n">可重复的</span><span class="err">，</span><span class="n">使用Collection存储所的value</span> <span class="o">---&gt;</span><span class="n">value所在的类要重写equals</span><span class="o">()</span>
<span class="o">&gt;</span> <span class="n">一个键值对</span><span class="err">：</span><span class="n">key</span><span class="o">-</span><span class="n">value构成了一个Entry对象</span><span class="err">。</span>
<span class="o">&gt;</span><span class="nl">Map中的entry:</span><span class="n">无序的</span><span class="err">、</span><span class="n">不可重复的</span><span class="err">，</span><span class="n">使用Set存储所的entry</span>

<span class="n">图示</span><span class="err">：</span>


<span class="mi">3</span><span class="o">.</span><span class="na">常用方法</span>
<span class="o">*</span> <span class="n">添加</span><span class="err">：</span><span class="n">put</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">,</span><span class="nc">Object</span> <span class="n">value</span><span class="o">)</span>
<span class="o">*</span> <span class="n">删除</span><span class="err">：</span><span class="n">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span>
<span class="o">*</span> <span class="n">修改</span><span class="err">：</span><span class="n">put</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">,</span><span class="nc">Object</span> <span class="n">value</span><span class="o">)</span>
<span class="o">*</span> <span class="n">查询</span><span class="err">：</span><span class="n">get</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span>
<span class="o">*</span> <span class="n">长度</span><span class="err">：</span><span class="n">size</span><span class="o">()</span>
<span class="o">*</span> <span class="n">遍历</span><span class="err">：</span><span class="n">keySet</span><span class="o">()</span> <span class="o">/</span> <span class="n">values</span><span class="o">()</span> <span class="o">/</span> <span class="n">entrySet</span><span class="o">()</span>


<span class="mi">4</span><span class="o">.</span> <span class="n">内存结构说明</span><span class="err">：（</span><span class="n">难点</span><span class="err">）</span>
<span class="mf">4.1</span> <span class="nc">HashMap在jdk7中实现原理</span><span class="err">：</span>
<span class="nc">HashMap</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">():</span>
<span class="o">*</span>      <span class="n">在实例化以后</span><span class="err">，</span><span class="n">底层创建了长度是16的一维数组Entry</span><span class="o">[]</span> <span class="n">table</span><span class="err">。</span>
<span class="o">*</span>      <span class="o">...</span><span class="na">可能已经执行过多次put</span><span class="o">...</span>
<span class="o">*</span>      <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key1</span><span class="o">,</span><span class="n">value1</span><span class="o">):</span>
<span class="o">*</span>      <span class="n">首先</span><span class="err">，</span><span class="n">调用key1所在类的hashCode</span><span class="o">()</span><span class="n">计算key1哈希值</span><span class="err">，</span><span class="n">此哈希值经过某种算法计算以后</span><span class="err">，</span><span class="n">得到在Entry数组中的存放位置</span><span class="err">。</span>
<span class="o">*</span>      <span class="n">如果此位置上的数据为空</span><span class="err">，</span><span class="n">此时的key1</span><span class="o">-</span><span class="n">value1添加成功</span><span class="err">。</span> <span class="o">----</span><span class="n">情况1</span>
<span class="o">*</span>      <span class="n">如果此位置上的数据不为空</span><span class="err">，</span><span class="o">(</span><span class="n">意味着此位置上存在一个或多个数据</span><span class="o">(</span><span class="n">以链表形式存在</span><span class="o">)),</span><span class="n">比较key1和已经存在的一个或多个数据的哈希值</span><span class="err">：</span>
<span class="o">*</span>              <span class="n">如果key1的哈希值与已经存在的数据的哈希值都不相同</span><span class="err">，</span><span class="n">此时key1</span><span class="o">-</span><span class="n">value1添加成功</span><span class="err">。</span><span class="o">----</span><span class="n">情况2</span>
<span class="o">*</span>              <span class="n">如果key1的哈希值和已经存在的某一个数据</span><span class="o">(</span><span class="n">key2</span><span class="o">-</span><span class="n">value2</span><span class="o">)</span><span class="n">的哈希值相同</span><span class="err">，</span><span class="n">继续比较</span><span class="err">：</span><span class="n">调用key1所在类的equals</span><span class="o">(</span><span class="n">key2</span><span class="o">)</span><span class="n">方法</span><span class="err">，</span><span class="n">比较</span><span class="err">：</span>
<span class="o">*</span>                      <span class="n">如果equals</span><span class="o">()</span><span class="nl">返回false:</span><span class="n">此时key1</span><span class="o">-</span><span class="n">value1添加成功</span><span class="err">。</span><span class="o">----</span><span class="n">情况3</span>
<span class="o">*</span>                      <span class="n">如果equals</span><span class="o">()</span><span class="nl">返回true:</span><span class="n">使用value1替换value2</span><span class="err">。</span>
<span class="o">*</span>
<span class="o">*</span>      <span class="n">补充</span><span class="err">：</span><span class="n">关于情况2和情况3</span><span class="err">：</span><span class="n">此时key1</span><span class="o">-</span><span class="n">value1和原来的数据以链表的方式存储</span><span class="err">。</span>
<span class="o">*</span>
<span class="o">*</span>     <span class="n">在不断的添加过程中</span><span class="err">，</span><span class="n">会涉及到扩容问题</span><span class="err">，</span><span class="n">当超出临界值</span><span class="o">(</span><span class="n">且要存放的位置非空</span><span class="o">)</span><span class="n">时</span><span class="err">，</span><span class="n">扩容</span><span class="err">。</span><span class="n">默认的扩容方式</span><span class="err">：</span><span class="n">扩容为原来容量的2倍</span><span class="err">，</span><span class="n">并将原的数据复制过来</span><span class="err">。</span>

<span class="mf">4.2</span> <span class="nc">HashMap在jdk8中相较于jdk7在底层实现方面的不同</span><span class="err">：</span>
<span class="mi">1</span><span class="o">.</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">():</span><span class="n">底层没创建一个长度为16的数组</span>
<span class="mi">2</span><span class="o">.</span> <span class="n">jdk</span> <span class="mi">8</span><span class="n">底层的数组是</span><span class="err">：</span><span class="nc">Node</span><span class="o">[],</span><span class="n">而非Entry</span><span class="o">[]</span>
<span class="mi">3</span><span class="o">.</span> <span class="n">首次调用put</span><span class="o">()</span><span class="n">方法时</span><span class="err">，</span><span class="n">底层创建长度为16的数组</span>
<span class="mi">4</span><span class="o">.</span> <span class="n">jdk7底层结构只</span><span class="err">：</span><span class="n">数组</span><span class="o">+</span><span class="n">链表</span><span class="err">。</span><span class="n">jdk8中底层结构</span><span class="err">：</span><span class="n">数组</span><span class="o">+</span><span class="n">链表</span><span class="o">+</span><span class="n">红黑树</span><span class="err">。</span>
<span class="mf">4.1</span> <span class="n">形成链表时</span><span class="err">，</span><span class="n">七上八下</span><span class="err">（</span><span class="nl">jdk7:</span><span class="n">新的元素指向旧的元素</span><span class="err">。</span><span class="n">jdk8</span><span class="err">：</span><span class="n">旧的元素指向新的元素</span><span class="err">）</span>
<span class="mf">4.2</span> <span class="n">当数组的某一个索引位置上的元素以链表形式存在的数据个数</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="n">且当前数组的长度</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="n">时</span><span class="err">，</span><span class="n">此时此索引位置上的所数据改为使用红黑树存储</span><span class="err">。</span>

<span class="mf">4.3</span> <span class="nc">HashMap底层典型属性的属性的说明</span><span class="err">：</span>
<span class="no">DEFAULT_INITIAL_CAPACITY</span> <span class="o">:</span> <span class="nc">HashMap的默认容量</span><span class="err">，</span><span class="mi">16</span>
<span class="no">DEFAULT_LOAD_FACTOR</span><span class="err">：</span><span class="nc">HashMap的默认加载因子</span><span class="err">：</span><span class="mf">0.75</span>
<span class="n">threshold</span><span class="err">：</span><span class="n">扩容的临界值</span><span class="err">，</span><span class="o">=</span><span class="n">容量</span><span class="o">*</span><span class="n">填充因子</span><span class="err">：</span><span class="mi">16</span> <span class="o">*</span> <span class="mf">0.75</span> <span class="o">=&gt;</span> <span class="mi">12</span>
<span class="no">TREEIFY_THRESHOLD</span><span class="err">：</span><span class="nc">Bucket中链表长度大于该默认值</span><span class="err">，</span><span class="nl">转化为红黑树:</span><span class="mi">8</span>
<span class="no">MIN_TREEIFY_CAPACITY</span><span class="err">：</span><span class="nl">桶中的Node被树化时最小的hash表容量:</span><span class="mi">64</span>

<span class="mf">4.4</span> <span class="nc">LinkedHashMap的底层实现原理</span><span class="o">(</span><span class="n">了解</span><span class="o">)</span>
<span class="nc">LinkedHashMap底层使用的结构与HashMap相同</span><span class="err">，</span><span class="n">因为LinkedHashMap继承于HashMap</span><span class="o">.</span>
<span class="n">区别就在于</span><span class="err">：</span><span class="nc">LinkedHashMap内部提供了Entry</span><span class="err">，</span><span class="n">替换HashMap中的Node</span><span class="o">.</span>


<span class="mi">5</span><span class="o">.</span> <span class="nc">TreeMap的使用</span>
<span class="c1">//向TreeMap中添加key-value，要求key必须是由同一个类创建的对象</span>
<span class="c1">//因为要照key进行排序：自然排序 、定制排序</span>

<span class="mi">6</span><span class="o">.</span><span class="na">使用Properties读取配置文件</span>
<span class="c1">//Properties:常用来处理配置文件。key和value都是String类型</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>  <span class="o">{</span>
    <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Properties</span> <span class="n">pros</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>

        <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"jdbc.properties"</span><span class="o">);</span>
        <span class="n">pros</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span><span class="c1">//加载流对应的文件</span>

        <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">pros</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"name"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="n">pros</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"password"</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"name = "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">", password = "</span> <span class="o">+</span> <span class="n">password</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">fis</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>

        <span class="o">}</span>
    <span class="o">}</span>


</pre></table></code></div></div><h1 id="遍历hashmap">遍历HashMap</h1><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MapTest</span> <span class="o">{</span>

    <span class="cm">/*
 元视图操作的方法：
 Set keySet()：返回所有key构成的Set集合
 Collection values()：返回所有value构成的Collection集合
 Set entrySet()：返回所有key-value对构成的Set集合

     */</span>


    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test5</span><span class="o">(){</span>
        <span class="nc">Map</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"AA"</span><span class="o">,</span><span class="mi">123</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">45</span><span class="o">,</span><span class="mi">1234</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"BB"</span><span class="o">,</span><span class="mi">56</span><span class="o">);</span>

        <span class="c1">//遍历所有的key集：keySet()</span>
        <span class="nc">Set</span> <span class="n">set</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">();</span>
            <span class="nc">Iterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
            <span class="k">while</span><span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="c1">//遍历所有的value集：values()</span>
        <span class="nc">Collection</span> <span class="n">values</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">values</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span> <span class="o">:</span> <span class="n">values</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="c1">//遍历所有的key-value</span>
        <span class="c1">//方式一：entrySet()</span>
        <span class="nc">Set</span> <span class="n">entrySet</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">();</span>
        <span class="nc">Iterator</span> <span class="n">iterator1</span> <span class="o">=</span> <span class="n">entrySet</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">iterator1</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
            <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">iterator1</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="c1">//entrySet集合中的元素都是entry</span>
            <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">"----&gt;"</span> <span class="o">+</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>

        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="c1">//方式二：</span>
        <span class="nc">Set</span> <span class="n">keySet</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">();</span>
        <span class="nc">Iterator</span> <span class="n">iterator2</span> <span class="o">=</span> <span class="n">keySet</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">iterator2</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
            <span class="nc">Object</span> <span class="n">key</span> <span class="o">=</span> <span class="n">iterator2</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span> <span class="o">+</span> <span class="s">"====="</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>

        <span class="o">}</span>

    <span class="o">}</span>

    
    
 <span class="kt">void</span> <span class="nf">copy</span><span class="o">(</span><span class="nc">List</span> <span class="n">dest</span><span class="o">,</span><span class="nc">List</span> <span class="n">src</span><span class="o">)</span><span class="err">：</span><span class="n">将src中的内容复制到dest中</span>
    <span class="c1">//正确的：</span>
        <span class="nc">List</span> <span class="n">dest</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dest</span><span class="o">.</span><span class="na">size</span><span class="o">());</span><span class="c1">//list.size();</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">dest</span><span class="o">,</span><span class="n">list</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dest</span><span class="o">);</span>
</pre></table></code></div></div><h1 id="节点流">节点流</h1><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
</pre><td class="rouge-code"><pre><span class="mi">1</span><span class="o">.</span><span class="na">FileReader</span><span class="o">/</span><span class="nc">FileWriter的使用</span><span class="err">：</span>
<span class="mf">1.1</span> <span class="nc">FileReader的使用</span>
<span class="cm">/*
将day09下的hello.txt文件内容读入程序中，并输出到控制台

说明点：
1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1
2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理
3. 读入的文件一定要存在，否则就会报FileNotFoundException。

 */</span>
<span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testFileReader1</span><span class="o">()</span>  <span class="o">{</span>
        <span class="nc">FileReader</span> <span class="n">fr</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//1.File类的实例化</span>
            <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"hello.txt"</span><span class="o">);</span>

            <span class="c1">//2.FileReader流的实例化</span>
            <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>

            <span class="c1">//3.读入的操作</span>
            <span class="c1">//read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span>
            <span class="kt">char</span><span class="o">[]</span> <span class="n">cbuf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>
            <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">cbuf</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
                <span class="c1">//方式一：</span>
                <span class="c1">//错误的写法</span>
<span class="c1">//                for(int i = 0;i &lt; cbuf.length;i++){</span>
<span class="c1">//                    System.out.print(cbuf[i]);</span>
<span class="c1">//                }</span>
                <span class="c1">//正确的写法</span>
<span class="c1">//                for(int i = 0;i &lt; len;i++){</span>
<span class="c1">//                    System.out.print(cbuf[i]);</span>
<span class="c1">//                }</span>
                <span class="c1">//方式二：</span>
                <span class="c1">//错误的写法,对应着方式一的错误的写法</span>
<span class="c1">//                String str = new String(cbuf);</span>
<span class="c1">//                System.out.print(str);</span>
                <span class="c1">//正确的写法</span>
                <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">cbuf</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">fr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="c1">//4.资源的关闭</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">fr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>

            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="mf">1.2</span> <span class="nc">FileWriter的使用</span>
<span class="cm">/*
从内存中写出数据到硬盘的文件里。

说明：
1. 输出操作，对应的File可以不存在的。并不会报异常
2.
     File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。
     File对应的硬盘中的文件如果存在：
           如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原文件的覆盖
           如果流使用的构造器是：FileWriter(file,true):不会对原文件覆盖，而是在原文件基础上追加内容

 */</span>
<span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testFileWriter</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//1.提供File类的对象，指明写出到的文件</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"hello1.txt"</span><span class="o">);</span>

        <span class="c1">//2.提供FileWriter的对象，用于数据的写出</span>
        <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="n">file</span><span class="o">,</span><span class="kc">false</span><span class="o">);</span>

        <span class="c1">//3.写出的操作</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"I have a dream!\n"</span><span class="o">);</span>
        <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"you need to have a dream!"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="c1">//4.流资源的关闭</span>
        <span class="k">if</span><span class="o">(</span><span class="n">fw</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>

            <span class="k">try</span> <span class="o">{</span>
                <span class="n">fw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="mf">1.3</span> <span class="n">文本文件的复制</span><span class="err">：</span>
<span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testFileReaderFileWriter</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">FileReader</span> <span class="n">fr</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">FileWriter</span> <span class="n">fw</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//1.创建File类的对象，指明读入和写出的文件</span>
            <span class="nc">File</span> <span class="n">srcFile</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"hello.txt"</span><span class="o">);</span>
            <span class="nc">File</span> <span class="n">destFile</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"hello2.txt"</span><span class="o">);</span>

            <span class="c1">//不能使用字符流来处理图片等字节数据</span>
<span class="c1">//            File srcFile = new File("爱情与友情.jpg");</span>
<span class="c1">//            File destFile = new File("爱情与友情1.jpg");</span>


            <span class="c1">//2.创建输入流和输出流的对象</span>
             <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">srcFile</span><span class="o">);</span>
            <span class="n">fw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="n">destFile</span><span class="o">);</span>


            <span class="c1">//3.数据的读入和写出操作</span>
            <span class="kt">char</span><span class="o">[]</span> <span class="n">cbuf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">len</span><span class="o">;</span><span class="c1">//记录每次读入到cbuf数组中的字符的个数</span>
            <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">cbuf</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
                <span class="c1">//每次写出len个字符</span>
                <span class="n">fw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">cbuf</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">);</span>

            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="c1">//4.关闭流资源</span>
            <span class="c1">//方式一：</span>
<span class="c1">//            try {</span>
<span class="c1">//                if(fw != null)</span>
<span class="c1">//                    fw.close();</span>
<span class="c1">//            } catch (IOException e) {</span>
<span class="c1">//                e.printStackTrace();</span>
<span class="c1">//            }finally{</span>
<span class="c1">//                try {</span>
<span class="c1">//                    if(fr != null)</span>
<span class="c1">//                        fr.close();</span>
<span class="c1">//                } catch (IOException e) {</span>
<span class="c1">//                    e.printStackTrace();</span>
<span class="c1">//                }</span>
<span class="c1">//            }</span>
            <span class="c1">//方式二：</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">fw</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">fw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="k">try</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">fr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">fr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="mi">2</span><span class="o">.</span><span class="na">FileInputStream</span> <span class="o">/</span> <span class="nc">FileOutputStream的使用</span><span class="err">：</span>
<span class="o">*</span> <span class="mi">1</span><span class="o">.</span> <span class="n">对于文本文件</span><span class="o">(.</span><span class="na">txt</span><span class="o">,.</span><span class="na">java</span><span class="o">,.</span><span class="na">c</span><span class="o">,.</span><span class="na">cpp</span><span class="o">)</span><span class="err">，</span><span class="n">使用字符流处理</span>
<span class="o">*</span> <span class="mi">2</span><span class="o">.</span> <span class="n">对于非文本文件</span><span class="o">(.</span><span class="na">jpg</span><span class="o">,.</span><span class="na">mp3</span><span class="o">,.</span><span class="na">mp4</span><span class="o">,.</span><span class="na">avi</span><span class="o">,.</span><span class="na">doc</span><span class="o">,.</span><span class="na">ppt</span><span class="o">,...)</span><span class="err">，</span><span class="n">使用字节流处理</span>
<span class="cm">/*
实现对图片的复制操作
 */</span>
<span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testFileInputOutputStream</span><span class="o">()</span>  <span class="o">{</span>
    <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//1.造文件</span>
        <span class="nc">File</span> <span class="n">srcFile</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"爱情与友情.jpg"</span><span class="o">);</span>
        <span class="nc">File</span> <span class="n">destFile</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"爱情与友情2.jpg"</span><span class="o">);</span>

        <span class="c1">//2.造流</span>
        <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">srcFile</span><span class="o">);</span>
        <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">destFile</span><span class="o">);</span>

        <span class="c1">//3.复制的过程</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>
        <span class="k">while</span><span class="o">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">fos</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">//4.关闭流</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">fis</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>

        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>



<span class="err">【</span><span class="n">注意</span><span class="err">】</span>
<span class="n">相对路径在IDEA和Eclipse中使用的区别</span><span class="err">？</span>
<span class="nl">IDEA:</span>
<span class="n">如果使用单元测试方法</span><span class="err">，</span><span class="n">相对路径基于当前的Module的</span><span class="err">。</span>
<span class="n">如果使用main</span><span class="o">()</span><span class="n">测试</span><span class="err">，</span><span class="n">相对路径基于当前Project的</span><span class="err">。</span>

<span class="nl">Eclipse:</span>
<span class="n">单元测试方法还是main</span><span class="o">(),</span><span class="n">相对路径都是基于当前Project的</span><span class="err">。</span>

</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E9%9A%8F%E7%AC%94/'>随笔</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E5%88%86%E7%B1%BB/" class="post-tag no-text-decoration" >分类</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93+-+%E7%95%AA%E8%8C%84%E6%99%BA&url=https%3A%2F%2Fliudezhiya.github.io%2F%2Fposts%2Fjava%25E5%259F%25BA%25E7%25A1%2580%25E6%2580%25BB%25E7%25BB%2593%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93+-+%E7%95%AA%E8%8C%84%E6%99%BA&u=https%3A%2F%2Fliudezhiya.github.io%2F%2Fposts%2Fjava%25E5%259F%25BA%25E7%25A1%2580%25E6%2580%25BB%25E7%25BB%2593%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fliudezhiya.github.io%2F%2Fposts%2Fjava%25E5%259F%25BA%25E7%25A1%2580%25E6%2580%25BB%25E7%25BB%2593%2F&text=java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93+-+%E7%95%AA%E8%8C%84%E6%99%BA" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/gephi%E4%BD%9C%E8%80%85%E7%BD%91%E7%BB%9C%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96/">java基础总结</a><li><a href="/posts/hello/">复杂网络概念</a><li><a href="/posts/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">java基础总结</a><li><a href="/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><li><a href="/posts/matlab/">matlab</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%88%86%E7%B1%BB/">分类</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2/"><div class="card-body"> <em class="small" data-ts="1648262040" data-df="YYYY/MM/DD" > 2022/03/26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>小波变换</h3><div class="text-muted small"><p> 西储大学数据集解读 数据格式：轴承故障数据文件为Matlab格式 1 2 3 4 5 DE - drive end accelerometer data 驱动端振动数据 FE - fan end accelerometer data 风扇端振动数据 BA - base accelerometer data 基座振动数据 time - time series...</p></div></div></a></div><div class="card"> <a href="/posts/gephi%E4%BD%9C%E8%80%85%E7%BD%91%E7%BB%9C%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96/"><div class="card-body"> <em class="small" data-ts="1648262040" data-df="YYYY/MM/DD" > 2022/03/26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>java基础总结</h3><div class="text-muted small"><p> # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import pand...</p></div></div></a></div><div class="card"> <a href="/posts/networkx%E6%80%BB%E7%BB%93/"><div class="card-body"> <em class="small" data-ts="1648262040" data-df="YYYY/MM/DD" > 2022/03/26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>networkx总结</h3><div class="text-muted small"><p> 创建Graph 1 2 3 4 5 G = nx.Graph() # 无向图 G = nx.DiGraph() # 有向图 G = nx.MultiGraph() # 多重无向图 G = nx.MultiDigraph() # 多重有向图 G.clear() # 清空图 Graph 是一组节点（顶点）和已识别的节点...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/hello/" class="btn btn-outline-primary" prompt="上一篇"><p>复杂网络概念</p></a> <a href="/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="btn btn-outline-primary" prompt="下一篇"><p>正则表达式</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%88%86%E7%B1%BB/">分类</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">liudezhiya</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
