 [toc]

# çº¿æ€§è¡¨

## é¡ºåºè¡¨

### é¡ºåºè¡¨é™æ€åˆ†é…æ•°æ®ç±»å‹å®šä¹‰

```c++
#define MaxSize 10      //å®šä¹‰æœ€å¤§é•¿åº¦ 
typedef struct{
    ElemType data[MaxSize];  //ç”¨é™æ€çš„â€œæ•°ç»„â€å­˜æ”¾æ•°æ®å…ƒç´  
    int Length;         //é¡ºåºè¡¨çš„å½“å‰é•¿åº¦
}SqList;                //é¡ºåºè¡¨çš„ç±»å‹å®šä¹‰

void InitList(SqList &L){
    for(int i=0; i<MaxSize; i++){
        L.data[i]=0;   //é˜²æ­¢è„æ•°æ®â€
    }
    L.Length=0;        //é¡ºåºè¡¨åˆå§‹é•¿åº¦ä¸º0
}

```
### é¡ºåºè¡¨åŠ¨æ€åˆ†é…æ•°æ®ç±»å‹å®šä¹‰

```c
#define InitSize 10    //è®¾ç½®é»˜è®¤æœ€å¤§é•¿åº¦
typedef struct{
	ElemType  *data;//æŒ‡ç¤ºåŠ¨æ€åˆ†é…æ•°ç»„çš„æŒ‡é’ˆ
	int MaxSize;
	int length;
}SeqList;

void InitList(SeqList &L) {
	//mallocç”³è¯·è¿ç»­çš„å­˜å‚¨ç©ºé—´
	L.data = (int *)malloc(InitSize * sizeof(int));
	L.length = 0;
	L.MaxSize = InitSize;
}
```
### é¡ºåºè¡¨å®šä¹‰âœ¨ğŸ“š

```c
#define MaxSize 10      //å®šä¹‰æœ€å¤§é•¿åº¦ 
typedef struct{
    ElemType data[MaxSize];  //ç”¨é™æ€çš„â€œæ•°ç»„â€å­˜æ”¾æ•°æ®å…ƒç´  
    int Length;         //é¡ºåºè¡¨çš„å½“å‰é•¿åº¦
}SqList; 
#define InitSize 10    //è®¾ç½®é»˜è®¤æœ€å¤§é•¿åº¦
typedef struct{
	ElemType  *data;//æŒ‡ç¤ºåŠ¨æ€åˆ†é…æ•°ç»„çš„æŒ‡é’ˆ
	int MaxSize;
	int length;
}SeqList;
```



### å¢åŠ åŠ¨æ€æ•°ç»„çš„é•¿åº¦

```c++
//å¢åŠ åŠ¨æ€æ•°ç»„çš„é•¿åº¦
void IncreaseSize(SeqList &L, int len){
    int *p=L.data;
    L.data = (int*)malloc((L.MaxSize+len)*sizeof(int));
    for(int i=0; i<L.length; i++){
        L.data[i] = p[i]         //å°†æ•°æ®å¤åˆ¶åˆ°æ–°åŒºåŸŸ
    }
    L.MaxSize = L.MaxSize + len; //é¡ºåºè¡¨æœ€å¤§é•¿åº¦å¢åŠ len
    free(p);                     //é‡Šæ”¾åŸæ¥çš„å†…å­˜ç©ºé—´
}
```
### é¡ºåºè¡¨æ’å…¥âœ¨

```c
//åœ¨Lä½åºä¸ºiå¤„æ’å…¥å…ƒç´ e
bool ListInsert(SqList &L, int i, int e){ 
    //åˆ¤æ–­içš„èŒƒå›´æ˜¯å¦æœ‰æ•ˆ
    if(i<1||i>L.length+1) 
        return false;
    if(L.length>MaxSize) //å½“å‰å­˜å‚¨ç©ºé—´å·²æ»¡ï¼Œä¸èƒ½æ’å…¥  
        return false;
     
    for(int j=L.length; j>=i; j--){    //å°†ç¬¬iä¸ªå…ƒç´ åŠå…¶ä¹‹åçš„å…ƒç´ åç§»
        L.data[j]=L.data[j-1];
    }
    L.data[i-1]=e;  //åœ¨ä½ç½®iå¤„æ”¾å…¥e
    L.length++;      //é•¿åº¦åŠ 1
    return true;
}
```
### é¡ºåºè¡¨åˆ é™¤âœ¨

```c
bool ListDelete(SeqList &L, int i,Element &e){ // eç”¨å¼•ç”¨å‹å‚æ•° 
    //åˆ¤æ–­içš„èŒƒå›´æ˜¯å¦æœ‰æ•ˆ
    if(i<1 ||i>L.length) 
        return false;
    e = L.data[i-1];   //å°†è¢«åˆ é™¤çš„å…ƒç´ èµ‹å€¼ç»™e
    for(int j=i; j<L.length; j++){    //å°†ç¬¬iä¸ªåçš„å…ƒç´ å‰ç§»  åç§»ä¸ªæ•°ä¸ºn-i+1
        L.data[j-1]=L.data[j];
    }
    L.length--;      //é•¿åº¦å‡1
    return true;
}
```
### é¡ºåºè¡¨æŸ¥æ‰¾

```c
//æŒ‰å€¼æŸ¥æ‰¾é¡ºåºè¡¨,æ‰¾åˆ°ç¬¬ä¸€ä¸ªå…ƒç´ å€¼ç­‰äºeçš„ä½åºå¹¶è¿”å›å…¶ä½åº
int LocateElem(SeqList L, int e) {
	int i;
	for (i = 0; i < L.length; i++)
		if (L.data[i]==e)
			return i + 1;
	return 0;
}
```
### ä¹ é¢˜

#### 1.åˆ é™¤æœ€å°å…ƒç´ èŠ‚ç‚¹ï¼Œvalueè¿”å›

```c
//åˆ é™¤æœ€å°å…ƒç´ èŠ‚ç‚¹ï¼Œvalueè¿”å›
/*æŸ¥æ‰¾æœ€å°å€¼ä¸‹æ ‡ï¼Œç”¨æœ€åä¸€ä¸ªè¦†ç›–å®ƒ*/
bool Del_Main(SqList &L,ElemType &value){
    if(L.length==0)
        return false;
    value=L.data[0];
    int pos=0;//å‡è®¾0å·å…ƒç´ çš„å€¼æœ€å°
    for(int i=1;i<L.length;i++){
        if(L.data[i]<value){
            value=L.data[i];
            pos=i; 
        }
    }
    L.data[pos]=L.data[L.length-1];//ç©ºå‡ºçš„ä½ç½®ç”±æœ€åä¸€ä¸ªå…ƒç´ å¡«è¡¥
    L.length--;
    return true;
}
```

#### 2.é¡ºåºè¡¨å…ƒç´ é€†ç½®ğŸš¦

```c
void Reverse(Sqlist &L){
    ElemType temp;
    for(i=0;i<L.length/2;i++){
        temp=L.data[i];
        L.data[i]=L.data[L.length-i-1];
        L.data[L.length-i-1]=temp;
    }
}
```

#### 3.åˆ é™¤é¡ºåºè¡¨ä¸­æ‰€æœ‰å€¼ä¸ºxçš„å…ƒç´ 

```c
//åˆ é™¤é¡ºåºè¡¨ä¸­æ‰€æœ‰å€¼ä¸ºxçš„å…ƒç´ 
void del_x(Sqlist &L,ElemType x){
    int k=0;//è®°å½•å€¼ä¸ç­‰äºxçš„å…ƒç´ 
    for(i=0;i<L.length;i++)
        if(L.data[i]!=x){
            L.data[k]=L.data[i];
            k++;
        }
   L.length=k;  
}
```

#### 4.ä»æœ‰åºé¡ºåºè¡¨ä¸­åˆ é™¤s tä¹‹é—´çš„æ‰€æœ‰å…ƒç´ ğŸ‰

```c
//ä»æœ‰åºé¡ºåºè¡¨ä¸­åˆ é™¤s tä¹‹é—´çš„æ‰€æœ‰å…ƒç´ 
bool Del_st(Sqlist &L,ElemType s,ElemType t){
    int i,j;
    if(s>t||L.length==0)
        return false;
    for(i=0;i<L.length&&L.data[i]<s;i++);//å¯»æ‰¾å¤§äºç­‰äºsçš„ç¬¬ä¸€ä¸ªå…ƒç´ <
    if(i>=L.length)
        return false;//æ‰€æœ‰å…ƒç´ å‡å°äºsè¿”å›
    for( j=i;j<L.length&&L.data[j]<=t;j++);//å¯»æ‰¾å¤§äºtçš„ç¬¬ä¸€ä¸ªå…ƒç´ <=
    for(;j<L.length;i++,j++)
        L.data[i]=L.data[j];//å‰ç§»ï¼Œå¡«å……è¢«åˆ é™¤å…ƒç´ 
    L.length=i;
    return true;
}
```

#### 5.ä»é¡ºåºè¡¨ä¸­åˆ é™¤s t(åŒ…æ‹¬s t)ä¹‹é—´çš„æ‰€æœ‰å…ƒç´ 

```c
//ä»é¡ºåºè¡¨ä¸­åˆ é™¤s t(åŒ…æ‹¬s t)ä¹‹é—´çš„æ‰€æœ‰å…ƒç´ 
bool Del_st(Sqlist &L,ElemType s,ElemType t){
    int i ,k=0;//kä¸ºs tä¹‹é—´çš„å…ƒç´ ä¸ªæ•°
    if(L.length==0||s>=t)
        return false;
    for(i=0;i<L.length;i++){
        if(L.data[i]>=s&&L.data[i]<=t)
            k++;
        else
            L.data[i-k]=L.data[i];//å½“å‰å…ƒç´ å‰ç§»kä¸ªä½ç½®
    }
    L.length-=k;//é•¿åº¦å‡å°‘
    return true;
}
```

#### 6.ä»æœ‰åºé¡ºåºè¡¨ä¸­åˆ é™¤æ‰€æœ‰å…¶å€¼é‡å¤çš„å…ƒç´ ğŸš¦

```c
//#### ä»æœ‰åºé¡ºåºè¡¨ä¸­åˆ é™¤æ‰€æœ‰å…¶å€¼é‡å¤çš„å…ƒç´ 
bool Delete_Same(SqList &L){
    if(L.length==0)
        return false;
    int i,j;//iå­˜å‚¨ç¬¬ä¸€ä¸ªä¸ç›¸åŒå…ƒç´ ,jä¸ºå·¥ä½œæŒ‡é’ˆ
    for(i=0,j=1;j<L.length;j++){
        if(L.data[i]!=L.data[j])//æŸ¥æ‰¾ä¸ä¸Šä¸€ä¸ªä¸åŒçš„å…ƒç´ 
            L.data[++i]=L.data[j];//æ‰¾åˆ°åå‰ç§»ï¼Œæ”¾åˆ°ä¸åŒçš„åé¢
    }
    L.length=i+1;	//0å¼€å§‹
    return true;
}
```

#### 7.åˆå¹¶æœ‰åºé¡ºåºè¡¨

```c
//åˆå¹¶æœ‰åºé¡ºåºè¡¨ 
bool Merge(SqList A,SqList B,SqList c){
    if(A.length+B.length>C.maxSize)
        return false;
    int i=0,j=0,k=0;
    while(i<A.length&&j<B.length){
        if(A.data[i]<=B.data[j])
            C.data[k++]=A.data[i++];
        else
            C.data[k++]=B.data[j++];
    }
    while(i<A.length)
        C.data[k++]=A.data[i++];
    while(j<B.length)
        C.data[k++]=B.data[j++];
    C.length=k;
    return true;
}
```



## é“¾è¡¨

### èŠ‚ç‚¹ç±»å‹å®šä¹‰

```c
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

//ä¸å¸¦å¤´èŠ‚ç‚¹åˆå§‹åŒ–
bool InitList(LinkList &L){  //æ³¨æ„ç”¨å¼•ç”¨ &
    L = NULL; //ç©ºè¡¨ï¼Œæš‚æ—¶è¿˜æ²¡æœ‰ä»»ä½•ç»“ç‚¹ï¼›
    return true;
}

//å¸¦å¤´ç»“ç‚¹åˆå§‹
bool InitList(LinkList &L){  
    L = (LNode*) malloc(sizeof(LNode));  //å¤´ç»“ç‚¹
    if (L == NULL)          //å†…å­˜ä¸è¶³ï¼Œåˆ†é…å¤±è´¥
        return false;
    L -> next = NULL;       //å¤´ç»“ç‚¹ä¹‹åæš‚æ—¶è¿˜æ²¡æœ‰ç»“ç‚¹
    return true;
}
```
### å¤´æ’æ³•âœ¨ 

```c++
//å¸¦å¤´ç»“ç‚¹çš„å¤´æ’æ³•
LinkList List_HeadInsert(LinkList &L){       //é€†å‘å»ºç«‹å•é“¾è¡¨
    LNode *s;
    int x;
    L = (LinkList)malloc(sizeof(LNode));     //å»ºç«‹å¤´ç»“ç‚¹
    L->next = NULL;                          //åˆå§‹ä¸ºç©ºé“¾è¡¨,è¿™æ­¥ä¸èƒ½å°‘ï¼
    scanf("%d", &x);                         //è¾“å…¥è¦æ’å…¥çš„ç»“ç‚¹çš„å€¼
    while(x!=9999){                          //è¾“å…¥9999è¡¨ç»“æŸ
        s = (LNode *)malloc(sizeof(LNode));  //åˆ›å»ºæ–°ç»“ç‚¹
        s->data = x;
        s->next = L->next;
        L->next = s;                         //å°†æ–°ç»“ç‚¹æ’å…¥è¡¨ä¸­ï¼ŒLä¸ºå¤´æŒ‡é’ˆ
        scanf("%d", &x);   
    }
    return L;

 //å‘è¡¨ä¸­æŒ‡å®šçš„ä½ç½®poså¤„æ·»åŠ é”®å€¼ä¸ºkeyçš„å…ƒç´ 
int insert(Lnode *h,int pos,elemtype x)
{
	Lnode *p=h,*s;
    int j=0;
    while(p&&j<pos-1)     //å¯»æ‰¾ç¬¬i-1å·ç»“ç‚¹
    {
		p=p->next;
		j++;
    }
    if(p)
    {
		s=(Lnode *)malloc(sizeof(Lnode));
        s->data=x;
        s->next=p->next;     //æ”¹å˜æŒ‡é’ˆçŠ¶æ€ï¼Œå°†sæ’å…¥è¡¨ä¸­
        p->next=s;
        return(1);        //è¿”å›1è¡¨ç¤ºæ­£å¸¸ç»“æŸ
    }
    else 
        return (0);       //è¿”å›0è¡¨ç¤ºæ’å…¥å¤±è´¥
}
  
    
    
//ä¸å¸¦å¤´ç»“ç‚¹çš„å¤´æ’æ³•
LinkList List_HeadInsert(LinkList &L){       //é€†å‘å»ºç«‹å•é“¾è¡¨
    LNode *s;
    int x;
    L = (LinkList)malloc(sizeof(LNode));     //å»ºç«‹å¤´ç»“ç‚¹
	scanf("%d", &x);                         //è¾“å…¥è¦æ’å…¥çš„ç»“ç‚¹çš„å€¼
	L->data = x; 
    L->next = NULL;                          //åˆå§‹ä¸ºç©ºé“¾è¡¨,è¿™æ­¥ä¸èƒ½å°‘ï¼
    while(x!=9999){                          //è¾“å…¥9999è¡¨ç»“æŸ
        s = (LNode *)malloc(sizeof(LNode));  //åˆ›å»ºæ–°ç»“ç‚¹
        s->data = x;
        s->next = L->next;
        L->next = s;                         //å°†æ–°ç»“ç‚¹æ’å…¥è¡¨ä¸­ï¼ŒLä¸ºå¤´æŒ‡é’ˆ
        scanf("%d", &x);   
    }
    return L;
   
}
```
### å°¾æ’æ³•âœ¨

```c
//å¸¦å¤´ç»“ç‚¹çš„å°¾æ’æ³•
LinkList List_TailInsert(LinkList &L){       //æ­£å‘å»ºç«‹å•é“¾è¡¨
    int x;                                   //è®¾ElemTypeä¸ºæ•´å‹int
    L = (LinkList)malloc(sizeof(LNode));     //å»ºç«‹å¤´ç»“ç‚¹(åˆå§‹åŒ–ç©ºè¡¨)
    LNode *s, *r = L;                        //rä¸ºè¡¨å°¾æŒ‡é’ˆ
    scanf("%d", &x);                         //è¾“å…¥è¦æ’å…¥çš„ç»“ç‚¹çš„å€¼
    while(x!=9999){                          //è¾“å…¥9999è¡¨ç»“æŸ
        s = (LNode *)malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;                                //ræŒ‡é’ˆæŒ‡å‘æ–°çš„è¡¨å°¾ç»“ç‚¹
        scanf("%d", &x);   
    }
    r->next = NULL;                          //å°¾ç»“ç‚¹æŒ‡é’ˆç½®ç©º
    return L;
}

//ä¸å¸¦å¤´ç»“ç‚¹çš„å°¾æ’æ³•
LinkList List_TailInsert(LinkList &L){       //æ­£å‘å»ºç«‹å•é“¾è¡¨
    int x;                                   //è®¾ElemTypeä¸ºæ•´å‹int
    L = (LinkList)malloc(sizeof(LNode));    
	scanf("%d", &x);                         //è¾“å…¥è¦æ’å…¥çš„ç»“ç‚¹çš„å€¼
	L->data = x; 
    L->next = NULL;
    LNode *s, *r = L;                        //rä¸ºè¡¨å°¾æŒ‡é’ˆ
    while(x!=9999){                          //è¾“å…¥9999è¡¨ç»“æŸ
        s = (LNode *)malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;                                //ræŒ‡é’ˆæŒ‡å‘æ–°çš„è¡¨å°¾ç»“ç‚¹
        scanf("%d", &x);   
    }
    r->next = NULL;                          //å°¾ç»“ç‚¹æŒ‡é’ˆç½®ç©º
    return L;
}
```
### åˆ›å»ºnä¸ªå¸¦å¤´å•å¾ªç¯é“¾è¡¨ğŸš¦

```c
LNode create(int n){
    LNode head ,p,r;
    int i=1;
    head=(LNode)malloc(sizeof(LNode));
    head->next=head;
    while(i<=n-1){
        p=(LNode)malloc(sizeof(LNode));
        p->next=head->next;
        head->next=p;
        i++;
    }
    return head;
}
```



### æŒ‰åºå·æŸ¥æ‰¾ç»“ç‚¹

```c
//æŒ‰ä½æŸ¥æ‰¾ è·å–è¡¨Lä¸­ç¬¬iä¸ªä½ç½®çš„å…ƒç´ çš„å€¼
LNode * GetElem(LinkList L, int i){
    int j=1;
    LNode *p=L->next;
    if(i==0)
        return L;//è¿”å›å¤´èŠ‚ç‚¹
    if(i<0) 
        return NULL;
    while(p!=NULL && j<i){  //å¾ªç¯æ‰¾åˆ°ç¬¬iä¸ªç»“ç‚¹
        p = p->next;
        j++;
    }
    return p->data;         //è¿”å›pæŒ‡é’ˆæŒ‡å‘çš„å€¼
}
```
### æŒ‰å€¼æŸ¥æ‰¾ç»“ç‚¹

```c
//æŒ‰å€¼æŸ¥æ‰¾ç»“ç‚¹
LNode * LocateElem(LinkList L, int e){
    LNode *p = L->next;    //pæŒ‡å‘ç¬¬ä¸€ä¸ªç»“ç‚¹
    //ä»ç¬¬ä¸€ä¸ªç»“ç‚¹å¼€å§‹æŸ¥æ‰¾æ•°æ®åŸŸä¸ºeçš„ç»“ç‚¹
    while(p!=NULL && p->data != e){
        p = p->next;
    }
    return p;           //æ‰¾åˆ°åè¿”å›è¯¥ç»“ç‚¹æŒ‡é’ˆ
}
```
### 5.å¤´æ’æ³•åŸåœ°é€†åºâœ¨ğŸš¦ğŸ“X2

```c
LinkList Reverse(LinkList &L)//LNode *Reverse(LinkList L)
{
	LNode *p, *r;
	p = L->next;        //pæŒ‡é’ˆæŒ‡å‘ç¬¬ä¸€ä¸ªç»“ç‚¹
	L->next = NULL;     //å¤´ç»“ç‚¹æŒ‡å‘NULL
	while (p != NULL){  //ä¾æ¬¡å°†å…ƒç´ èŠ‚ç‚¹æ‘˜ä¸‹
		r = p->next;    //æš‚å­˜pçš„åç»§
		p->next = L->next; //å°†pèŠ‚ç‚¹æ’å…¥åˆ°å¤´ç»“ç‚¹ä¹‹å//æ— å¤´èŠ‚ç‚¹L->nextæ¢æˆL
		L->next = p;
		p=r;
	}
	return L;
}
```
### åˆ¤æ–­é“¾è¡¨å…ƒç´ é€’å¢âœ¨ğŸ“š

```c
//åˆ¤æ–­é“¾è¡¨å…ƒç´ é€’å¢  è¯•å·æ˜¯é€’å‡
bool Judge(LinkList L){ 
	LNode *p=L->next;         
	if(p==NULL) return true;    
	while(p->next!=NULL){
		if(p->data<=p->next->data)
			p=p->next;
		else
			return false;			
	}
	return true;
}
```

### 2.åˆ é™¤å•é“¾è¡¨å€¼ä¸ºxçš„ç»“ç‚¹âœ¨ğŸ“š

```c
//åˆ é™¤å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ä¸­å€¼ä¸ºxçš„ç»“ç‚¹
void delX(LinkList &L,int x){
    LNode *p=L->next,*pre=L,*q;//preæŒ‡å‘pçš„å‰é©±
    while(p!=NULL){
            if(p->data==x){
				q=p;
                p=p->next;//æ³¨æ„è¿™é‡Œåˆ é™¤åˆ†å¼€æ˜¯ä¿ç•™p
                pre->next=p; //åˆ é™¤qèŠ‚ç‚¹
                free(q);      
           }
            else{			 
				pre=p;      // pre å’Œ p åŒæ­¥åç§»
                p=p->next; 
                }
        }
}
```

### ä¹ é¢˜

#### 1.é€’å½’åˆ é™¤ä¸å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ä¸­å€¼ä¸ºxçš„ç»“ç‚¹

```c
//é€’å½’åˆ é™¤ä¸å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ä¸­å€¼ä¸ºxçš„ç»“ç‚¹Y
void dex_x(LinkList &L,int x){
    LNode *p;
    if(L==NULL)
        return;
    if(L->data==x){
        p=L;
        L=L->next;
        free(p);
        dex_x(L,x);
    }
    else
        dex_x(L->next,x);
}
```



#### 4.åˆ é™¤å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ä¸­æœ€å°å€¼çš„ç»“ç‚¹

```c
//åˆ é™¤å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ä¸­æœ€å°å€¼çš„ç»“ç‚¹Y
LinkList Del_Min(LinkList &L){
    LNode *pre=L,*p=pre->next;//pä¸ºå·¥ä½œæŒ‡é’ˆ,preæŒ‡å‘å‰é©±
    LNode *minpre=pre,*minp=p;//ä¿å­˜æœ€å°å€¼èŠ‚ç‚¹åŠå…¶å‰é©±
    while(p!=NULL){
        if(p->data<minp->data){//æ‰¾åˆ°æ›´å°
            minp=p;
            minpre=pre;
        }
        pre=p;	//ç»§ç»­æ‰«æä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        p=p->next;
    }
    minpre->next=minp->next;	//åˆ é™¤æœ€å°å€¼èŠ‚ç‚¹
    free(minp);
    return L;
}
```

#### 6.ä½¿å¸¦å¤´ç»“ç‚¹å•é“¾è¡¨å…ƒç´ é€’å¢æœ‰åºï¼ˆæ’å…¥æ’åºï¼‰âœ¨ğŸš¦

```c
//ä½¿å¸¦å¤´ç»“ç‚¹å•é“¾è¡¨å…ƒç´ é€’å¢æœ‰åºY
void Sort(LinkList &L){
    LNode *p=L->next,*pre;
    LNode *r=p->next;	//rä¿æŒ*påç»§æŒ‡é’ˆä¿è¯ä¸æ–­é“¾
    p->next=NULL;		//æ„é€ åªå«ä¸€ä¸ªæ•°æ®èŠ‚ç‚¹çš„æœ‰åºè¡¨
    p=r;				//æ–­å¼€ä¸€ä¸ªåæ‹¿åˆ°å…¶åé¢
    while(p!=NULL){
        r=p->next; 		//ä¿å­˜*pçš„åç»§æŒ‡é’ˆ
        pre=L;
        while(pre->next!=NULL && pre->next->data<p->data)
            pre=pre->next;//åœ¨æœ‰åºè¡¨ä¸­æŸ¥æ‰¾æ’å…¥*pçš„å‰é©±èŠ‚ç‚¹*pre
        p->next=pre->next;//å°†*pæ’å…¥åˆ°*preä¹‹å
        pre->next=p;
        p=r;			  //æ‰«æåŸå•é“¾è¡¨ä¸­å‰©ä¸‹çš„èŠ‚ç‚¹
    }
}
```

#### 7.åˆ é™¤å¸¦å¤´ç»“ç‚¹å•é“¾è¡¨ä»‹äºä¸¤å€¼ä¹‹é—´å…ƒç´ ğŸš¦

```c
//7.åˆ é™¤å¸¦å¤´ç»“ç‚¹å•é“¾è¡¨ä»‹äºä¸¤å€¼ä¹‹é—´å…ƒç´ Y
void RangeDelete(LinkList &L,int min,int max){
    LNode *pre=L,*p=L->next;	//pæ£€æµ‹æŒ‡é’ˆï¼Œpreå‰é©±
    while(p!=NULL)
        if(p->data>min&&p->data<max){
            pre->next=p->next;
            free(p);
            p=pre->next;
        }
    	else{
            pre=p;
            p=p->next;
        }
}
```

#### 9.é€’å¢è¾“å‡ºå•é“¾è¡¨å„èŠ‚ç‚¹å¹¶åˆ é™¤ 

```c
//9.é€’å¢è¾“å‡ºå•é“¾è¡¨å„èŠ‚ç‚¹å¹¶åˆ é™¤ Y
/*å¯¹é“¾è¡¨è¿›è¡Œéå†ï¼Œæ¯æ¬¡æ‰¾åˆ°æ•´ä¸ªé“¾è¡¨æœ€æœ€å°å€¼å…ƒç´ åˆ é™¤*/
void MIn_Delete(LinkList &head){//headä¸ºå¤´æŒ‡é’ˆ
    while(head->next!=NULL){//å¾ªç¯åˆ°ä»…å‰©å¤´ç»“ç‚¹
        LNode *pre=head;
        LNode *p=pre->next;
        while(p->next!=NULL){
            if(p->next->data<pre->next->data)
                pre=p;//è®°ä½å½“å‰æœ€å°èŠ‚ç‚¹å‰é©±
            p=p->next;
        }
        printf("%d",pre->next->data);
        LNode* u=pre->next;	
        pre->next=u->nexr;	//åˆ é™¤é‡Šæ”¾ç©ºé—´
        free(u);
    }
    free(head);
}
```

#### 10.å°†Aæ‹†åˆ†ä¸ºAå­˜å¥‡æ•°Bå­˜å¶æ•°

```c
//10.å°†Aæ‹†åˆ†ä¸ºAå­˜å¥‡æ•°Bå­˜å¶æ•°
LinkList DisCreat_1(LinkList &A)
{
    int i=0;
	LinkList B;
    B = (LinkList)malloc(sizeof(LNode));
    B->next = NULL;
    LNode *ra = A,*rb = B;	//Aï¼ŒBå°¾ç»“ç‚¹
    LNode *p = A->next
    A->next = NULL;
    while(p!=NULL)
    {
        i++;
        if(i%2==0)		//å¤„ç†åºå·ä¸ºå¶æ•°èŠ‚ç‚¹
        {
            rb->next = p;//è¡¨å°¾æ’å…¥
            rb = p;//å°¾æŒ‡é’ˆç§»åŠ¨
        }
        else
        {
            ra->next = p;
            ra = p;
        }
        p = p->next;
    }
    ra->next = NULL;
    rb->next = NULL;
    return B;
}
```

#### 12.åˆ é™¤é€’å¢å•é“¾è¡¨ç›¸åŒå…ƒç´ 

```c
//(7,10,10,21,30,42,42,42,51,70) ->(7,10,21,30,42,51,70)
void Del_Same(LinkList &L){
    LNode *p=L->next,*q;
    if(p==NULL)
        return;
    while(p->next!=NULL){
        q=p->next;
        if(p->data==q->data);{ 	//æ‰¾åˆ°é‡å¤èŠ‚ç‚¹
            p->next=q->next;	//é‡Šæ”¾*qèŠ‚ç‚¹
            free(q);			//é‡Šæ”¾ç›¸åŒå…ƒç´ èŠ‚ç‚¹
        }
        else
            p=p->next;
        	
    }
}
```

#### 14.äº§ç”Ÿå…¬å…±å…ƒç´  C=AnB

```c
void Get_Common(LinkList A,LinkList B){
    LNode *p=A->next,*q=B->next,*r,*s;
    LinkList C=(LinkList)malloc(sizeof(LNode));
    LNode * r=C;
    while(p!=NULL&&q!=NULL){
        if(p->data<q->data)
            p=p->next;//Açš„å…ƒç´ è¾ƒå°åç§»æŒ‡é’ˆ
        else if(p->data>q->data)
            q=q->next;//Bçš„å…ƒç´ è¾ƒå°åç§»æŒ‡é’ˆ
        else{//ç›¸ç­‰
            s=(LNode*)malloc(sizeof(LNOde));
            s->data=p->data;
            r->next=s; 				//å°¾æ’æ³•å°†*sé“¾æ¥åˆ°C
            r=s;
            p=p->next;//åŒæ—¶ä¸‹ä¸€ä¸ª
            q=q->next;
        }
    }
    r->next=NULL;
}
```



## æ ˆå’Œé˜Ÿåˆ—

### é¡ºåºæ ˆç±»å‹å®šä¹‰

```c
typedef int ElemType 
#define MaxSize 10         //å®šä¹‰æ ˆä¸­å…ƒç´ çš„æœ€å¤§ä¸ªæ•°
typedef struct{
    ElemType data[MaxSize];       //é™æ€æ•°ç»„å­˜æ”¾æ ˆä¸­å…ƒç´ 
    int top;                      //æ ˆé¡¶å…ƒç´ 
}SqStack;

//åˆå§‹åŒ–æ ˆ
void InitStack(SqStack &S){
    S.top = -1;                   //åˆå§‹åŒ–æ ˆé¡¶æŒ‡é’ˆ
}
```
### é¡ºåºæ ˆè¿›å‡ºæ ˆ

```c
//å…¥æ ˆ
bool Push(SqStack &S, ElemType x){
    if(S.top == MaxSize - 1)  //æ ˆæ»¡
        return false;
    S.data[++S.top] = x;  ////æŒ‡é’ˆå†åŠ 1 å†å…¥æ ˆ 
    return true;
}

//å‡ºæ ˆ
bool Pop(SqStack &x, ElemType &x){
    if(S.top == -1)          //æ ˆç©º
        return false;
    x = S.data[S.top--];     //å…ˆå‡ºæ ˆ æŒ‡é’ˆå†å‡1
    return true;
}
```
### é“¾æ ˆç±»å‹å®šä¹‰ğŸ“š

```c
//æ ˆçš„é“¾å¼å­˜å‚¨
typedef struct Linknode{
	int data;
	struct Linknode *next;
}Linknode,*LiStack; 
 
//åˆå§‹åŒ–æ ˆ 
void InitStack(LiStack &L){
	L =(Linknode*)malloc(sizeof(Linknode));//åˆ›å»ºå¤´èŠ‚ç‚¹ 
	//L=new Linknode;
	L->next=NULL;	//åˆå§‹åŒ–ä¸ºç©º	
}
```

### é“¾æ ˆè¿›å‡ºæ ˆâœ¨ğŸ“š

```c
//å…¥æ ˆ    é“¾è¡¨å¤´æ’æ³•æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹
bool pushStack(LiStack &L,int e){
	Linknode *s=(Linknode *)malloc(sizeof(Linknode));
	s->data=e;
	s->next=L->next; //å¤´æ’æ³•
	L->next=s; 
	return true;
}
 
//å‡ºæ ˆ 
bool popStack(LiStack &L,int &e){
	if(L->next==NULL){ //æ ˆç©º
		return false;
	}
	Linknode *p=L->next;
	e=p->data;
	L->next=p->next;
	free(p);
	return true;
} 
```

### é¡ºåºé˜Ÿåˆ—

```c
//é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨ç±»å‹
# define MaxSize 10;     //å®šä¹‰é˜Ÿåˆ—ä¸­å…ƒç´ çš„æœ€å¤§ä¸ªæ•°
typedef struct{ //å¤§å°ä¸ºMaxSize*sizeof(ElemType)
    ElemType data[MaxSize];   //ç”¨é™æ€æ•°ç»„å­˜æ”¾é˜Ÿåˆ—å…ƒç´                        
    int front, rear;          //é˜Ÿå¤´æŒ‡é’ˆå’Œé˜Ÿå°¾æŒ‡é’ˆ
}SqQueue;
//åˆå§‹åŒ–é˜Ÿåˆ—
void InitQueue(SqQueue &Q){
    Q.rear = Q.front = 0;//åˆå§‹åŒ–æ—¶ï¼Œé˜Ÿå¤´ã€é˜Ÿå°¾æŒ‡é’ˆæŒ‡å‘0
}
```
### é“¾é˜Ÿå­˜å‚¨ç±»å‹

```c
typedef struct{      //é“¾å¼é˜Ÿåˆ—ç»“ç‚¹
    ElemType data;
    struct LinkNode *next;
}LinkNode;
typedef struct{               //é“¾å¼é˜Ÿåˆ—
    LinkNode *front, *rear;   //é˜Ÿåˆ—çš„é˜Ÿå¤´å’Œé˜Ÿå°¾æŒ‡é’ˆ
}LinkQueue;

void InitQueue(LinkQueue &Q){
    //åˆå§‹åŒ–æ—¶ï¼Œfrontã€rearéƒ½æŒ‡å‘å¤´ç»“ç‚¹
    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));
    Q.front -> next = NULL;
}
```

### é“¾å¼å…¥é˜Ÿå‡ºé˜Ÿ

```c
//æ–°å…ƒç´ å…¥é˜Ÿ 
/*å°¾æ’æ³•æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹*/
void EnQueue(LinkQueue &Q, ElemType x){
    LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode)); //ç”³è¯·ä¸€ä¸ªæ–°ç»“ç‚¹
    s->data = x;
    s->next = NULL;     //sä½œä¸ºæœ€åä¸€ä¸ªç»“ç‚¹ï¼ŒæŒ‡é’ˆåŸŸæŒ‡å‘NULL
    Q.rear->next = s;   //æ–°ç»“ç‚¹æ’å…¥åˆ°å½“å‰çš„rearä¹‹å
    Q.rear = s;         //è¡¨å°¾æŒ‡é’ˆæŒ‡å‘æ–°çš„è¡¨å°¾
}
//é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿ
/*åˆ é™¤é“¾è¡¨ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæœ€ååˆ¤æ–­æ˜¯ä¸æ˜¯å°¾èŠ‚ç‚¹*/
bool DeQueue(LinkQueue &Q, ElemType &x){
    if(Q.front == Q.rear)
        return false;             //ç©ºé˜Ÿ
    LinkNode *p = Q.front->next;  //pæŒ‡é’ˆæŒ‡å‘å³å°†åˆ é™¤çš„ç»“ç‚¹(å¤´ç»“ç‚¹æ‰€æŒ‡å‘çš„ç»“ç‚¹)
    x = p->data;
    Q.front->next = p->next;   //ä¿®æ”¹å¤´ç»“ç‚¹çš„nextæŒ‡é’ˆ     å…ˆä¿®æ”¹å¥½äº†å¤´
    if(Q.rear == p)            //æ­¤æ¬¡æ˜¯æœ€åä¸€ä¸ªç»“ç‚¹å‡ºé˜Ÿ
        Q.rear = Q.front;      //ä¿®æ”¹rearæŒ‡é’ˆ
    free(p);                   //é‡Šæ”¾ç»“ç‚¹ç©ºé—´

    return true;
}
```

### å¾ªç¯é“¾é˜Ÿå…¥é˜Ÿå‡ºé˜ŸğŸš¦

```c
//å¾ªç¯é˜Ÿåˆ—å…¥é˜Ÿ é˜Ÿå°¾æ’å…¥ï¼ˆåˆ¤æ»¡ï¼‰
bool EnQueue(SqQueue &Q, ElemType x){
    if((Q.rear+1)%MaxSize == Q.front)   //é˜Ÿæ»¡
        return false;
    Q.data[Q.rear] = x;                 //å°†xæ’å…¥é˜Ÿå°¾
    Q.rear = (Q.rear + 1) % MaxSize;   //é˜Ÿå°¾æŒ‡é’ˆåŠ 1å–æ¨¡
    return true;
}

//å‡ºé˜Ÿï¼Œåˆ é™¤ä¸€ä¸ªé˜Ÿå¤´å…ƒç´ ï¼Œç”¨xè¿”å›
bool DeQueue(SqQueue &Q, ElemType &x){
    if(Q.rear == Q.front)              //é˜Ÿç©ºæŠ¥é”™
        return false;  
    x = Q.data[Q.front];
    Q.front = (Q.front + 1) % MaxSize; //é˜Ÿå¤´æŒ‡é’ˆåç§»åŠ¨
    return true;
}
```

### ä¹ é¢˜

#### åˆ¤æ–­é“¾è¡¨æ˜¯å¦ä¸­å¿ƒå¯¹ç§°ğŸ“

```c
//åˆ¤æ–­é“¾è¡¨æ˜¯å¦ä¸­å¿ƒå¯¹ç§°
int dc(Linklist L,int n){
    int i;
    char s[n/2];//å­—ç¬¦æ ˆ
    p=L->next;//å·¥ä½œæŒ‡é’ˆ
    for(i=0;i<n/2;i++){//é“¾è¡¨å‰ä¸€åŠå…ƒç´ è¿›æ ˆ
        s[i]=p->data;
        p=p->next;
    }
    i--;//æ¢å¤æœ€åiå€¼
    if(n%2==1)
        p=p->next;	//è‹¥næ˜¯å¥‡æ•°åç§»è¿‡ä¸­å¿ƒèŠ‚ç‚¹
    while(p!=NULL&&s[i]==p->data){//æ£€æŸ¥æ˜¯å¦ä¸­å¿ƒå¯¹ç§°
        i--;	//iå½“æ ˆé¡¶æŒ‡é’ˆ
        p=p->next;
    }
    if(i==-1) //æ ˆä¸ºç©º
        return 1;
    else
        return 0;
}
```

#### åè¿›åˆ¶è½¬å…«è¿›åˆ¶ğŸš¦ğŸ“

```c
void Convert(int A[],int B[]){
    int i ,p;
    for(i=0;i<n;i++){
        p=A[i];
        clearstack(s);//InitStack(S);
        while(p!=0){
            push(s,p%8);
            p=p/8;
        }
        while(!EmptyStack(s))
            p=p*10+pop(s);
        B[i]=p;
    }
}
```



## ä¸²

```c
int BF(SString s,SString t){
	int i=0,j=0;
	while(i<=s.length && j<=t.length){
		if(s.ch[i]==t.ch[j]){
			i++;
			j++;
		}
		else
			i=i-j+1;
			j=0;
	}
	if(j>t.length)
		return i-t.length;
	else
		return 0;
}
```



## æ ‘ä¸äºŒå‰æ ‘

### æ•°ç»“æ„ä½“ç±»å‹å®šä¹‰

```c
//æ•°ç»“æ„ä½“ç±»å‹å®šä¹‰
typedef struct BTNode {
	char data;// è¿™é‡Œé»˜è®¤ç»“ç‚¹dataåŸŸä¸ºcharç±»å‹
	struct BTNode *lchild,*rchild;// å·¦æŒ‡é’ˆåŸŸ  æŒ‡é’ˆåŸŸ
} BTNode,*BiTree;
```
### éå†âœ¨

```c
//æœªè¿è¡Œ
//ä¸­åºéé€’å½’ğŸš¦   é€’å½’ğŸ“
void InOrder(BiTree T){
    InitStack(S);//BiTree* stack[MaxSize]
    BiTree p=T;
    while(p||!IsEmpty(S)){//top != -1)
        if(p){
            Push(S,P);//stack[++top]
            p=p->lchild;
        }
        else
            Pop(S,P);//stack[top--]
            visit(p);
            p=p->rchild;
        }
    }
}
//å…ˆåºéé€’å½’ï¼ˆæ·±åº¦éå†ï¼‰
void PreOrder(BiTree T){
    InitStack(S);
    BiTree p=T;
    while(p||!IsEmpty(S)){
        if(p){
            visit(p);
            Push(S,P);
            p=p->lchild;
        }
        else{
            Pop(S,P);
            p=p->rchild;//å‘å³å­æ ‘èµ°
        }
    }
}
//ååºéé€’å½’ğŸš¦
void PostOrder(BiTree T){
    InitStack(S);
    BiTree p=T,r=NULL;
    while(p||!IsEmpty(S)){
        if(p){
            Push(S,p);
            p=p->lchild;
        }
        else{
            GetTop(S,p);
            if(p->rchild&&p->rchild!=r)//è‹¥å­˜åœ¨å³å­æ ‘ä¸”æ²¡æœ‰è¢«è®¿é—®è¿‡
                p=p->rchild;//è½¬å‘å³å­æ ‘
            else{
                pop(S,p);
                visit(p->data);
                r=p;	//è®°å½•æœ€è¿‘è®¿é—®è¿‡çš„èŠ‚ç‚¹
                p=NULL;//æ¯æ¬¡å‡ºæ ˆè®¿é—®å®Œä¸€ä¸ªèŠ‚ç‚¹ç›¸å½“äºéå†å®Œä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘
            }
        }
    }
}
```

### å±‚æ¬¡éå†

```c
/*åˆå§‹å°†æ ¹å…¥é˜Ÿå¹¶è®¿é—®æ ¹ç»“ç‚¹;
è‹¥æœ‰å·¦å­æ ‘ï¼Œåˆ™å°†å·¦å­æ ‘çš„æ ¹å…¥é˜Ÿ;è‹¥æœ‰å³å­æ ‘ï¼Œåˆ™å°†å³å­æ ‘çš„æ ¹å…¥é˜Ÿ;
ç„¶åå‡ºé˜Ÿï¼Œè®¿é—®è¯¥ç»“ç‚¹;åå¤è¯¥è¿‡ç¨‹ç›´åˆ°é˜Ÿåˆ—ç©ºä¸ºæ­¢*/
//äºŒå‰æ ‘çš„ç»“ç‚¹(é“¾å¼å­˜å‚¨)
typedef struct BiTnode{
   ElemType data;          
   struct BiTNode *lchild, *rchild; 
}BiTNode, *BiTree;

//é“¾å¼é˜Ÿåˆ—ç»“ç‚¹
typedef struct LinkNode{
   BiTNode * data;
   struct LinkNode *next;
}LinkNode;

typedef struct{
   LinkNode *front, *rear;  
}LinkQueue;

//å±‚åºéå†
void LevelOrder(BiTree T){
   LinkQueue Q;
   InitQueue (Q);          //åˆå§‹åŒ–è¾…åŠ©é˜Ÿåˆ—
   BiTree p;
   EnQueue(Q,T);           //å°†æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
   while(!isEmpty(Q)){     //é˜Ÿåˆ—ä¸ç©ºåˆ™å¾ªç¯
      DeQueue(Q,p);        //é˜Ÿå¤´ç»“ç‚¹å‡ºé˜Ÿ
      visit(p);            //è®¿é—®å‡ºé˜Ÿç»“ç‚¹
      if(p->lchild != NULL)
         EnQueue(Q,p->lchild);   //å·¦å­©å­å…¥é˜Ÿ
      if(p->rchild != NULL)
         EnQueue(Q,p->rchild);   //å³å­©å­å…¥é˜Ÿ
   }
}
```



### çº¿ç´¢åŒ–

ä¸­åºçº¿ç´¢åŒ–

```c
//ä¸­åºçº¿ç´¢åŒ–èŠ‚ç‚¹
typedef sturct ThreadNOde{
    ElemType data;
    struct ThreadNOde *lchild,*rchild;
    int ltag,rtag;
}ThreadNOde,*ThreadTree;
//ä¸­åºéå†äºŒå‰æ ‘ï¼Œä¸€è¾¹éå†ä¸€éçº¿ç´¢åŒ–
void InThread(ThreadTree T){
    if(T!=NULL){
        InThread(T->lchild);
        visit(T);
        Inthread(T->rchild);
    }
}
void visit(ThreadNode *q){
    if(q->lchild==NUll){//å·¦å­æ ‘ä¸ºç©ºå»ºç«‹å‰é©±çº¿ç´¢
        q-lchild=pre;
        q->ltag=1;
    }
    if(pre!=NULL&&q->rchild==NULL){
        pre->rchild=q;
        pre->rtag=1;
    }
    pre=q;
}
ThreadNode *pre=NULL;
//ä¸­åºçº¿ç´¢åŒ–äºŒå‰æ ‘T
void CreateInThread(ThreadTree T){
    pre=NULL;
    if(T!=NULL){		//éç©ºäºŒå‰æ ‘æ‰èƒ½çº¿ç´¢åŒ–
        Inthread(T);	//ä¸­åºçº¿ç´¢åŒ–äºŒå‰æ ‘
        if(pre->rchild==NULL)
            pre->rtag=1;//å¤„ç†æœ€åä¸€ä¸ªèŠ‚ç‚¹
    }
}
```

ä¸­åºçº¿ç´¢åŒ–2

```c
/*
å·¦å­æ ‘ä¸ºç©ºå»ºç«‹å‰é©±çº¿ç´¢ï¼Œå‰é©±å³å­æ ‘ä¸ºç©ºå»ºç«‹åç»§çº¿ç´¢
*/
void Inthread(ThreadTree &p,ThreadTree &pre){
    if(p!=NULL){
        InThread(p->lchild,pre);
   		if(p->lchild==NUll){						//å·¦å­æ ‘ä¸ºç©ºå»ºç«‹å‰é©±çº¿ç´¢
        	p->lchild=pre;
       	 	p->ltag=1;
    	}
    	if(pre!=NULL&&pre->rchild==NULL){			//åç»§çº¿ç´¢
        	pre->rchild=p;
        	pre->rtag=1;
    	}
    	pre=p;
        Inthread(p->rchild,pre);
    }
}
//ä¸­åºçº¿ç´¢åŒ–äºŒå‰æ ‘T
void CreateInThread(ThreadTree T){
    ThreadNode pre=NULL;
    if(T!=NULL){		//éç©ºäºŒå‰æ ‘æ‰èƒ½çº¿ç´¢åŒ–
        Inthread(T,pre);	//ä¸­åºçº¿ç´¢åŒ–äºŒå‰æ ‘
        pre->rchild=NULL;//å¤„ç†æœ€åä¸€ä¸ªèŠ‚ç‚¹
        pre->rtag=1;
    }
}
```

å…ˆåºçº¿ç´¢åŒ–

```c
void preThread(ThreadTree p,ThreadTree &pre){
    if(p!=NULL){
        if(p->lchild==NUll){//å·¦å­æ ‘ä¸ºç©ºå»ºç«‹å‰é©±çº¿ç´¢
       		p->lchild=pre;
       		p->ltag=1;
    	}
    	if(pre!=NULL&&pre->rchild==NULL){
        	pre->rchild=p;
        	pre->rtag=1;
    	}
    	pre=p;
        if(p->ltag==0){//é˜²æ­¢è½¬åœˆ	
            PreThread(p->lchild,pre);	//å·¦å­æ ‘
        }
        PreThread(p->rchild,pre);		//å³å­æ ‘
    }
}
//å…ˆåºçº¿ç´¢åŒ–äºŒå‰æ ‘T
void CreateInThread(ThreadTree T){
    ThreadNode pre=NULL;
    if(T!=NULL){		//éç©ºäºŒå‰æ ‘æ‰èƒ½çº¿ç´¢åŒ–
        Inthread(T,pre);	//ä¸­åºçº¿ç´¢åŒ–äºŒå‰æ ‘
        pre->rchild=NULL;//å¤„ç†æœ€åä¸€ä¸ªèŠ‚ç‚¹
        pre->rtag=1;
    }
}
```

ååºçº¿ç´¢åŒ–

```c
//ååºçº¿ç´¢åŒ–
void PostThread(BiThrTree p)
{
    if (p!=NULL)
    {
        PostThread(p->lchild);           //å·¦å­æ ‘çº¿ç´¢åŒ–
        PostThread(p->rchild);           //å³å­æ ‘çº¿ç´¢åŒ–
        if (p->lchild==NUll)                     //å‰é©±çº¿ç´¢
        {
            p->lchild=pre;
       		p->ltag=1;
        }
        if(pre!=NULL&&pre->rchild==NULL){
        	pre->rchild=p;
        	pre->rtag=1;
    	}
    	pre=p;
        //visit(pre->data);
    }
    
void CreateInThread(ThreadTree T){
    ThreadNode pre=NULL;
    if(T!=NULL){		//éç©ºäºŒå‰æ ‘æ‰èƒ½çº¿ç´¢åŒ–
        PostThread(T,pre);	//ä¸­åºçº¿ç´¢åŒ–äºŒå‰æ ‘
        pre->rchild=NULL;//å¤„ç†æœ€åä¸€ä¸ªèŠ‚ç‚¹
        pre->rtag=1;
    }
}
```



### è¾“å…¥åˆ›å»ºäºŒå‰æ ‘

```c++
//ABC##DE##F##GH### 
void CreatBiNode(BTNode **Node) { //æ­¤å¤„åº”æ³¨æ„ä¼ é€’çš„å‚æ•°ï¼ˆäºŒé‡æŒ‡é’ˆï¼‰
	char data;
	scanf("%c", &data);
	*Node = (BiTree)malloc(sizeof(BTNode));
	if (data == '#') {
		*Node = NULL;
	} else if ((data != '#') && (*Node)) {
		(*Node)->data = data;
		(*Node)->lchild = NULL;
		(*Node)->rchild = NULL;
		CreatBiNode(&(*Node)->lchild);
		CreatBiNode(&(*Node)->rchild);
	}
}

//æ„å»ºäºŒå‰æ’åºæ ‘ï¼Œé€šè¿‡é€ä¸ªæ’å…¥æ³•
int BST_Insert(BiTree &T,ElemType k){   //æ³¨æ„Tå‰é¢è¦æœ‰å¼•ç”¨&ã€‚ 
    if(T==NULL){
        T=(BiTree)malloc(sizeof(BiTNode));
        T->data=k;
        T->lchild=T->rchild=NULL;
        return 1;
    }
    else if(T->data==k)return 0;
    else if(k<T->data) return BST_Insert(T->lchild,k);
    else return BST_Insert(T->rchild,k);
}
void BST_Create(BiTree &T,ElemType a[],int n){
    T=NULL;
    for(int i=0;i<n;i++){
        BST_Insert(T,a[i]);
    }

```
### äºŒå‰æ’åºæ ‘æ’å…¥ğŸ“

```c
int BST_Insert(BiTree &T,KeyType k){
    if(T==NULL){
        T=(BiTree)malloc(sizeof(BSTNode));
        T->key=k;
        T->lchild=T->rchild=NULL;
        return 1;
    }
    else if(k==T->key)
        return 0;
    else if(k<T->key)
        return BST_Insert(T->lchild,k);
    else
        return BST_Insert(T->rchild,k);
}
```

### åˆ é™¤ğŸš¦

```c
//åˆ é™¤äºŒå‰æ’åºæ ‘ä¸å°äºxçš„èŠ‚ç‚¹ï¼ˆå¤§äºç­‰äºï¼‰
void Delete(BiTree &T,int x){
    if(T->rchild)//å³å­æ ‘
        Delelte(T->rchlid,x);
    if(T->data<x) exit();//
    q=T;
    T=T->lchild;
    free(q);	//å¦‚æœæ ‘æ ¹ä¸å°äºx,åˆ é™¤æ ‘æ ¹ï¼Œå¹¶ä»¥å·¦å­æ ‘çš„æ ¹ä½œä¸ºæ–°çš„æ ‘æ ¹
    if(T)
        Delete(T,x);  //å·¦å­æ ‘
}




// éé€’å½’åˆ é™¤ä»¥Tä¸ºæ ¹çš„äºŒå‰æ’åºæ ‘
void DelTree(BSTree &T) {
    BSTree S[N] = {};// æ ˆ, å®¹é‡è¶³å¤Ÿå¤§, æ ˆä¸­å…ƒç´ æ˜¯äºŒå‰æ’åºæ ‘ç»“ç‚¹çš„æŒ‡é’ˆ
    int top = 0;
    while (T != NULL || top > 0) {
        // æ²¿å·¦åˆ†æå‘ä¸‹
        while (T != NULL) {
            S[++top] = T;
            T = T ->left;
        }
        // é€€æ ˆ, æ²¿æ ˆé¡¶ç»“ç‚¹çš„å³å­æ ‘å‘ä¸‹åˆ é™¤, é‡Šæ”¾è¢«åˆ é™¤ç»“ç‚¹ç©ºé—´
       if (top > 0) {
            BSTree p = S[top--];
            T = p ->right;
            free(p);
        }
    }
} // DelTree


//åœ¨äºŒå‰æ’åºæ ‘Tä¸­, åˆ é™¤æ‰€æœ‰å°äºç­‰äºxçš„ç»“ç‚¹
void DeleteAllx(BSTree &T, int x) {
    BSTree p = T, q = NULL;
    //æ ¹ç»“ç‚¹çš„å€¼å°äºç­‰äºx
    while (T && T ->data <= x) {
        p = T;
        T = T ->right;
        p ->right = NULL;
        DelTree(p);
    } //åˆ é™¤äºŒå‰æ ‘p,åˆ é™¤æŒç»­åˆ°â€œæ ¹â€ç»“ç‚¹å€¼å¤§äºxæˆ–Tä¸ºç©ºæ ‘ä¸ºæ­¢
    if (T) {
        q = T; p = T ->left;
        // æ²¿æ ¹ç»“ç‚¹å·¦åˆ†æå‘ä¸‹, æŸ¥å°äºç­‰äºxçš„ç»“ç‚¹
        while (p) {
            while (p && p ->data > x) {
                q = p;
                p = p ->left;
            }
            // p ç»“ç‚¹çš„å€¼å°äºç­‰äº x
            if (p) {
                q ->left = p ->right;
                p ->right = NULL;
                DelTree(p);
            }
        }
    }
}// DeleteAllx

```



### äºŒå‰æ ‘çš„é«˜åº¦(å±‚æ¬¡éå†)ğŸ‰

```c
//é€’å½’æ±‚äºŒå‰æ ‘çš„é«˜åº¦
int Height(BiTree T){
    if(!T)return 0;
    int h1=Height(T->lchild);
    int h2=Height(T->rchild);
    return (h1>h2?h1:h2)+1;
} 

//éé€’å½’æ±‚äºŒå‰æ ‘çš„é«˜åº¦ï¼Œç”¨å±‚æ¬¡éå†
int Height1(BiTree T){
    if(T!=NULL){
        BiTree Q[maxSize];
        int front=-1,rear=-1;
        int level=0,last=0;  //last=0æ˜¯å› ä¸ºç¬¬ä¸€ä¸ªå…ƒç´ å…¥é˜Ÿåï¼Œfrontçš„å€¼ä¸º0ï¼› 
        BiTree p;
        Q[++rear]=T;
        while(front<rear){
            p=Q[++front];
            if(p->lchild!=NULL) Q[++rear]=p->lchild;
            if(p->rchild!=NULL) Q[++rear]=p->rchild;    
            if(front==last){   //å‡ºé˜Ÿå…ƒç´ å¦‚æœæ˜¯æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå±‚æ¬¡+1ï¼Œä¸”æ›´æ–°lastæŒ‡å‘ä¸‹ä¸€å±‚çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚ 
                level++;
                last=rear;    //lastæŒ‡å‘ä¸‹ä¸€å±‚çš„æœ€åä¸€ä¸ªç»“ç‚¹ã€‚ 
            }
        }
    return level;
    }
}
```
### äºŒå‰æ ‘å®½åº¦

```c
//é€’å½’
int Max=0;
int conut_[MaxSize];//count[k]æ•°ç»„ç”¨æ¥å‚¨å­˜æ¯ä¸€å±‚çš„å®½åº¦ï¼Œæ¯æ¬¡é€’å½’k+1ä»£è¡¨å±‚æ¬¡+1ï¼Œ
int getWidth(BiTree T,int k){ //kå˜é‡ä¸ºå½“å‰å±‚æ•° é»˜è®¤ä»ç¬¬ä¸€å±‚å¼€å§‹
	if(T==NULL)// Tä¸ºç©ºç›´æ¥è¿”å›
		return;
	else
	   conut_[k]++;// Tä¸ä¸ºç©ºconut_[k]++
	if(conut_[k]>Max)
		Max=conut_[k];	//Maxä¸ºæ•°ç»„çš„æœ€å¤§å€¼
	getWidth(T->lchild,k+1);
	getWidth(T->Rchild,k+1);
	return Max;
}

//éé€’å½’
int Btdepth2(BiTree T){
	if(!T)
	   return 0;
    int font=-1,rear=-1;
    int last=0,ever=0;//lastæŒ‡å‘å½“å‰å±‚çš„æœ€å³ç»“ç‚¹
    int max=0,width=0;//max ä¿å­˜ä¸Šä¸€å±‚å®½åº¦ï¼Œwidthä¿å­˜æœ¬å±‚å®½åº¦
    BiTree Q[Maxsize];//åˆå§‹åŒ–é˜Ÿåˆ—Q,å…ƒç´ æ˜¯äºŒå‰æ ‘ç»“ç‚¹æŒ‡é’ˆ
    Q[++rear]=Tï¼›   //æ ¹ç»“ç‚¹å…¥é˜Ÿ
    BiTree p;
    while(front<rear){//é˜Ÿä¸ç©ºå¾ªç¯
    	p=Q[++front];  width++  
    	if(p->lchild)
    	   Q[++rear]=p->lchild;
 	    if(p->rchild)
 	       Q[++rear]=p->rchild;
        if(front==last){//å¤„ç†è¯¥å±‚çš„æœ€å³ç»“ç‚¹
		   if(max<width)
		      max=width; //è‹¥è¯¥å±‚çš„å®½åº¦å¤§äºmaxï¼Œèµ‹å€¼
		   last=rear;//
		   width=0;//æ¯ä¸€å±‚å®½åº¦ç½®ç©ºä¸€æ¬¡
		}
	}
	return max;
}

```



### åˆ¤æ–­æ˜¯å¦æ˜¯å®Œå…¨äºŒå‰æ ‘

```c
int isCompleted(BiTree T){
    if(!T)return 1;
        BiTree Q[maxSize];
        int front=-1,rear=-1;
        BiTree p;
        Q[++rear]=T;
        while(front<rear){
            p=Q[++front];
            if(p){              //ç»“ç‚¹éç©ºï¼Œå·¦å³å­æ ‘çš„éƒ½å…¥é˜Ÿï¼Œç©ºç»“ç‚¹ä¹Ÿè¦ã€‚ 
                Q[++rear]=p->lchild;
                Q[++rear]=p->rchild;
            }
            else{
                while(front<rear){//åªè¦å‡ºç°ç©ºç»“ç‚¹åˆ™å¾ªç¯æ£€æŸ¥åé¢çš„ç»“ç‚¹æ˜¯å¦æœ‰éç©ºç»“ç‚¹ã€‚ 
                    p=Q[++front];
                    if(p!=NULL)//åé¢å‡ºç°ä¸ä¸ºç©ºçš„åˆ™ä¸æ˜¯
                        return 0;
                }
            }
        }
    return 1;    
}
```
### ä»¥xèŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘é«˜åº¦ğŸš¦ğŸ‰

```c
int Get_Sub_Depth(Bitree t,int x){
    if(T->data==x){
        printf("%d",Get_depth(T));
        exit 1;
    }
    else{
        if(T->lchild) Get_depth(T->lchild,x);
        if(T->rchild) get_depth(T->rchild,x);
    }
}
int Get_Depth(Bitree T){
    if(!T)return 0;
    else{
        m=Get_Depth(T->lchild);
        n=Get_Depth(T->rchild);
        return(m>n? m:n)+1;
    }
}
```



### åˆ¤æ–­æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘

```c
//æœªè¿è¡Œ
void Judge_AVL(BiTree bt ,int &balance,int &h){//hä¸ºäºŒå‰æ ‘bté«˜åº¦
    int bl=0,br=0,hl=0,hr=0;
    if(bt==NULL){//btä¸ºç©ºæ ‘
        h=0;
        balance=1;
    }
    else if(bt->lchild==NULL&&bt->rchild==NULL){//ä»…æœ‰æ ¹èŠ‚ç‚¹
        h=1;
        balance=1;
    }
    else{
        Judge_AVL(bt->lchild,bl,hl);//é€’å½’åˆ¤æ–­å·¦å­æ ‘
        Judge_AVL(bt->rchild,br,hr);//é€’å½’åˆ¤æ–­å³å­æ ‘
        h=(hl>hr? hl:hr)+1;//btçš„é«˜åº¦ä¸ºæœ€é«˜å­æ ‘çš„é«˜åº¦+1
        if(abs(hl-hr)<2)
            balance=br&&bl;//å·¦å³å­æ ‘éƒ½å¹³è¡¡
        else
            balance=0;            
    }
}
```





### äº¤æ¢å·¦å³å­æ ‘ğŸš¦ğŸ“

```c
//æŠŠäºŒå‰æ ‘æ‰€æœ‰ç»“ç‚¹çš„å·¦å³å­æ ‘è¿›è¡Œäº¤æ¢,å¦‚æœç”¨ä¸­åºéå†ï¼Œæ°å¥½ååºã€‚ 
void swap(BiTree T){
    if(T!=NULL){
        BiTree temp;
        swap(T->lchild);
        swap(T->rchild);
        temp=T->lchild;
        T->lchild=T->rchild;
        T->rchild=temp;
    }
} 
//å±‚æ¬¡éå†äº’æ¢ğŸ“
void swap(BiTree T){
   LinkQueue Q;
   InitQueue (Q);          //åˆå§‹åŒ–è¾…åŠ©é˜Ÿåˆ—
   BiTree p;
   EnQueue(Q,T);           //å°†æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
   while(!isEmpty(Q)){     //é˜Ÿåˆ—ä¸ç©ºåˆ™å¾ªç¯
      DeQueue(Q,p);        //é˜Ÿå¤´ç»“ç‚¹å‡ºé˜Ÿ
      //visit(p);            //è®¿é—®å‡ºé˜Ÿç»“ç‚¹
      BiTree temp=p->lchild;
      p->lchild=p->rchild;
      p->rchild=temp;
      if(p->lchild != NULL)
         EnQueue(Q,p->lchild);   //å·¦å­©å­å…¥é˜Ÿ
      if(p->rchild != NULL)
         EnQueue(Q,p->rchild);   //å³å­©å­å…¥é˜Ÿ
   }
}
```
### å¶å­èŠ‚ç‚¹ä¸ªæ•°âœ¨ğŸš¦ğŸ“šğŸ‰

```c
 //å¶å­èŠ‚ç‚¹ä¸ªæ•°ğŸ“šğŸ“
int Leafcount(BiTree T)
{  if (!T) //if (T == NULL)
      return 0;
   if (!T->lchild && !T->rchild) //tree->lchild == NULL&&tree->rchild == NULL
	   return 1;
   else
	   return Leafcount(T->lchild) + Leafcount(T->rchild);
}
//èŠ‚ç‚¹ä¸ªæ•°
int Nodecount1(BiTree T)
{  if (T==NULL)
      return 0;  
   else
	   return Nodecount1(T->lchild) + Nodecount1(T->rchild)+1;
}


void count(blink bt,int *leaf,int *node )
{//æ±‚äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°å’Œå¶å­æ•°ï¼Œä½¿ç”¨ä¼ åœ°å€çš„æ–¹æ³•ï¼Œè°ƒç”¨ç¨‹åºå‰ï¼Œå¶å­æ•°å’ŒèŠ‚ç‚¹æ•°è¦åˆå§‹åŒ–ä¸º0
	if(bt)
	{
		(*node)++;//èŠ‚ç‚¹æ•°å¢åŠ 
		if(bt->lchild==NULL&&bt->rchild==NULL)
			(*leaf)++;//å¶å­æ•°å¢åŠ 
		count(bt->lchild,leaf,node);//è®¡ç®—å·¦å­æ•°
		count(bt->rchild,leaf,node);//è®¡ç®—å³å­æ ‘
	}
}


//åŒåˆ†æ”¯ç»“ç‚¹æ•° ï¼ˆé€’å½’ï¼‰ 
int TwoBranchNum(BiTree T){
    int n=0;         //æ­¤å¤„æŠŠnçš„åˆå€¼è®¾ä¸º0éå¸¸é‡è¦ã€‚ï¼ï¼ï¼ 
    if(!T)return 0;
    if(T->lchild!=NULL&&T->rchild!=NULL)n=1;
    int num1=TwoBranchNum(T->lchild);
    int num2=TwoBranchNum(T->rchild);
    return num1+num2+n;
}
```
### åˆ¤æ–­æ˜¯å¦æ˜¯äºŒå‰æ’åºæ ‘âœ¨ğŸš¦ğŸ“š

```c
//é€’å½’
/*å¦‚æœäºŒå‰æ ‘ä¸ºäºŒå‰æ’åºæ ‘ï¼Œé‚£ä¹ˆä¸­åºéå†è¯¥æ ‘åº”è¯¥è¾“å‡ºæœ‰åºç»“æœï¼Œ
  æ¯æ¬¡è¾“å‡ºçš„å€¼åº”è¯¥æ¯”å…¶å‰é©±çš„å€¼è¦å¤§ï¼Œå¦åˆ™ä¸æ˜¯äºŒå‰æ’åºæ ‘ */

KeyType predt=-32767;
int JudgeBST(BiTree bt){
    int b1,b2;
    if(bt==NULL)
        return 1;
    else{//ä¸­åºéå†
        b1=JudgeBST(bt->lchild);
        if(b1==0||predt>=bt->data)//å‰é©±å¤§äºåé¢ä¸€ä¸ªåˆ™ä¸æ˜¯
            return 0;
        predt=bt->data;//ä¿ç•™å½“å‰èŠ‚ç‚¹çš„å…³é”®å­—
        b2=JudgeBST(bt->rchild);
        return b2;
    }
}
//éé€’å½’
#define max 999
#define min -999
int judge(BiTree bt){
    BiTNode *S[max],*p=bt;
    int top=0,preval=min;
    while(p||top>0){
        if(p){					//å·¦
            s[++top]=p;
            p=p->lchild;
        }
        else{
            p=s[top--];
            //visit(p);			//ä¸­
            if(preval>p->data)
                return 0;
            preval=p->data;
            p=p->rchild;			//å³
        }
    }
    return 1;
}
```

### å¤åˆ¶ä¸€é¢—äºŒå‰æ ‘ğŸš¦

```c
btree *copy(btree *b){
    btree *p;
    if(b!=NULL){
        p=(btree*)malloc(sizeof(btree));
        p->data=b->data;
        p->left=copy(b->left);
        p->right=copy(b->right);
        return(p);
    }
    else return(NULL);
}
```

### äºŒé¢—äºŒå‰æ’åºæ ‘åˆå¹¶ä¸€é¢—ğŸš¦

```c
//äºŒé¢—äºŒå‰æ’åºæ ‘åˆå¹¶ä¸€é¢—
//æŒ‰ç…§ååºéå†é€ä¸ªè¿æ¥åˆ°å¦å¤–ä¸€é¢—æ ‘ä¸Š
void BSTreeMerge(BiTree &T,BiTree &s){
    if((s->lchild)) BSTreeMerge(T,s->lchild);//åˆå¹¶å·¦å­æ ‘
    if((s->rchild)) BSTreeMerge(T,s->rchild);//åˆå¹¶å³å­æ ‘
    insertNode(T,S);						//æ ¹
}
void insertNode(BiTree &T,BTNode &s){//æŠŠæ ‘èŠ‚ç‚¹Sæ’å…¥åˆ°T
    if(S->data>T->data){
        if(!T->rchild) T->rchild=S;
        else insertNode(T->rchild,S);
    }
    else if(S->data<T->data){
        if(!T->lchild) T->lchild=S;
        else insertNode(T->lchild,S);
    }
    S->lchild=NULL;
    S->rchild=NULL;

}
```



### æŸ¥æ‰¾èŠ‚ç‚¹ğŸ“š

```c
typedef struct  node
{
    KeyType  key ; /*å…³é”®å­—çš„å€¼*/
    struct node  *lchild,*rchild;/*å·¦å³æŒ‡é’ˆ*/
}BSTNode, *BSTree;
/*åœ¨æ ¹æŒ‡é’ˆbstæ‰€æŒ‡äºŒå‰æ’åºæ ‘bstä¸Šï¼ŒæŸ¥æ‰¾å…³é”®å­—ç­‰äºkeyçš„ç»“ç‚¹ï¼Œ
è‹¥æŸ¥æ‰¾æˆåŠŸï¼Œè¿”å›æŒ‡å‘è¯¥å…ƒç´ ç»“ç‚¹æŒ‡é’ˆï¼Œå¦åˆ™è¿”å›ç©ºæŒ‡é’ˆ*/
BSTree  SearchBST(BSTree bst, KeyType key)
{ 
    BSTree q;
    q=bst;
    while(q)
    {
        if (q->key == key) 
            return q;  /*æŸ¥æ‰¾æˆåŠŸ*/
        if (q->key > key)  
            q=q->lchild;  /*åœ¨å·¦å­æ ‘ä¸­æŸ¥æ‰¾*/
        else  
            q=q->rchild;  /*åœ¨å³å­æ ‘ä¸­æŸ¥æ‰¾*/
    }
    return NULL; /*æŸ¥æ‰¾å¤±è´¥*/
}
```
### äºŒå‰æ’åºæ ‘æœ€å¤§æœ€å°èŠ‚ç‚¹

```c
//äºŒå‰æ’åºæ ‘ï¼Œæœ€å·¦ä¸‹èŠ‚ç‚¹æœ€å°ï¼Œæœ€å³ä¸‹æœ€å¤§
//æœ€å°
KeyType MinKey(BSTNode *bt){
    while(bt->lchild!=NULL)
        bt=bt->lchild;
    return bt->data;
}
//æœ€å¤§
KeyType MinKey(BSTNode *bt){
    while(bt->rchild!=NULL)
        bt=bt->rchild;
    return bt->data;
}
```

### è¾“å‡ºäºŒå‰æ’åºæ ‘ä¸å°äºkçš„å…³é”®å­—ğŸš¦

```c
//è¾“å‡ºäºŒå‰æ’åºæ ‘ä¸å°äºkçš„å…³é”®å­— æœªæµ‹è¯•
void OutPut(SBTNode *bt,KeyType k){
    if(bt==NULL)
        return;
    if(bt->rchild!=NULL)
        OutPut(bt->rchlid,k);//é€’å½’è¾“å‡ºå³å­æ ‘èŠ‚ç‚¹
    if(bt->data>=k)
        printf("%d",bt->data);//åªè¾“å‡ºå¤§äºç­‰äºkçš„èŠ‚ç‚¹
    if(bt->lchild!=NULL)
        OutPut(bt->lchlid,k);//é€’å½’è¾“å‡ºå·¦å­æ ‘èŠ‚ç‚¹
}
```

### æ‰“å°XèŠ‚ç‚¹çš„æ‰€æœ‰ç¥–å…ˆï¼ˆè·¯å¾„ï¼‰ğŸš¦

```c
/*ï¼ˆè€ƒå‡ ç‡ä¸å¤§ï¼‰
ç®—æ³•æ€æƒ³ï¼šéé€’å½’åç»­éå†ï¼Œæœ€åè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œè®¿é—®åˆ°å€¼ä¸ºXçš„èŠ‚ç‚¹æ—¶æ ˆä¸­æ‰€æœ‰å…ƒç´ éƒ½æ˜¯è¯¥èŠ‚ç‚¹çš„ç¥–å…ˆï¼Œä¾æ¬¡å‡ºæ ˆæ‰“å°
*/
typedef struct{
    BiTree t;
    int tag;
}stack;	//	tag=0è¡¨ç¤ºå·¦å­å¥³è¢«è®¿é—®ï¼Œtag=1è¡¨ç¤ºå³å­å¥³è¢«è®¿é—®
void Search(BiTree bt,ElemType x){
    stack s[];
    top=0;
    while(bt!=NULL||top>0){
        while(bt!=NULL&&bt->data!=x){	//èŠ‚ç‚¹å…¥æ ˆ
            s[++top].t=bt;
            s[top].tag=0;	//æ²¿å·¦åˆ†æ”¯å‘ä¸‹
            bt=bt->lchild;
        }
        if(bt->data==x){
            for(int i=1;i<=top;i++)
                printf("%d",s[i].t->data);
            exit(1)	//è¾“å‡ºç»“æŸ
        }
        while(top!=0&&s[top].tag==1)
            top--;	//é€€æ ˆç©ºéå†
        if(top!=0){
            s[top].tag=1;
            bt=s[top].t->rchild;	//æ²¿å³åˆ†æ”¯å‘ä¸‹
        }
            
    }
}
//é€’å½’ é‡åˆ°xè¿”å›trueï¼Œå·¦å³å­æ ‘æœ‰ä¸€æ–¹ä¸ºtrueï¼Œè¿”å›ä¸Šä¸€å±‚ä¸ºtrue
initial stack;//åªæ˜¯ä¸ºäº†ä»æ ¹åˆ°èŠ‚ç‚¹,ä¸è¦ä¹Ÿå¯ä»¥
bool Ancesstors(Node *root,int x){
    if(!root) return;
    if(root->data==x)return true;
    if(Ancesstors(root->lchild,x) || Ancesstors(root->rchild,x)){
        //éç©ºéxå‹æ ˆ
        stack.push(root->data);
        return true;//è¿”å›ä¸Šä¸€å±‚
    }
    return false;//æ²¡æ‰¾åˆ°
}
//æœ€è¿‘å…¬å…±ç¥–å…ˆ
BiTree getLCA(BiTree T,BiTNode *p,BiTNode *q){
	if(T==NULL) //å¦‚æœTä¸ºç©ºï¼Œè¿”å›NULL
	   return NULL;
    if(T==p||T==q)//å¦‚æœTç­‰äºpæˆ–qï¼Œè¿”å›è¯¥ç»“ç‚¹
       return T;
   	BiTNode *left=getLCA(T->lchild,p,q);//æ²¿ç€å·¦å­æ ‘éå†
   	BiTNode *right=getLCA(T->rchild,p,q);//æ²¿ç€å³å­æ ‘éå†
	if(left&&right)//å¦‚æœå·¦å³ç»“ç‚¹éƒ½ä¸ç©ºï¼Œæ‰¾åˆ°ï¼Œè¿”å›T
	   return T;
    else if(left==NULL)//å¦‚æœå·¦å­æ ‘ä¸ºç©ºï¼Œè¿”å›å³å­æ ‘çš„æŸ¥æ‰¾ç»“æœ
       return right;
    else               //å¦åˆ™ï¼Œè¿”å›å·¦å­æ ‘çš„æŸ¥æ‰¾ç»“æœ
       return left;
}
```

æ ¹åˆ°è·¯å¾„

### 19.äºŒå‰æ ‘å¸¦æƒè·¯å¾„é•¿åº¦WPL

```c
//ç±»å‹å®šä¹‰
typedef struct BiTNode{
    int weight;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

int WPL(BiTree root){
    reruen wpl_PreOrder(root,0);
}
int wpl_PreOrder(BiTree root,int deep){
    static int wpl=0;
    if(root->lchild==NULL&&root->rchild=NULL)
        wpl+=deep*root->weigth;//è‹¥ä¸ºå¶èŠ‚ç‚¹ç´¯ç§¯wpl
    if(root->lchild!=NULL)
        wpl_PreOrder(root->lchild,deep+1);
    if(root->rchild!=NULL)
        wpl_PreOrder(root->rchild,deep+1);
    return wpl;
}
```



### å®šä¹‰huffmanç¼–ç çš„ç»“æ„

```c++
//å®šä¹‰huffmanç¼–ç çš„ç»“æ„ 
struct HuffManCode {
	å‚è€ƒæ ‘ç»“æ„å’Œéå†
};
```

## æŸ¥æ‰¾

#### é¡ºåºæŸ¥æ‰¾ç®—æ³•

```c
typedef struct grade
{
	int key;
}node;
int SeqSearch(SeqList R,int n,KeyType k) //é¡ºåºæŸ¥æ‰¾ç®—æ³•
{
    int i=0;
    while (i<n && R[i].key!=k) 
 {
  printf("%d ",R[i].key);
  i++;     //ä»è¡¨å¤´å¾€åæ‰¾
 }
    if (i>=n) 
  return -1;
    else 
 {
  printf("%d",R[i].key);
  return i;
 }
}
```

#### æŠ˜åŠæŸ¥æ‰¾âœ¨ğŸ“šğŸ“

```c
int Binsearch(int A[], int low, int high, int k) { 
    int mid; 
    while (low < high) { 
        mid = (low+high) / 2; 
        if (A[mid] == k) { 
            return mid; 
        } 
        else if (A[mid] > k) {
            high = mid - 1; 
        }
        else { 
            low = mid + 1; 
        } 
    }return 0; 
}

//é€’å½’
int Besearch(sqlist r,int j,int k){
    int m;
    if(i>j) return(-1);
    else{
        m=(i+j)/2;
        if(r[m].key==k)
            return m;
        if(r[m].key>k)
            return(Besearch(r,i,m-1));
        else
            return(Bserach(r,m+1,j));  
    }
}
```

## æ’åº

### ç±»å‹å®šä¹‰

```c
#define n 10
typedef int Element;
typedef struct{
    Element key;  //ä¸»å…³é”®å­—
}node;

void show(node A[]){
    for(int i=0;i<n;i++){
        printf("%3d",A[i].key);
    }
    printf("\n");
}
```

### æ’å…¥æ’åº

#### ç›´æ¥æ’å…¥âœ¨ğŸ“š

```c
//********************************************
//ç›´æ¥æ’å…¥æ’åº    &&å†™è¿‡ç¨‹
//********************************************
void InsertSort(int a[]) { 
	int i, j,temp; 
	for (i = 1; i < n; i++) { 
		if (a[i] < a[i-1]) { //è‹¥A[i]å°äºå‰é©±ç§»åˆ°
			temp = a[i]; 
			for (j = i; a[j-1] > temp && j >= 1;j--) { //æœ‰åºè¡¨é‡Œ
				a[j] = a[j-1]; //å‘åæŒªä½ jçš„å€¼tempä¿å­˜
			}
			a[j] = temp; 
		}
	} 
}

void Sort(LinkList &L){
    LNode *p=L->next,*pre;
    LNode *r=p->next;		//rä¿æŒ*påç»§æŒ‡é’ˆä¿è¯ä¸æ–­é“¾
    p->next=NULL;			//æ„é€ åªå«ä¸€ä¸ªæ•°æ®èŠ‚ç‚¹çš„æœ‰åºè¡¨
    p=r;					//æ–­å¼€ä¸€ä¸ªåæ‹¿åˆ°å…¶åé¢
    while(p!=NULL){
        r=p->next; 			//ä¿å­˜*pçš„åç»§æŒ‡é’ˆ
        pre=L;
        while(pre->next!=NULL && pre->next->data<p->data)
            pre=pre->next;	//åœ¨æœ‰åºè¡¨ä¸­æŸ¥æ‰¾æ’å…¥*pçš„å‰é©±èŠ‚ç‚¹*pre
        p->next=pre->next;	//å°†*pæ’å…¥åˆ°*preä¹‹å
        pre->next=p;
        p=r;				//æ‰«æåŸå•é“¾è¡¨ä¸­å‰©ä¸‹çš„èŠ‚ç‚¹
    }
}

void InsertSort(node a[]) { 
	int i, j; 
	node temp; 
	for (i = 1; i < n; ++i) { 
		if (a[i].key < a[i-1].key) { 
			temp.key = a[i].key; 
			for (j = i; a[j-1].key > temp.key && j >= 1; --j) { 
				a[j].key = a[j-1].key; 
			}
			a[j].key = temp.key; //å‡åçš„j
		}
	} 
}
```



#### æŠ˜åŠæ’å…¥âœ¨ğŸ“š

```c
//********************************************
//æŠ˜åŠ/äºŒåˆ†æ’å…¥æ’åº
//********************************************
void BinInsertSort(int A[]){
	int i,j,low,mid,high,temp;
	for(i=1;i<n;i++){		//	å¦‚æœé‡‡ç”¨å“¨å…µå°†A[0]ç»™å“¨å…µå¾ªç¯å‘ååŠ 1
		temp=A[i];
		low=0;high=i-1;		//äºŒåˆ†æŸ¥æ‰¾
		while(low<=high){
			mid=(low+high)/2;
			if(temp<A[mid]) 
				high=mid-1;
			else
				low=mid+1;
		}
		for(j=i-1;j>=high+1;j--) //    æƒ³è±¡  high j| low i åœ
			A[j+1]=A[j];  //åç§»
		A[j+1]=temp;	  //æ’å…¥ jå’Œhighç›¸ç­‰
	}
}
```

#### å¸Œå°”æ’åº

```c
//********************************************
//å¸Œå°”æ’åº
//********************************************
void ShellSort(int a[]) { 
	int i, j,temp,d;
	for(d=n/2;d>0;d/=2){
        //// ä¸‹é¢çš„å†…å®¹å°±æ˜¯æ’å…¥æ’åºä¸­æ‰€æœ‰çš„1æ”¹ä¸ºdï¼Œä¸€å…±æœ‰5å¤„ä¿®æ”¹ï¼Œåˆ«å¿˜äº†j-=dä¹Ÿè¦æ”¹
		for (i = d; i < n; i++) { 
			if (a[i] < a[i-d]) { 
				temp = a[i]; 
				for (j = i; a[j-d] > temp && j >= d; j-=d) { 
					a[j] = a[j-d]; 
				}
				a[j] = temp; 
			}
		} 
	}
	
}
```



### äº¤æ¢æ’åº

#### å†’æ³¡æ’åºâœ¨

```c
//********************************************
//å†’æ³¡æ’åº
//********************************************
void Bubblesort(node A[]){
    int i,j;
    node t;
    for(i=0;i<n-1;i++)
    {	int flag=1;
        for(j=n-1;j>i;j--)
        {
            if (A[j-1].key > A[j].key)
            {
                t = A[j-1];
                A[j-1] = A[j]; 
                A[j] = t;
				flag=0;
            }
        }
		if(flag) return;
    }
    show(A);
}

//åŒå‘å†’æ³¡
void BubbleSort(ElemType A[],int n){
    int low=0,hight=n-1;
    bool flag=true;
    while(low<high&&flag){
        flag=false;
        for(i=low;i<high;i++)//ä»å‰å‘åå†’æ³¡
            if(a[i]>a[i+1]){
                swap(a[i],a[i+1]);
                flag=true;
            }
        high--;//æ›´æ–°ä¸Šç•Œ
        for(i=high;i>low;i--)//ä»åå¾€å‰å†’æ³¡
            if(a[i]<a[i-1]){
                swap(a[i],a[i-1]);
                flag=true;
            }
        low++;
    }
}
```

#### å¿«é€Ÿæ’åºâœ¨ğŸ“šğŸ“

```c
//********************************************
//å¿«é€Ÿæ’åº1   è¦æ±‚å†™æ—¶é—´å¤æ‚åº¦
//********************************************
int Partition(int A[], int low, int high){
	int pivot=A[low];   //æ¢è½´
	while(low<high){
		while(low<high&&A[high]>=pivot)
			high--;				//--high
		A[low]=A[high]; //æ¯”æ¢è½´å°çš„å…ƒç´ ç§»åˆ°å·¦ç«¯
		while(low<high&&A[low]<=pivot)
			low++;				//++low
		A[high]=A[low]; //æ¯”æ¢è½´å¤§çš„å…ƒç´ ç§»åˆ°å³ç«¯
	}
	A[low]=pivot;  		//å°†æ¢è½´å…ƒç´ å­˜æ”¾åˆ°æœ€ç»ˆä½ç½®
	return low;
}

void QuickSort(int A[], int low, int high){
    if (low < high)
    {
		int pivotpos=Partition(A,low,high);
		QuickSort(A, low, pivotpos - 1);//é€’å½’åœ°å¯¹tempå·¦è¾¹çš„å…³é”®å­—è¿›è¡Œæ’åº
        QuickSort(A, pivotpos+1, high);//é€’å½’åœ°å¯¹tempå³è¾¹çš„å…³é”®å­—è¿›è¡Œæ’åº

    }
}

//è¦æ±‚æ”¹å˜éå†æ–¹å‘æ¢è½´çš„æƒ…å†µä¸‹å»ºè®®ç”¨è¿™ä¸ªæ”¹
//********************************************
//å¿«é€Ÿæ’åº2
//********************************************
void QuickSort(node a[], int low, int high)
{
    node temp;
    int i = low, j = high;
    if (low < high)
    {
        temp.key = a[low].key;//è®°å½•ç¬¬ä¸€ä¸ªæ•°ä½œä¸ºæ¢è½´
        //å°†å°äºæ¢è½´çš„å…³é”®å­—æ”¾åœ¨æ¢è½´å·¦è¾¹ï¼Œå°†å¤§äºæ¢è½´çš„å…³é”®å­—æ”¾åœ¨æ¢è½´å³è¾¹
        while(i < j)
        {
            //ä»å³å‘å·¦æ‰«æï¼Œå¦‚æœå³è¾¹çš„æ•°æ¯”æ¢è½´å¤§ï¼Œä½ç½®ä¸å˜ï¼Œjå‘å·¦ç§»åŠ¨
            while (j > i && a[j].key >= temp.key)//ä¸€è¶Ÿæ—¶>=0
                --j;
            //æŠŠè¦äº¤æ¢çš„å…³é”®å­—è¦†ç›–æ‰æ¢è½´æ‰€å¯¹åº”çš„içš„ä½ç½®ï¼Œiå³ç§»ä¸€ä½
            if (i < j)//ä¸€è¶Ÿæ—¶çœç•¥
            {
                a[i].key = a[j].key;
                ++i;
            }
            //ä»å·¦å¾€å³æ‰«æï¼Œå¦‚æœå·¦è¾¹çš„æ•°æ¢è½´å°ï¼Œä½ç½®ä¸å˜ï¼Œiå‘å³ç§»åŠ¨
            while (i < j && a[i].key <= temp.key)//ä¸€è¶Ÿæ—¶<0
                ++i;
            //æŠŠè¦äº¤æ¢çš„å…³é”®å­—è¦†ç›–æ‰æ¢è½´æ‰€å¯¹åº”çš„jçš„ä½ç½®ï¼Œjå·¦ç§»ä¸€ä½
            if (i < j)//ä¸€è¶Ÿæ—¶a[i],a[j]äº¤æ¢
            {
                a[j].key = a[i].key;
                --j;
            }
            a[i].key = temp.key;//æŠŠæ¢è½´çš„ç©ºç¼ºè¡¥ä¸Š
            QuickSort(a, low, i - 1);//é€’å½’åœ°å¯¹tempå·¦è¾¹çš„å…³é”®å­—è¿›è¡Œæ’åº
            QuickSort(a, i+1, high);//é€’å½’åœ°å¯¹tempå³è¾¹çš„å…³é”®å­—è¿›è¡Œæ’åº
        }
    }
}
```

### é€‰æ‹©æ’åº

#### é€‰æ‹©æ’åºğŸš¦ğŸ“

```c
//********************************************
//ç›´æ¥é€‰æ‹©æ’åº
//********************************************
void selectsort(node A[])
{
    int i,j,min;
    node t;
    for(i=0;i<n-1;i++)
    {
        min=i;
        for(j=i+1;j<n;j++)//å¯»æ‰¾æœ¬è½®ä¸­çš„æœ€å°å€¼
        {
            if(A[min].key>A[j].key) //è®°ä¸‹æœ€å°å€¼çš„ä½ç½®
                min=j;
        }
        //æŠŠDATA[i]å’Œæœ€å°å€¼DATA[k]äº¤æ¢
        if(min!=i)
        {t=A[i];A[i]=A[min];A[min]=t;}
    }
    show(A);
}
typedef struct node{
    int data;
    struct node *next;
}Lnode,*link;
void Selctsort(link L){
    link p,q,minp;
    int temp;
    p=L->next;
    while(p!=NULL){
        minp=p;
        q=p->next;
        while(q!=NULL){
            if(q->data<minp->data)
                minp=q;
            q=q->next;
        }
        if(p->data>minp->data){//æ¢å€¼
            temp=p->data;
            p->data=minp->data;
            mip->data=temp;
        }
        p=p->next;
    }
}





//æ¯æ¬¡æ‰¾å‡ºæœ€å¤§èŠ‚ç‚¹ï¼Œå¤´æ’æ³•åˆ°å¤´éƒ¨ ->å‡åºæ’åº æˆ–æ¯æ¬¡æ‰¾å‡ºæœ€å°èŠ‚ç‚¹ï¼Œå°¾æ’æ³•
void selectSort(LinkedList &L){
    //å¯¹ä¸å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨Læ‰§è¡Œç®€å•é€‰æ‹©æ’åº
    LinkNode *h=L,*p,*pre,*maxp,*maxpre;
    L=NULL;
    while(h!=NULL){
        p=maxp=h;pre=maxpre=NULL;
        //maxpå’Œmaxpreè®°å¿†æœ€å¤§èŠ‚ç‚¹å’Œå…¶å‰é©± pä¸ºå·¥ä½œæŒ‡é’ˆï¼Œpreä¸ºå‰é©±
        while(p!=NULL){
            if(p->data>maxp->data){//æ‰¾æœ€å¤§èŠ‚ç‚¹
                maxp=p;
                maxpre=pre;
            }
            pre=p;
            p=p->next;
        }
        if(maxp==h)					//	æ¢èŠ‚ç‚¹
            h=h->next;				//æœ€å¤§èŠ‚ç‚¹åœ¨åŸé“¾è¡¨å‰ç«¯æ— åºç¬¬ä¸€ä¸ª
        else
            maxpre->next=maxp->next;	//æœ€å¤§èŠ‚ç‚¹åœ¨åŸé“¾è¡¨è¡¨å†…ï¼Œæ–­å¼€PèŠ‚ç‚¹
        maxp->next=L;					//èŠ‚ç‚¹så¤´æ’æ³•æ’å…¥ç»“æœé“¾å‰ç«¯
        L=s;
    }
}
```

#### å †æ’åº 

```c
//æ‰‹å†™è¿‡ç¨‹p315
//å¯¹åˆå§‹åºåˆ—å»ºç«‹å¤§æ ¹å †
void BuildMaxHeap(int A[], int len){
    for(int i=len/2; i>0; i--)   //ä»åå¾€å‰è°ƒæ•´æ‰€æœ‰éç»ˆç«¯ç»“ç‚¹
        HeadAdjust(A, i, len);
}

/*å°†ä»¥kä¸ºæ ¹çš„å­æ ‘è°ƒæ•´ä¸ºå¤§æ ¹å †
ä»æœ€åº•å±‚çš„åˆ†æ”¯ç»“ç‚¹å¼€å§‹è°ƒæ•´*/
void HeadAdjust(int A[], int k, int len){
    A[0] = A[k];                      //A[0]æš‚å­˜å­æ ‘çš„æ ¹ç»“ç‚¹
    for(int i=2*k; i<=len; i*=2){     //æ²¿keyè¾ƒå¤§çš„å­ç»“ç‚¹å‘ä¸‹ç­›é€‰
                                      // iä¸ºå½“å‰æ‰€é€‰æ ¹ç»“ç‚¹çš„å·¦å­©å­
                                      //i*=2æ˜¯ä¸ºäº†åˆ¤æ–­è°ƒæ•´åå†ä¸‹ä¸€å±‚æ˜¯å¦æ»¡è¶³å¤§æ ¹å †
        if(i<len && A[i]<A[i+1])      //åˆ¤æ–­ï¼šå½“å‰æ‰€é€‰æ ¹ç»“ç‚¹çš„å·¦ã€å³ç»“ç‚¹å“ªä¸ªæ›´å¤§
            i++;                      //å–keyè¾ƒå¤§çš„å­ç»“ç‚¹çš„ä¸‹æ ‡
        if(A[0] >= A[i]) 
            break;                    //ç­›é€‰ç»“æŸï¼šiæŒ‡å‘æ›´å¤§çš„å­ç»“ç‚¹
        else{
            A[k] = A[i];              //å°†A[i]è°ƒæ•´è‡³åŒäº²ç»“ç‚¹ä¸Š
            k=i;                      //ä¿®æ”¹kå€¼ï¼Œä»¥ä¾¿ç»§ç»­å‘ä¸‹ç­›é€‰
        }
    }
    A[k] = A[0];                      //è¢«ç­›é€‰çš„ç»“ç‚¹çš„å€¼æ”¾å…¥æœ€ç»ˆä½ç½®
}

//äº¤æ¢
void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}

//åŸºäºå¤§æ ¹å †è¿›è¡Œæ’åº
void HeapSort(int A[], int len){
    BuildMaxHeap(A, len);          //åˆå§‹å»ºå †
    for(int i=len; i>1; i--){      //n-1è¶Ÿçš„äº¤æ¢å’Œå»ºå †è¿‡ç¨‹
        swap(A[i], A[1]);          //å †é¡¶å…ƒç´ å’Œå †åº•å…ƒç´ äº¤æ¢
        HeadAdjust(A,1,i-1);       //æŠŠå‰©ä½™çš„å¾…æ’åºå…ƒç´ æ•´ç†æˆå †
    }
}
```



### å½’å¹¶æ’åºâœ¨ğŸ“šğŸ“

```c
//********************************************
//å½’å¹¶æ’åº 
//********************************************
  int *B=(int *)malloc((n+1)*sizeof(int));
  void Merge(int A[],int low,int mid,int high){
	  int i,j,k;
	  for(k=low;k<=high;k++)
		  B[k]=A[k];       //å°†Aå…ƒç´ å¤åˆ¶åˆ°B
	  for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){
		  if(B[i]<=B[j])   //æ¯”è¾ƒBå·¦å³ä¸¤æ®µ
			  A[k]=B[i++]; //å°†è¾ƒå°å€¼å¤åˆ¶åˆ°Aä¸­
		  else
			  A[k]=B[j++];
	  }
	  while(i<=mid)   A[k++]=B[i++];//æ£€æµ‹ç¬¬ä¸€ä¸ªè¡¨
	  while(j<=high)  A[k++]=B[j++]; //æ£€æµ‹ç¬¬äºŒä¸ªè¡¨
  }
  void MergeSort(int A[],int low,int high){
	  if(low<high){
		  int mid=(low+high)/2;
		  MergeSort(A,low,mid);
		  MergeSort(A,mid+1,high);
		  Merge(A,low,mid,high);

	  }
  }
```





### 2020 

ä¸€ã€ç®—æ³•åˆ†æé¢˜(70 åˆ†) 

1ã€ä¸€ä¸ªæ ˆ s è¿›è¡Œå¦‚ä¸‹æ“ä½œ, push(1), push(2), pop(), push(3), pop(), push(4),  

pop(), push(5), pop().æ±‚æœ€ç»ˆè¾“å‡ºçš„åºåˆ—ã€‚(10 åˆ†) 

```2,3,4,5   æ ˆä¸­ç•™æœ‰1
2,3,4,5   æ ˆä¸­ç•™æœ‰1
```

2ã€æŸäºŒå‰æ ‘çš„å…ˆåºéå†ä¸º ABHFDECKGï¼Œä¸­åºéå†ä¸º HBDFAEKCGï¼Œç”»å‡ºè¯¥äºŒå‰ 

æ ‘ã€‚(10 åˆ†)

 <img src="D:\æ•°æ®ç»“æ„\IMG\1png" alt="1634296582293" style="zoom:50%;" />

3ã€ç»™å‡ºä¸€ä¸ªå›¾ï¼Œæ ¹æ®å›¾é‡‡jç”¨ Prim ç®—æ³•ç”»å‡ºä¸€ä¸ªç”Ÿæˆå­å›¾ï¼Œè¦æ±‚ç»™å‡ºæ¯ä¸€æ­¥çš„æ‰§ 

è¡Œè¿‡ç¨‹ã€‚(10 åˆ†)

 <img src="D:\æ•°æ®ç»“æ„\IMG\3.png" style="zoom:80%;" />

<img src="D:\æ•°æ®ç»“æ„\IMG\3.1.png" alt="3.1" style="zoom:50%;" />

4ã€å°†ç»™å®šçš„å…³é”®å­—é›†{47,7,29,11,16,92,22,8,3,18,27,25,40}ç”¨é•¿åº¦ä¸º 13 çš„å“ˆå¸Œ  p<=13 

è¡¨å­˜å‚¨ï¼Œç”¨çº¿æ€§æ¢æµ‹æ³•å¤„ç†å†²çªã€‚ç”»å‡ºè¯¥å“ˆå¸Œè¡¨ï¼Œå¹¶æ±‚å‡ºè¯¥è¡¨çš„ ASLã€‚(10 åˆ†)

5ã€æ ¹æ®ç»™å®šçš„ a-g çš„æ¦‚ç‡æ„é€ éœå¤«æ›¼æ ‘å¹¶æ±‚å…¶ç¼–ç ï¼ˆæƒå€¼å°çš„åœ¨å·¦è¾¹ï¼‰ã€‚(10 åˆ†) <img src="D:\æ•°æ®ç»“æ„\IMG\2.PNG" style="zoom: 67%;" />

6ã€è®°å½•çš„å…³é”®å­—åºåˆ—ä¸º{63,90,70,55,67,42,98,83,10,45,58}ï¼Œç”»å‡ºç»™å®šåºåˆ—çš„äºŒ 

å‰æ’åºæ ‘ï¼Œå¹¶ç”»å‡ºåˆ é™¤ç»“ç‚¹ 70 ä¹‹åçš„æ’åºæ ‘ã€‚(10 åˆ†) 

<img src="D:\æ•°æ®ç»“æ„\IMG\4.png" alt="4" style="zoom:50%;" />

<img src="D:\æ•°æ®ç»“æ„\IMG\5.png" style="zoom:50%;" />

7ã€å†™å‡ºç»™å®šåºåˆ—{67,38,29,56,53,95,48,12}çš„é€’å¢å¿«é€Ÿæ’åºçš„æ¯ä¸€è¶Ÿæ’åºçš„ç»“æœã€‚ 

(10 åˆ†) 

â€‹      67,38,29,56,53,95,48,12

1ï¸âƒ£	[12,38,29,56,53,48],67,[95]

2ï¸âƒ£	12,[38,29,56,53,48],67,[95]

3ï¸âƒ£	12,29,[38],[56,53,48],67,[95]

4ï¸âƒ£	12,29,38,[56,53,48],67,[95]

5ï¸âƒ£	12,29,38,[48,53],56,67,[95]

6ï¸âƒ£	12,29,38,48,[53],56,67,[95]

7ï¸âƒ£	12,29,38,48,53,56,67,[95]

8ï¸âƒ£	12,29,38,48,53,56,67,95

äºŒã€ç®—æ³•è®¾è®¡é¢˜(80 åˆ†) 

1.ã€å†™å‡ºé¡ºåºè¡¨çš„ç»“æ„ä½“ï¼Œå¹¶è®¾è®¡åœ¨é¡ºåºè¡¨ L ä¸­ç¬¬ pos ä½ç½®ä¸Šæ’å…¥ä¸€ä¸ªå…ƒç´  e çš„ 

ç®—æ³•ï¼Œé»˜è®¤æ•°æ®ç±»å‹ä¸ºæ•´å‹ã€‚(15 åˆ†) 

```c
#define MaxSize 10      //å®šä¹‰æœ€å¤§é•¿åº¦ 
typedef struct{
    ElemType data[MaxSize];  //ç”¨é™æ€çš„â€œæ•°ç»„â€å­˜æ”¾æ•°æ®å…ƒç´  
    int Length;         //é¡ºåºè¡¨çš„å½“å‰é•¿åº¦
}SqList; 
//åœ¨Lä½åºä¸ºiå¤„æ’å…¥å…ƒç´ e
bool ListInsert(SqList &L, int i, int e){ 
    //åˆ¤æ–­içš„èŒƒå›´æ˜¯å¦æœ‰æ•ˆ
    if(i<1||i>L.length+1) 
        return false;
    if(L.length>MaxSize) //å½“å‰å­˜å‚¨ç©ºé—´å·²æ»¡ï¼Œä¸èƒ½æ’å…¥  
        return false;
     
    for(int j=L.length; j>i; j--){    //å°†ç¬¬iä¸ªå…ƒç´ åŠå…¶ä¹‹åçš„å…ƒç´ åç§»
        L.data[j]=L.data[j-1];
    }
    L.data[i-1]=e;  //åœ¨ä½ç½®iå¤„æ”¾å…¥e
    L.length++;      //é•¿åº¦åŠ 1
    return true;
}
```



2ã€å†™å‡ºé“¾è¡¨çš„ç»“æ„ä½“ï¼Œå¹¶è®¾è®¡åœ¨é“¾è¡¨ä¸­åˆ é™¤æŒ‡å®šå…ƒç´  e çš„ç®—æ³•ï¼Œå‡è®¾å…ƒç´  e åœ¨é“¾ 

è¡¨ä¹‹ä¸­ï¼Œé»˜è®¤æ•°æ®ç±»å‹ä¸ºæ•´å‹ã€‚(15 åˆ†) 

```c
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode, *LinkList;
//åˆ é™¤å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ä¸­å€¼ä¸ºxçš„ç»“ç‚¹
void delX(LinkList &L,int e){
    LNode *p=L->next,*pre=L,*q;//preæŒ‡å‘pçš„å‰é©±
    while(p!=NULL){
            if(p->data==e){
				q=p;
                p=p->next;//æ³¨æ„è¿™é‡Œåˆ é™¤åˆ†å¼€æ˜¯ä¿ç•™p
                pre->next=p; //åˆ é™¤qèŠ‚ç‚¹
                free(q);      
           }
            else{			 
				pre=p;      // pre å’Œ p åŒæ­¥åç§»
                p=p->next; 
                }
        }
}
```



3ã€è®¾è®¡ä¸€ä¸ªç®—æ³•å°†ç»™å®šçš„åè¿›åˆ¶æ•°è½¬åŒ–ä¸ºäºŒè¿›åˆ¶æ•°ã€‚ç»™å®šé»˜è®¤æ“ä½œ Initial_stack()ï¼› 

Is_ empty_stack(s)ï¼›Push()ï¼›Pop()ï¼Œåˆ©ç”¨è¿™å‡ ä¸ªæ ˆæ“ä½œå®ç°ã€‚(15 åˆ†) 

```c
void Convert(int x){
    Initial_stack(s);
    while(x!=0){
        Push(s,p%2);
        p=p/2;
        }
    while(!Is_ empty_stack(s))
          x=x*10+Pop(s);
}
```



4ã€è®¾è®¡åœ¨äºŒå‰æ’åºæ ‘ä¸­æŸ¥æ‰¾ç»“ç‚¹å€¼ä¸º e çš„ç®—æ³•ã€‚(15 åˆ†) 

```c
typedef struct  node
{
    KeyType  key ; /*å…³é”®å­—çš„å€¼*/
    struct node  *lchild,*rchild;/*å·¦å³æŒ‡é’ˆ*/
}BSTNode, *BSTree;

BSTree  SearchBST(BSTree T, KeyType key)
{ 
    BSTree p=T;
    while(p)
    {
        if (p->key == key) 
            return q;  /*æŸ¥æ‰¾æˆåŠŸ*/
        if (p->key > key)  
            p=p->lchild;  /*åœ¨å·¦å­æ ‘ä¸­æŸ¥æ‰¾*/
        else  
            p=p->rchild;  /*åœ¨å³å­æ ‘ä¸­æŸ¥æ‰¾*/
    }
    return NULL; /*æŸ¥æ‰¾å¤±è´¥*/
}
```



5ã€è®¾è®¡å°† a[n]æ•°ç»„é‡‡ç”¨å½’å¹¶æ–¹å¼æ’åºçš„ç®—æ³•ã€‚(20 åˆ†)

```c
//********************************************
//å½’å¹¶æ’åº 
//********************************************
  int *B=(int *)malloc((n+1)*sizeof(int));
  void Merge(int A[],int low,int mid,int high){
	  int i,j,k;
	  for(k=low;k<=high;k++)
		  B[k]=A[k];       //å°†Aå…ƒç´ å¤åˆ¶åˆ°B
	  for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){
		  if(B[i]<=B[j])   //æ¯”è¾ƒBå·¦å³ä¸¤æ®µ
			  A[k]=B[i++]; //å°†è¾ƒå°å€¼å¤åˆ¶åˆ°Aä¸­
		  else
			  A[k]=B[j++];
	  }
	  while(i<=mid)   A[k++]=B[i++];//æ£€æµ‹ç¬¬ä¸€ä¸ªè¡¨
	  while(j<=high)  A[k++]=B[j++]; //æ£€æµ‹ç¬¬äºŒä¸ªè¡¨
  }
  void MergeSort(int A[],int low,int high){
	  if(low<high){
		  int mid=(low+high)/2;
		  MergeSort(A,low,mid);
		  MergeSort(A,mid+1,high);
		  Merge(A,low,mid,high);

	  }
  }
```



### 2021

1.å†™é¡ºåºè¡¨ç±»å‹å®šä¹‰ï¼Œé¡ºåºè¡¨çš„æ’å…¥å’Œåˆ é™¤ã€‚ 

2.å†™é“¾å¼å †æ ˆç±»å‹å®šä¹‰ï¼Œç¼–ç¨‹å†™å‡ºå…¥æ ˆå’Œå‡ºæ ˆã€‚ 

3.ç»™å®šæƒé›†ï¼Œæ„é€ å“ˆå¤«æ›¼æ ‘ï¼Œæ±‚åŠ æƒè·¯å¾„é•¿åº¦ã€‚ 

4.ç»™å‡ºåºåˆ—ï¼Œæ„é€ ç”»å‡ºäºŒå‰æ’åºæ ‘ï¼Œåˆ é™¤å…¶ä¸­ä¸€ä¸ªèŠ‚ç‚¹åçš„äºŒå‰æ’åºæ ‘ã€‚ 

**ä¸­åºå‰é©±æˆ–è€…åç»§è¡¥**

5.æœ‰å›¾ï¼Œé‚»æ¥çŸ©é˜µï¼Œç”»å›¾ã€‚åˆ©ç”¨æ™®é‡Œå§†ç®—æ³•å†™å‡ºæœ€å°ç”Ÿæˆæ ‘ï¼Œåˆ©ç”¨ Dijkstra ç®—æ³•æ±‚å„ ç»“ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚ 

6.æœ‰å‘å›¾ï¼Œç”»å›¾å†™å‡ºæ‰€æœ‰æ‹“æ‰‘ç»“æ„ã€‚ä¾‹

<img src="D:\æ•°æ®ç»“æ„\IMG\æ‹“æ‰‘æ’åº.png" style="zoom:50%;" /> 

```
æ‹“æ‰‘åºåˆ— 
ABCFDEG,ABCDFEG,ABCDEFG,ABDCFEG,ABDCEFG
```

7.ç»™å‡ºåºåˆ—ï¼Œåˆ©ç”¨å½’å¹¶æ’åºå’Œæ’å…¥æ’åºï¼Œåœ¨åºåˆ—ä¸­è¿›è¡Œå‡åºæ’åºã€‚å†™è¿‡ç¨‹ã€‚ 

8.å†™å¿«æ’çš„ä»£ç ï¼Œæ±‚æ—¶é—´å¤æ‚åº¦ã€‚

```
æŠŠnä¸ªå…ƒç´ ç»„ç»‡æˆäºŒå‰æ ‘ï¼ŒäºŒå‰æ ‘çš„å±‚æ•°å°±æ˜¯é€’å½’è°ƒç”¨çš„å±‚æ•°ï¼Œnä¸ªç»“ç‚¹çš„äºŒå‰æ ‘æœ€å°é«˜åº¦ = âŒŠlogâ‚‚nâŒ‹ + 1, æœ€å¤§é«˜åº¦ = n

æ—¶é—´å¤æ‚åº¦ = O(nÃ—é€’å½’å±‚æ•°) ï¼ˆé€’å½’å±‚æ•°æœ€å¤§ä¸ºnï¼‰

æœ€å¥½ = O(nlogâ‚‚n) : æ¯æ¬¡é€‰çš„æ¢è½´å…ƒç´ éƒ½èƒ½å°†åºåˆ—åˆ’åˆ†æˆå‡åŒ€çš„ä¸¤éƒ¨åˆ†ï¼›
æœ€å = O(nÂ²) ï¼šåºåˆ—æœ¬å°±æœ‰åºæˆ–é€†åºï¼Œæ­¤æ—¶æ—¶é—´ã€ç©ºé—´å¤æ‚åº¦æœ€é«˜ï¼›
å¹³å‡æ—¶é—´å¤æ‚åº¦ = O(nlogâ‚‚n) ï¼ˆæ¥è¿‘æœ€å¥½è€Œä¸æ˜¯æœ€åï¼‰
```

9.ç»™å‡ºå“ˆå¸Œè¡¨ï¼Œå“ˆå¸Œå‡½æ•°ï¼Œæƒå€¼åºåˆ—ï¼Œæ±‚åˆ©ç”¨çº¿æ€§æ¢æµ‹æ³•å¤„ç†å†²çªçš„å“ˆå¸Œè¡¨ï¼Œæ±‚æˆåŠŸæŸ¥æ‰¾æƒ…å†µä¸‹å¹³å‡æœ€çŸ­è·¯å¾„ã€‚



2022

1.æ—¶é—´å¤æ‚åº¦

2.æ’å…¥ç®—æ³•

3.éå†åºåˆ—

4.äºŒå‰æ ‘è½¬æ£®æ—

5.å“ˆå¤«æ›¼æ ‘å’Œè·¯å¾„ç¼–ç 

6.æ™®é‡Œå§†å’Œå…‹é²æ–¯å¡å°”

7.çº¿æ€§æ¢æµ‹æˆåŠŸæ¦‚ç‡

8.å¿«é€Ÿæ’åº

# 2022

```
1.æ—¶é—´å¤æ‚åº¦
2.åœ¨çº¿æ€§è¡¨æŸä¸ªä½ç½®å‡ºå…¥ä¸€ä¸ªå…ƒç´ ï¼ˆå¥½åƒæ˜¯æ‰¾åˆ°ä¸€ä¸ªç„¶ååç§»è¿›è¡Œæ’å…¥ï¼‰
3.äºŒå‰æ ‘éå†åºåˆ—ï¼ˆå‰ä¸­åå±‚æ¬¡ï¼‰  äºŒå‰æ ‘è½¬æ£®æ—å’ŒäºŒå‰æ ‘è½¬æ ‘çš„äº’ç›¸è½¬åŒ–
4.æ„é€ å“ˆå¤«æ›¼æ ‘ï¼Œå“ˆå¤«æ›¼ç¼–ç 
8.æ±‚æœ€å°ç”Ÿæˆæ ‘ å…‹é²æ–¯å¡å°”å’Œæ™®é‡Œå§†ï¼Œæœ€çŸ­è·¯å¾„ è¿ªæ°æ–¯ç‰¹æ‹‰å’Œå¼—æ´›ä¼Šå¾·ï¼ˆä¸€èˆ¬æ²¡ä»£ç ï¼‰
9.çº¿æ€§æ¢æµ‹æ„é€  æ±‚æˆåŠŸå’Œä¸æˆåŠŸæ¦‚ç‡
10.å¿«é€Ÿæ’åº
```



## å›¾ä¾‹

âœ¨ è€ƒè¿‡

ğŸš¦å‚è€ƒä¹¦ä¹ é¢˜æœ‰

ğŸ“šæ”¹åè€ƒè¿‡

ğŸ“æœŸæœ«è€ƒè¯•å‡ºç°è¿‡