 [toc]

# 线性表

## 顺序表

### 顺序表静态分配数据类型定义

```c++
#define MaxSize 10      //定义最大长度 
typedef struct{
    ElemType data[MaxSize];  //用静态的“数组”存放数据元素 
    int Length;         //顺序表的当前长度
}SqList;                //顺序表的类型定义

void InitList(SqList &L){
    for(int i=0; i<MaxSize; i++){
        L.data[i]=0;   //防止脏数据”
    }
    L.Length=0;        //顺序表初始长度为0
}

```
### 顺序表动态分配数据类型定义

```c
#define InitSize 10    //设置默认最大长度
typedef struct{
	ElemType  *data;//指示动态分配数组的指针
	int MaxSize;
	int length;
}SeqList;

void InitList(SeqList &L) {
	//malloc申请连续的存储空间
	L.data = (int *)malloc(InitSize * sizeof(int));
	L.length = 0;
	L.MaxSize = InitSize;
}
```
### 顺序表定义✨📚

```c
#define MaxSize 10      //定义最大长度 
typedef struct{
    ElemType data[MaxSize];  //用静态的“数组”存放数据元素 
    int Length;         //顺序表的当前长度
}SqList; 
#define InitSize 10    //设置默认最大长度
typedef struct{
	ElemType  *data;//指示动态分配数组的指针
	int MaxSize;
	int length;
}SeqList;
```



### 增加动态数组的长度

```c++
//增加动态数组的长度
void IncreaseSize(SeqList &L, int len){
    int *p=L.data;
    L.data = (int*)malloc((L.MaxSize+len)*sizeof(int));
    for(int i=0; i<L.length; i++){
        L.data[i] = p[i]         //将数据复制到新区域
    }
    L.MaxSize = L.MaxSize + len; //顺序表最大长度增加len
    free(p);                     //释放原来的内存空间
}
```
### 顺序表插入✨

```c
//在L位序为i处插入元素e
bool ListInsert(SqList &L, int i, int e){ 
    //判断i的范围是否有效
    if(i<1||i>L.length+1) 
        return false;
    if(L.length>MaxSize) //当前存储空间已满，不能插入  
        return false;
     
    for(int j=L.length; j>=i; j--){    //将第i个元素及其之后的元素后移
        L.data[j]=L.data[j-1];
    }
    L.data[i-1]=e;  //在位置i处放入e
    L.length++;      //长度加1
    return true;
}
```
### 顺序表删除✨

```c
bool ListDelete(SeqList &L, int i,Element &e){ // e用引用型参数 
    //判断i的范围是否有效
    if(i<1 ||i>L.length) 
        return false;
    e = L.data[i-1];   //将被删除的元素赋值给e
    for(int j=i; j<L.length; j++){    //将第i个后的元素前移  后移个数为n-i+1
        L.data[j-1]=L.data[j];
    }
    L.length--;      //长度减1
    return true;
}
```
### 顺序表查找

```c
//按值查找顺序表,找到第一个元素值等于e的位序并返回其位序
int LocateElem(SeqList L, int e) {
	int i;
	for (i = 0; i < L.length; i++)
		if (L.data[i]==e)
			return i + 1;
	return 0;
}
```
### 习题

#### 1.删除最小元素节点，value返回

```c
//删除最小元素节点，value返回
/*查找最小值下标，用最后一个覆盖它*/
bool Del_Main(SqList &L,ElemType &value){
    if(L.length==0)
        return false;
    value=L.data[0];
    int pos=0;//假设0号元素的值最小
    for(int i=1;i<L.length;i++){
        if(L.data[i]<value){
            value=L.data[i];
            pos=i; 
        }
    }
    L.data[pos]=L.data[L.length-1];//空出的位置由最后一个元素填补
    L.length--;
    return true;
}
```

#### 2.顺序表元素逆置🚦

```c
void Reverse(Sqlist &L){
    ElemType temp;
    for(i=0;i<L.length/2;i++){
        temp=L.data[i];
        L.data[i]=L.data[L.length-i-1];
        L.data[L.length-i-1]=temp;
    }
}
```

#### 3.删除顺序表中所有值为x的元素

```c
//删除顺序表中所有值为x的元素
void del_x(Sqlist &L,ElemType x){
    int k=0;//记录值不等于x的元素
    for(i=0;i<L.length;i++)
        if(L.data[i]!=x){
            L.data[k]=L.data[i];
            k++;
        }
   L.length=k;  
}
```

#### 4.从有序顺序表中删除s t之间的所有元素🎉

```c
//从有序顺序表中删除s t之间的所有元素
bool Del_st(Sqlist &L,ElemType s,ElemType t){
    int i,j;
    if(s>t||L.length==0)
        return false;
    for(i=0;i<L.length&&L.data[i]<s;i++);//寻找大于等于s的第一个元素<
    if(i>=L.length)
        return false;//所有元素均小于s返回
    for( j=i;j<L.length&&L.data[j]<=t;j++);//寻找大于t的第一个元素<=
    for(;j<L.length;i++,j++)
        L.data[i]=L.data[j];//前移，填充被删除元素
    L.length=i;
    return true;
}
```

#### 5.从顺序表中删除s t(包括s t)之间的所有元素

```c
//从顺序表中删除s t(包括s t)之间的所有元素
bool Del_st(Sqlist &L,ElemType s,ElemType t){
    int i ,k=0;//k为s t之间的元素个数
    if(L.length==0||s>=t)
        return false;
    for(i=0;i<L.length;i++){
        if(L.data[i]>=s&&L.data[i]<=t)
            k++;
        else
            L.data[i-k]=L.data[i];//当前元素前移k个位置
    }
    L.length-=k;//长度减少
    return true;
}
```

#### 6.从有序顺序表中删除所有其值重复的元素🚦

```c
//#### 从有序顺序表中删除所有其值重复的元素
bool Delete_Same(SqList &L){
    if(L.length==0)
        return false;
    int i,j;//i存储第一个不相同元素,j为工作指针
    for(i=0,j=1;j<L.length;j++){
        if(L.data[i]!=L.data[j])//查找与上一个不同的元素
            L.data[++i]=L.data[j];//找到后前移，放到不同的后面
    }
    L.length=i+1;	//0开始
    return true;
}
```

#### 7.合并有序顺序表

```c
//合并有序顺序表 
bool Merge(SqList A,SqList B,SqList c){
    if(A.length+B.length>C.maxSize)
        return false;
    int i=0,j=0,k=0;
    while(i<A.length&&j<B.length){
        if(A.data[i]<=B.data[j])
            C.data[k++]=A.data[i++];
        else
            C.data[k++]=B.data[j++];
    }
    while(i<A.length)
        C.data[k++]=A.data[i++];
    while(j<B.length)
        C.data[k++]=B.data[j++];
    C.length=k;
    return true;
}
```



## 链表

### 节点类型定义

```c
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

//不带头节点初始化
bool InitList(LinkList &L){  //注意用引用 &
    L = NULL; //空表，暂时还没有任何结点；
    return true;
}

//带头结点初始
bool InitList(LinkList &L){  
    L = (LNode*) malloc(sizeof(LNode));  //头结点
    if (L == NULL)          //内存不足，分配失败
        return false;
    L -> next = NULL;       //头结点之后暂时还没有结点
    return true;
}
```
### 头插法✨ 

```c++
//带头结点的头插法
LinkList List_HeadInsert(LinkList &L){       //逆向建立单链表
    LNode *s;
    int x;
    L = (LinkList)malloc(sizeof(LNode));     //建立头结点
    L->next = NULL;                          //初始为空链表,这步不能少！
    scanf("%d", &x);                         //输入要插入的结点的值
    while(x!=9999){                          //输入9999表结束
        s = (LNode *)malloc(sizeof(LNode));  //创建新结点
        s->data = x;
        s->next = L->next;
        L->next = s;                         //将新结点插入表中，L为头指针
        scanf("%d", &x);   
    }
    return L;

 //向表中指定的位置pos处添加键值为key的元素
int insert(Lnode *h,int pos,elemtype x)
{
	Lnode *p=h,*s;
    int j=0;
    while(p&&j<pos-1)     //寻找第i-1号结点
    {
		p=p->next;
		j++;
    }
    if(p)
    {
		s=(Lnode *)malloc(sizeof(Lnode));
        s->data=x;
        s->next=p->next;     //改变指针状态，将s插入表中
        p->next=s;
        return(1);        //返回1表示正常结束
    }
    else 
        return (0);       //返回0表示插入失败
}
  
    
    
//不带头结点的头插法
LinkList List_HeadInsert(LinkList &L){       //逆向建立单链表
    LNode *s;
    int x;
    L = (LinkList)malloc(sizeof(LNode));     //建立头结点
	scanf("%d", &x);                         //输入要插入的结点的值
	L->data = x; 
    L->next = NULL;                          //初始为空链表,这步不能少！
    while(x!=9999){                          //输入9999表结束
        s = (LNode *)malloc(sizeof(LNode));  //创建新结点
        s->data = x;
        s->next = L->next;
        L->next = s;                         //将新结点插入表中，L为头指针
        scanf("%d", &x);   
    }
    return L;
   
}
```
### 尾插法✨

```c
//带头结点的尾插法
LinkList List_TailInsert(LinkList &L){       //正向建立单链表
    int x;                                   //设ElemType为整型int
    L = (LinkList)malloc(sizeof(LNode));     //建立头结点(初始化空表)
    LNode *s, *r = L;                        //r为表尾指针
    scanf("%d", &x);                         //输入要插入的结点的值
    while(x!=9999){                          //输入9999表结束
        s = (LNode *)malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;                                //r指针指向新的表尾结点
        scanf("%d", &x);   
    }
    r->next = NULL;                          //尾结点指针置空
    return L;
}

//不带头结点的尾插法
LinkList List_TailInsert(LinkList &L){       //正向建立单链表
    int x;                                   //设ElemType为整型int
    L = (LinkList)malloc(sizeof(LNode));    
	scanf("%d", &x);                         //输入要插入的结点的值
	L->data = x; 
    L->next = NULL;
    LNode *s, *r = L;                        //r为表尾指针
    while(x!=9999){                          //输入9999表结束
        s = (LNode *)malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;                                //r指针指向新的表尾结点
        scanf("%d", &x);   
    }
    r->next = NULL;                          //尾结点指针置空
    return L;
}
```
### 创建n个带头单循环链表🚦

```c
LNode create(int n){
    LNode head ,p,r;
    int i=1;
    head=(LNode)malloc(sizeof(LNode));
    head->next=head;
    while(i<=n-1){
        p=(LNode)malloc(sizeof(LNode));
        p->next=head->next;
        head->next=p;
        i++;
    }
    return head;
}
```



### 按序号查找结点

```c
//按位查找 获取表L中第i个位置的元素的值
LNode * GetElem(LinkList L, int i){
    int j=1;
    LNode *p=L->next;
    if(i==0)
        return L;//返回头节点
    if(i<0) 
        return NULL;
    while(p!=NULL && j<i){  //循环找到第i个结点
        p = p->next;
        j++;
    }
    return p->data;         //返回p指针指向的值
}
```
### 按值查找结点

```c
//按值查找结点
LNode * LocateElem(LinkList L, int e){
    LNode *p = L->next;    //p指向第一个结点
    //从第一个结点开始查找数据域为e的结点
    while(p!=NULL && p->data != e){
        p = p->next;
    }
    return p;           //找到后返回该结点指针
}
```
### 5.头插法原地逆序✨🚦📝X2

```c
LinkList Reverse(LinkList &L)//LNode *Reverse(LinkList L)
{
	LNode *p, *r;
	p = L->next;        //p指针指向第一个结点
	L->next = NULL;     //头结点指向NULL
	while (p != NULL){  //依次将元素节点摘下
		r = p->next;    //暂存p的后继
		p->next = L->next; //将p节点插入到头结点之后//无头节点L->next换成L
		L->next = p;
		p=r;
	}
	return L;
}
```
### 判断链表元素递增✨📚

```c
//判断链表元素递增  试卷是递减
bool Judge(LinkList L){ 
	LNode *p=L->next;         
	if(p==NULL) return true;    
	while(p->next!=NULL){
		if(p->data<=p->next->data)
			p=p->next;
		else
			return false;			
	}
	return true;
}
```

### 2.删除单链表值为x的结点✨📚

```c
//删除带头结点的单链表中值为x的结点
void delX(LinkList &L,int x){
    LNode *p=L->next,*pre=L,*q;//pre指向p的前驱
    while(p!=NULL){
            if(p->data==x){
				q=p;
                p=p->next;//注意这里删除分开是保留p
                pre->next=p; //删除q节点
                free(q);      
           }
            else{			 
				pre=p;      // pre 和 p 同步后移
                p=p->next; 
                }
        }
}
```

### 习题

#### 1.递归删除不带头结点的单链表中值为x的结点

```c
//递归删除不带头结点的单链表中值为x的结点Y
void dex_x(LinkList &L,int x){
    LNode *p;
    if(L==NULL)
        return;
    if(L->data==x){
        p=L;
        L=L->next;
        free(p);
        dex_x(L,x);
    }
    else
        dex_x(L->next,x);
}
```



#### 4.删除带头结点的单链表中最小值的结点

```c
//删除带头结点的单链表中最小值的结点Y
LinkList Del_Min(LinkList &L){
    LNode *pre=L,*p=pre->next;//p为工作指针,pre指向前驱
    LNode *minpre=pre,*minp=p;//保存最小值节点及其前驱
    while(p!=NULL){
        if(p->data<minp->data){//找到更小
            minp=p;
            minpre=pre;
        }
        pre=p;	//继续扫描下一个节点
        p=p->next;
    }
    minpre->next=minp->next;	//删除最小值节点
    free(minp);
    return L;
}
```

#### 6.使带头结点单链表元素递增有序（插入排序）✨🚦

```c
//使带头结点单链表元素递增有序Y
void Sort(LinkList &L){
    LNode *p=L->next,*pre;
    LNode *r=p->next;	//r保持*p后继指针保证不断链
    p->next=NULL;		//构造只含一个数据节点的有序表
    p=r;				//断开一个后拿到其后面
    while(p!=NULL){
        r=p->next; 		//保存*p的后继指针
        pre=L;
        while(pre->next!=NULL && pre->next->data<p->data)
            pre=pre->next;//在有序表中查找插入*p的前驱节点*pre
        p->next=pre->next;//将*p插入到*pre之后
        pre->next=p;
        p=r;			  //扫描原单链表中剩下的节点
    }
}
```

#### 7.删除带头结点单链表介于两值之间元素🚦

```c
//7.删除带头结点单链表介于两值之间元素Y
void RangeDelete(LinkList &L,int min,int max){
    LNode *pre=L,*p=L->next;	//p检测指针，pre前驱
    while(p!=NULL)
        if(p->data>min&&p->data<max){
            pre->next=p->next;
            free(p);
            p=pre->next;
        }
    	else{
            pre=p;
            p=p->next;
        }
}
```

#### 9.递增输出单链表各节点并删除 

```c
//9.递增输出单链表各节点并删除 Y
/*对链表进行遍历，每次找到整个链表最最小值元素删除*/
void MIn_Delete(LinkList &head){//head为头指针
    while(head->next!=NULL){//循环到仅剩头结点
        LNode *pre=head;
        LNode *p=pre->next;
        while(p->next!=NULL){
            if(p->next->data<pre->next->data)
                pre=p;//记住当前最小节点前驱
            p=p->next;
        }
        printf("%d",pre->next->data);
        LNode* u=pre->next;	
        pre->next=u->nexr;	//删除释放空间
        free(u);
    }
    free(head);
}
```

#### 10.将A拆分为A存奇数B存偶数

```c
//10.将A拆分为A存奇数B存偶数
LinkList DisCreat_1(LinkList &A)
{
    int i=0;
	LinkList B;
    B = (LinkList)malloc(sizeof(LNode));
    B->next = NULL;
    LNode *ra = A,*rb = B;	//A，B尾结点
    LNode *p = A->next
    A->next = NULL;
    while(p!=NULL)
    {
        i++;
        if(i%2==0)		//处理序号为偶数节点
        {
            rb->next = p;//表尾插入
            rb = p;//尾指针移动
        }
        else
        {
            ra->next = p;
            ra = p;
        }
        p = p->next;
    }
    ra->next = NULL;
    rb->next = NULL;
    return B;
}
```

#### 12.删除递增单链表相同元素

```c
//(7,10,10,21,30,42,42,42,51,70) ->(7,10,21,30,42,51,70)
void Del_Same(LinkList &L){
    LNode *p=L->next,*q;
    if(p==NULL)
        return;
    while(p->next!=NULL){
        q=p->next;
        if(p->data==q->data);{ 	//找到重复节点
            p->next=q->next;	//释放*q节点
            free(q);			//释放相同元素节点
        }
        else
            p=p->next;
        	
    }
}
```

#### 14.产生公共元素 C=AnB

```c
void Get_Common(LinkList A,LinkList B){
    LNode *p=A->next,*q=B->next,*r,*s;
    LinkList C=(LinkList)malloc(sizeof(LNode));
    LNode * r=C;
    while(p!=NULL&&q!=NULL){
        if(p->data<q->data)
            p=p->next;//A的元素较小后移指针
        else if(p->data>q->data)
            q=q->next;//B的元素较小后移指针
        else{//相等
            s=(LNode*)malloc(sizeof(LNOde));
            s->data=p->data;
            r->next=s; 				//尾插法将*s链接到C
            r=s;
            p=p->next;//同时下一个
            q=q->next;
        }
    }
    r->next=NULL;
}
```



## 栈和队列

### 顺序栈类型定义

```c
typedef int ElemType 
#define MaxSize 10         //定义栈中元素的最大个数
typedef struct{
    ElemType data[MaxSize];       //静态数组存放栈中元素
    int top;                      //栈顶元素
}SqStack;

//初始化栈
void InitStack(SqStack &S){
    S.top = -1;                   //初始化栈顶指针
}
```
### 顺序栈进出栈

```c
//入栈
bool Push(SqStack &S, ElemType x){
    if(S.top == MaxSize - 1)  //栈满
        return false;
    S.data[++S.top] = x;  ////指针再加1 再入栈 
    return true;
}

//出栈
bool Pop(SqStack &x, ElemType &x){
    if(S.top == -1)          //栈空
        return false;
    x = S.data[S.top--];     //先出栈 指针再减1
    return true;
}
```
### 链栈类型定义📚

```c
//栈的链式存储
typedef struct Linknode{
	int data;
	struct Linknode *next;
}Linknode,*LiStack; 
 
//初始化栈 
void InitStack(LiStack &L){
	L =(Linknode*)malloc(sizeof(Linknode));//创建头节点 
	//L=new Linknode;
	L->next=NULL;	//初始化为空	
}
```

### 链栈进出栈✨📚

```c
//入栈    链表头插法插入一个节点
bool pushStack(LiStack &L,int e){
	Linknode *s=(Linknode *)malloc(sizeof(Linknode));
	s->data=e;
	s->next=L->next; //头插法
	L->next=s; 
	return true;
}
 
//出栈 
bool popStack(LiStack &L,int &e){
	if(L->next==NULL){ //栈空
		return false;
	}
	Linknode *p=L->next;
	e=p->data;
	L->next=p->next;
	free(p);
	return true;
} 
```

### 顺序队列

```c
//队列的顺序存储类型
# define MaxSize 10;     //定义队列中元素的最大个数
typedef struct{ //大小为MaxSize*sizeof(ElemType)
    ElemType data[MaxSize];   //用静态数组存放队列元素                       
    int front, rear;          //队头指针和队尾指针
}SqQueue;
//初始化队列
void InitQueue(SqQueue &Q){
    Q.rear = Q.front = 0;//初始化时，队头、队尾指针指向0
}
```
### 链队存储类型

```c
typedef struct{      //链式队列结点
    ElemType data;
    struct LinkNode *next;
}LinkNode;
typedef struct{               //链式队列
    LinkNode *front, *rear;   //队列的队头和队尾指针
}LinkQueue;

void InitQueue(LinkQueue &Q){
    //初始化时，front、rear都指向头结点
    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));
    Q.front -> next = NULL;
}
```

### 链式入队出队

```c
//新元素入队 
/*尾插法插入一个节点*/
void EnQueue(LinkQueue &Q, ElemType x){
    LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode)); //申请一个新结点
    s->data = x;
    s->next = NULL;     //s作为最后一个结点，指针域指向NULL
    Q.rear->next = s;   //新结点插入到当前的rear之后
    Q.rear = s;         //表尾指针指向新的表尾
}
//队头元素出队
/*删除链表第一个节点，最后判断是不是尾节点*/
bool DeQueue(LinkQueue &Q, ElemType &x){
    if(Q.front == Q.rear)
        return false;             //空队
    LinkNode *p = Q.front->next;  //p指针指向即将删除的结点(头结点所指向的结点)
    x = p->data;
    Q.front->next = p->next;   //修改头结点的next指针     先修改好了头
    if(Q.rear == p)            //此次是最后一个结点出队
        Q.rear = Q.front;      //修改rear指针
    free(p);                   //释放结点空间

    return true;
}
```

### 循环链队入队出队🚦

```c
//循环队列入队 队尾插入（判满）
bool EnQueue(SqQueue &Q, ElemType x){
    if((Q.rear+1)%MaxSize == Q.front)   //队满
        return false;
    Q.data[Q.rear] = x;                 //将x插入队尾
    Q.rear = (Q.rear + 1) % MaxSize;   //队尾指针加1取模
    return true;
}

//出队，删除一个队头元素，用x返回
bool DeQueue(SqQueue &Q, ElemType &x){
    if(Q.rear == Q.front)              //队空报错
        return false;  
    x = Q.data[Q.front];
    Q.front = (Q.front + 1) % MaxSize; //队头指针后移动
    return true;
}
```

### 习题

#### 判断链表是否中心对称📝

```c
//判断链表是否中心对称
int dc(Linklist L,int n){
    int i;
    char s[n/2];//字符栈
    p=L->next;//工作指针
    for(i=0;i<n/2;i++){//链表前一半元素进栈
        s[i]=p->data;
        p=p->next;
    }
    i--;//恢复最后i值
    if(n%2==1)
        p=p->next;	//若n是奇数后移过中心节点
    while(p!=NULL&&s[i]==p->data){//检查是否中心对称
        i--;	//i当栈顶指针
        p=p->next;
    }
    if(i==-1) //栈为空
        return 1;
    else
        return 0;
}
```

#### 十进制转八进制🚦📝

```c
void Convert(int A[],int B[]){
    int i ,p;
    for(i=0;i<n;i++){
        p=A[i];
        clearstack(s);//InitStack(S);
        while(p!=0){
            push(s,p%8);
            p=p/8;
        }
        while(!EmptyStack(s))
            p=p*10+pop(s);
        B[i]=p;
    }
}
```



## 串

```c
int BF(SString s,SString t){
	int i=0,j=0;
	while(i<=s.length && j<=t.length){
		if(s.ch[i]==t.ch[j]){
			i++;
			j++;
		}
		else
			i=i-j+1;
			j=0;
	}
	if(j>t.length)
		return i-t.length;
	else
		return 0;
}
```



## 树与二叉树

### 数结构体类型定义

```c
//数结构体类型定义
typedef struct BTNode {
	char data;// 这里默认结点data域为char类型
	struct BTNode *lchild,*rchild;// 左指针域  指针域
} BTNode,*BiTree;
```
### 遍历✨

```c
//未运行
//中序非递归🚦   递归📝
void InOrder(BiTree T){
    InitStack(S);//BiTree* stack[MaxSize]
    BiTree p=T;
    while(p||!IsEmpty(S)){//top != -1)
        if(p){
            Push(S,P);//stack[++top]
            p=p->lchild;
        }
        else
            Pop(S,P);//stack[top--]
            visit(p);
            p=p->rchild;
        }
    }
}
//先序非递归（深度遍历）
void PreOrder(BiTree T){
    InitStack(S);
    BiTree p=T;
    while(p||!IsEmpty(S)){
        if(p){
            visit(p);
            Push(S,P);
            p=p->lchild;
        }
        else{
            Pop(S,P);
            p=p->rchild;//向右子树走
        }
    }
}
//后序非递归🚦
void PostOrder(BiTree T){
    InitStack(S);
    BiTree p=T,r=NULL;
    while(p||!IsEmpty(S)){
        if(p){
            Push(S,p);
            p=p->lchild;
        }
        else{
            GetTop(S,p);
            if(p->rchild&&p->rchild!=r)//若存在右子树且没有被访问过
                p=p->rchild;//转向右子树
            else{
                pop(S,p);
                visit(p->data);
                r=p;	//记录最近访问过的节点
                p=NULL;//每次出栈访问完一个节点相当于遍历完以该节点为根的子树
            }
        }
    }
}
```

### 层次遍历

```c
/*初始将根入队并访问根结点;
若有左子树，则将左子树的根入队;若有右子树，则将右子树的根入队;
然后出队，访问该结点;反复该过程直到队列空为止*/
//二叉树的结点(链式存储)
typedef struct BiTnode{
   ElemType data;          
   struct BiTNode *lchild, *rchild; 
}BiTNode, *BiTree;

//链式队列结点
typedef struct LinkNode{
   BiTNode * data;
   struct LinkNode *next;
}LinkNode;

typedef struct{
   LinkNode *front, *rear;  
}LinkQueue;

//层序遍历
void LevelOrder(BiTree T){
   LinkQueue Q;
   InitQueue (Q);          //初始化辅助队列
   BiTree p;
   EnQueue(Q,T);           //将根节点入队
   while(!isEmpty(Q)){     //队列不空则循环
      DeQueue(Q,p);        //队头结点出队
      visit(p);            //访问出队结点
      if(p->lchild != NULL)
         EnQueue(Q,p->lchild);   //左孩子入队
      if(p->rchild != NULL)
         EnQueue(Q,p->rchild);   //右孩子入队
   }
}
```



### 线索化

中序线索化

```c
//中序线索化节点
typedef sturct ThreadNOde{
    ElemType data;
    struct ThreadNOde *lchild,*rchild;
    int ltag,rtag;
}ThreadNOde,*ThreadTree;
//中序遍历二叉树，一边遍历一遍线索化
void InThread(ThreadTree T){
    if(T!=NULL){
        InThread(T->lchild);
        visit(T);
        Inthread(T->rchild);
    }
}
void visit(ThreadNode *q){
    if(q->lchild==NUll){//左子树为空建立前驱线索
        q-lchild=pre;
        q->ltag=1;
    }
    if(pre!=NULL&&q->rchild==NULL){
        pre->rchild=q;
        pre->rtag=1;
    }
    pre=q;
}
ThreadNode *pre=NULL;
//中序线索化二叉树T
void CreateInThread(ThreadTree T){
    pre=NULL;
    if(T!=NULL){		//非空二叉树才能线索化
        Inthread(T);	//中序线索化二叉树
        if(pre->rchild==NULL)
            pre->rtag=1;//处理最后一个节点
    }
}
```

中序线索化2

```c
/*
左子树为空建立前驱线索，前驱右子树为空建立后继线索
*/
void Inthread(ThreadTree &p,ThreadTree &pre){
    if(p!=NULL){
        InThread(p->lchild,pre);
   		if(p->lchild==NUll){						//左子树为空建立前驱线索
        	p->lchild=pre;
       	 	p->ltag=1;
    	}
    	if(pre!=NULL&&pre->rchild==NULL){			//后继线索
        	pre->rchild=p;
        	pre->rtag=1;
    	}
    	pre=p;
        Inthread(p->rchild,pre);
    }
}
//中序线索化二叉树T
void CreateInThread(ThreadTree T){
    ThreadNode pre=NULL;
    if(T!=NULL){		//非空二叉树才能线索化
        Inthread(T,pre);	//中序线索化二叉树
        pre->rchild=NULL;//处理最后一个节点
        pre->rtag=1;
    }
}
```

先序线索化

```c
void preThread(ThreadTree p,ThreadTree &pre){
    if(p!=NULL){
        if(p->lchild==NUll){//左子树为空建立前驱线索
       		p->lchild=pre;
       		p->ltag=1;
    	}
    	if(pre!=NULL&&pre->rchild==NULL){
        	pre->rchild=p;
        	pre->rtag=1;
    	}
    	pre=p;
        if(p->ltag==0){//防止转圈	
            PreThread(p->lchild,pre);	//左子树
        }
        PreThread(p->rchild,pre);		//右子树
    }
}
//先序线索化二叉树T
void CreateInThread(ThreadTree T){
    ThreadNode pre=NULL;
    if(T!=NULL){		//非空二叉树才能线索化
        Inthread(T,pre);	//中序线索化二叉树
        pre->rchild=NULL;//处理最后一个节点
        pre->rtag=1;
    }
}
```

后序线索化

```c
//后序线索化
void PostThread(BiThrTree p)
{
    if (p!=NULL)
    {
        PostThread(p->lchild);           //左子树线索化
        PostThread(p->rchild);           //右子树线索化
        if (p->lchild==NUll)                     //前驱线索
        {
            p->lchild=pre;
       		p->ltag=1;
        }
        if(pre!=NULL&&pre->rchild==NULL){
        	pre->rchild=p;
        	pre->rtag=1;
    	}
    	pre=p;
        //visit(pre->data);
    }
    
void CreateInThread(ThreadTree T){
    ThreadNode pre=NULL;
    if(T!=NULL){		//非空二叉树才能线索化
        PostThread(T,pre);	//中序线索化二叉树
        pre->rchild=NULL;//处理最后一个节点
        pre->rtag=1;
    }
}
```



### 输入创建二叉树

```c++
//ABC##DE##F##GH### 
void CreatBiNode(BTNode **Node) { //此处应注意传递的参数（二重指针）
	char data;
	scanf("%c", &data);
	*Node = (BiTree)malloc(sizeof(BTNode));
	if (data == '#') {
		*Node = NULL;
	} else if ((data != '#') && (*Node)) {
		(*Node)->data = data;
		(*Node)->lchild = NULL;
		(*Node)->rchild = NULL;
		CreatBiNode(&(*Node)->lchild);
		CreatBiNode(&(*Node)->rchild);
	}
}

//构建二叉排序树，通过逐个插入法
int BST_Insert(BiTree &T,ElemType k){   //注意T前面要有引用&。 
    if(T==NULL){
        T=(BiTree)malloc(sizeof(BiTNode));
        T->data=k;
        T->lchild=T->rchild=NULL;
        return 1;
    }
    else if(T->data==k)return 0;
    else if(k<T->data) return BST_Insert(T->lchild,k);
    else return BST_Insert(T->rchild,k);
}
void BST_Create(BiTree &T,ElemType a[],int n){
    T=NULL;
    for(int i=0;i<n;i++){
        BST_Insert(T,a[i]);
    }

```
### 二叉排序树插入📝

```c
int BST_Insert(BiTree &T,KeyType k){
    if(T==NULL){
        T=(BiTree)malloc(sizeof(BSTNode));
        T->key=k;
        T->lchild=T->rchild=NULL;
        return 1;
    }
    else if(k==T->key)
        return 0;
    else if(k<T->key)
        return BST_Insert(T->lchild,k);
    else
        return BST_Insert(T->rchild,k);
}
```

### 删除🚦

```c
//删除二叉排序树不小于x的节点（大于等于）
void Delete(BiTree &T,int x){
    if(T->rchild)//右子树
        Delelte(T->rchlid,x);
    if(T->data<x) exit();//
    q=T;
    T=T->lchild;
    free(q);	//如果树根不小于x,删除树根，并以左子树的根作为新的树根
    if(T)
        Delete(T,x);  //左子树
}




// 非递归删除以T为根的二叉排序树
void DelTree(BSTree &T) {
    BSTree S[N] = {};// 栈, 容量足够大, 栈中元素是二叉排序树结点的指针
    int top = 0;
    while (T != NULL || top > 0) {
        // 沿左分枝向下
        while (T != NULL) {
            S[++top] = T;
            T = T ->left;
        }
        // 退栈, 沿栈顶结点的右子树向下删除, 释放被删除结点空间
       if (top > 0) {
            BSTree p = S[top--];
            T = p ->right;
            free(p);
        }
    }
} // DelTree


//在二叉排序树T中, 删除所有小于等于x的结点
void DeleteAllx(BSTree &T, int x) {
    BSTree p = T, q = NULL;
    //根结点的值小于等于x
    while (T && T ->data <= x) {
        p = T;
        T = T ->right;
        p ->right = NULL;
        DelTree(p);
    } //删除二叉树p,删除持续到“根”结点值大于x或T为空树为止
    if (T) {
        q = T; p = T ->left;
        // 沿根结点左分枝向下, 查小于等于x的结点
        while (p) {
            while (p && p ->data > x) {
                q = p;
                p = p ->left;
            }
            // p 结点的值小于等于 x
            if (p) {
                q ->left = p ->right;
                p ->right = NULL;
                DelTree(p);
            }
        }
    }
}// DeleteAllx

```



### 二叉树的高度(层次遍历)🎉

```c
//递归求二叉树的高度
int Height(BiTree T){
    if(!T)return 0;
    int h1=Height(T->lchild);
    int h2=Height(T->rchild);
    return (h1>h2?h1:h2)+1;
} 

//非递归求二叉树的高度，用层次遍历
int Height1(BiTree T){
    if(T!=NULL){
        BiTree Q[maxSize];
        int front=-1,rear=-1;
        int level=0,last=0;  //last=0是因为第一个元素入队后，front的值为0； 
        BiTree p;
        Q[++rear]=T;
        while(front<rear){
            p=Q[++front];
            if(p->lchild!=NULL) Q[++rear]=p->lchild;
            if(p->rchild!=NULL) Q[++rear]=p->rchild;    
            if(front==last){   //出队元素如果是最后一个元素，层次+1，且更新last指向下一层的最后一个元素。 
                level++;
                last=rear;    //last指向下一层的最后一个结点。 
            }
        }
    return level;
    }
}
```
### 二叉树宽度

```c
//递归
int Max=0;
int conut_[MaxSize];//count[k]数组用来储存每一层的宽度，每次递归k+1代表层次+1，
int getWidth(BiTree T,int k){ //k变量为当前层数 默认从第一层开始
	if(T==NULL)// T为空直接返回
		return;
	else
	   conut_[k]++;// T不为空conut_[k]++
	if(conut_[k]>Max)
		Max=conut_[k];	//Max为数组的最大值
	getWidth(T->lchild,k+1);
	getWidth(T->Rchild,k+1);
	return Max;
}

//非递归
int Btdepth2(BiTree T){
	if(!T)
	   return 0;
    int font=-1,rear=-1;
    int last=0,ever=0;//last指向当前层的最右结点
    int max=0,width=0;//max 保存上一层宽度，width保存本层宽度
    BiTree Q[Maxsize];//初始化队列Q,元素是二叉树结点指针
    Q[++rear]=T；   //根结点入队
    BiTree p;
    while(front<rear){//队不空循环
    	p=Q[++front];  width++  
    	if(p->lchild)
    	   Q[++rear]=p->lchild;
 	    if(p->rchild)
 	       Q[++rear]=p->rchild;
        if(front==last){//处理该层的最右结点
		   if(max<width)
		      max=width; //若该层的宽度大于max，赋值
		   last=rear;//
		   width=0;//每一层宽度置空一次
		}
	}
	return max;
}

```



### 判断是否是完全二叉树

```c
int isCompleted(BiTree T){
    if(!T)return 1;
        BiTree Q[maxSize];
        int front=-1,rear=-1;
        BiTree p;
        Q[++rear]=T;
        while(front<rear){
            p=Q[++front];
            if(p){              //结点非空，左右子树的都入队，空结点也要。 
                Q[++rear]=p->lchild;
                Q[++rear]=p->rchild;
            }
            else{
                while(front<rear){//只要出现空结点则循环检查后面的结点是否有非空结点。 
                    p=Q[++front];
                    if(p!=NULL)//后面出现不为空的则不是
                        return 0;
                }
            }
        }
    return 1;    
}
```
### 以x节点为根的子树高度🚦🎉

```c
int Get_Sub_Depth(Bitree t,int x){
    if(T->data==x){
        printf("%d",Get_depth(T));
        exit 1;
    }
    else{
        if(T->lchild) Get_depth(T->lchild,x);
        if(T->rchild) get_depth(T->rchild,x);
    }
}
int Get_Depth(Bitree T){
    if(!T)return 0;
    else{
        m=Get_Depth(T->lchild);
        n=Get_Depth(T->rchild);
        return(m>n? m:n)+1;
    }
}
```



### 判断是否是平衡二叉树

```c
//未运行
void Judge_AVL(BiTree bt ,int &balance,int &h){//h为二叉树bt高度
    int bl=0,br=0,hl=0,hr=0;
    if(bt==NULL){//bt为空树
        h=0;
        balance=1;
    }
    else if(bt->lchild==NULL&&bt->rchild==NULL){//仅有根节点
        h=1;
        balance=1;
    }
    else{
        Judge_AVL(bt->lchild,bl,hl);//递归判断左子树
        Judge_AVL(bt->rchild,br,hr);//递归判断右子树
        h=(hl>hr? hl:hr)+1;//bt的高度为最高子树的高度+1
        if(abs(hl-hr)<2)
            balance=br&&bl;//左右子树都平衡
        else
            balance=0;            
    }
}
```





### 交换左右子树🚦📝

```c
//把二叉树所有结点的左右子树进行交换,如果用中序遍历，恰好反序。 
void swap(BiTree T){
    if(T!=NULL){
        BiTree temp;
        swap(T->lchild);
        swap(T->rchild);
        temp=T->lchild;
        T->lchild=T->rchild;
        T->rchild=temp;
    }
} 
//层次遍历互换📝
void swap(BiTree T){
   LinkQueue Q;
   InitQueue (Q);          //初始化辅助队列
   BiTree p;
   EnQueue(Q,T);           //将根节点入队
   while(!isEmpty(Q)){     //队列不空则循环
      DeQueue(Q,p);        //队头结点出队
      //visit(p);            //访问出队结点
      BiTree temp=p->lchild;
      p->lchild=p->rchild;
      p->rchild=temp;
      if(p->lchild != NULL)
         EnQueue(Q,p->lchild);   //左孩子入队
      if(p->rchild != NULL)
         EnQueue(Q,p->rchild);   //右孩子入队
   }
}
```
### 叶子节点个数✨🚦📚🎉

```c
 //叶子节点个数📚📝
int Leafcount(BiTree T)
{  if (!T) //if (T == NULL)
      return 0;
   if (!T->lchild && !T->rchild) //tree->lchild == NULL&&tree->rchild == NULL
	   return 1;
   else
	   return Leafcount(T->lchild) + Leafcount(T->rchild);
}
//节点个数
int Nodecount1(BiTree T)
{  if (T==NULL)
      return 0;  
   else
	   return Nodecount1(T->lchild) + Nodecount1(T->rchild)+1;
}


void count(blink bt,int *leaf,int *node )
{//求二叉树的节点数和叶子数，使用传地址的方法，调用程序前，叶子数和节点数要初始化为0
	if(bt)
	{
		(*node)++;//节点数增加
		if(bt->lchild==NULL&&bt->rchild==NULL)
			(*leaf)++;//叶子数增加
		count(bt->lchild,leaf,node);//计算左子数
		count(bt->rchild,leaf,node);//计算右子树
	}
}


//双分支结点数 （递归） 
int TwoBranchNum(BiTree T){
    int n=0;         //此处把n的初值设为0非常重要。！！！ 
    if(!T)return 0;
    if(T->lchild!=NULL&&T->rchild!=NULL)n=1;
    int num1=TwoBranchNum(T->lchild);
    int num2=TwoBranchNum(T->rchild);
    return num1+num2+n;
}
```
### 判断是否是二叉排序树✨🚦📚

```c
//递归
/*如果二叉树为二叉排序树，那么中序遍历该树应该输出有序结果，
  每次输出的值应该比其前驱的值要大，否则不是二叉排序树 */

KeyType predt=-32767;
int JudgeBST(BiTree bt){
    int b1,b2;
    if(bt==NULL)
        return 1;
    else{//中序遍历
        b1=JudgeBST(bt->lchild);
        if(b1==0||predt>=bt->data)//前驱大于后面一个则不是
            return 0;
        predt=bt->data;//保留当前节点的关键字
        b2=JudgeBST(bt->rchild);
        return b2;
    }
}
//非递归
#define max 999
#define min -999
int judge(BiTree bt){
    BiTNode *S[max],*p=bt;
    int top=0,preval=min;
    while(p||top>0){
        if(p){					//左
            s[++top]=p;
            p=p->lchild;
        }
        else{
            p=s[top--];
            //visit(p);			//中
            if(preval>p->data)
                return 0;
            preval=p->data;
            p=p->rchild;			//右
        }
    }
    return 1;
}
```

### 复制一颗二叉树🚦

```c
btree *copy(btree *b){
    btree *p;
    if(b!=NULL){
        p=(btree*)malloc(sizeof(btree));
        p->data=b->data;
        p->left=copy(b->left);
        p->right=copy(b->right);
        return(p);
    }
    else return(NULL);
}
```

### 二颗二叉排序树合并一颗🚦

```c
//二颗二叉排序树合并一颗
//按照后序遍历逐个连接到另外一颗树上
void BSTreeMerge(BiTree &T,BiTree &s){
    if((s->lchild)) BSTreeMerge(T,s->lchild);//合并左子树
    if((s->rchild)) BSTreeMerge(T,s->rchild);//合并右子树
    insertNode(T,S);						//根
}
void insertNode(BiTree &T,BTNode &s){//把树节点S插入到T
    if(S->data>T->data){
        if(!T->rchild) T->rchild=S;
        else insertNode(T->rchild,S);
    }
    else if(S->data<T->data){
        if(!T->lchild) T->lchild=S;
        else insertNode(T->lchild,S);
    }
    S->lchild=NULL;
    S->rchild=NULL;

}
```



### 查找节点📚

```c
typedef struct  node
{
    KeyType  key ; /*关键字的值*/
    struct node  *lchild,*rchild;/*左右指针*/
}BSTNode, *BSTree;
/*在根指针bst所指二叉排序树bst上，查找关键字等于key的结点，
若查找成功，返回指向该元素结点指针，否则返回空指针*/
BSTree  SearchBST(BSTree bst, KeyType key)
{ 
    BSTree q;
    q=bst;
    while(q)
    {
        if (q->key == key) 
            return q;  /*查找成功*/
        if (q->key > key)  
            q=q->lchild;  /*在左子树中查找*/
        else  
            q=q->rchild;  /*在右子树中查找*/
    }
    return NULL; /*查找失败*/
}
```
### 二叉排序树最大最小节点

```c
//二叉排序树，最左下节点最小，最右下最大
//最小
KeyType MinKey(BSTNode *bt){
    while(bt->lchild!=NULL)
        bt=bt->lchild;
    return bt->data;
}
//最大
KeyType MinKey(BSTNode *bt){
    while(bt->rchild!=NULL)
        bt=bt->rchild;
    return bt->data;
}
```

### 输出二叉排序树不小于k的关键字🚦

```c
//输出二叉排序树不小于k的关键字 未测试
void OutPut(SBTNode *bt,KeyType k){
    if(bt==NULL)
        return;
    if(bt->rchild!=NULL)
        OutPut(bt->rchlid,k);//递归输出右子树节点
    if(bt->data>=k)
        printf("%d",bt->data);//只输出大于等于k的节点
    if(bt->lchild!=NULL)
        OutPut(bt->lchlid,k);//递归输出左子树节点
}
```

### 打印X节点的所有祖先（路径）🚦

```c
/*（考几率不大）
算法思想：非递归后续遍历，最后访问根节点，访问到值为X的节点时栈中所有元素都是该节点的祖先，依次出栈打印
*/
typedef struct{
    BiTree t;
    int tag;
}stack;	//	tag=0表示左子女被访问，tag=1表示右子女被访问
void Search(BiTree bt,ElemType x){
    stack s[];
    top=0;
    while(bt!=NULL||top>0){
        while(bt!=NULL&&bt->data!=x){	//节点入栈
            s[++top].t=bt;
            s[top].tag=0;	//沿左分支向下
            bt=bt->lchild;
        }
        if(bt->data==x){
            for(int i=1;i<=top;i++)
                printf("%d",s[i].t->data);
            exit(1)	//输出结束
        }
        while(top!=0&&s[top].tag==1)
            top--;	//退栈空遍历
        if(top!=0){
            s[top].tag=1;
            bt=s[top].t->rchild;	//沿右分支向下
        }
            
    }
}
//递归 遇到x返回true，左右子树有一方为true，返回上一层为true
initial stack;//只是为了从根到节点,不要也可以
bool Ancesstors(Node *root,int x){
    if(!root) return;
    if(root->data==x)return true;
    if(Ancesstors(root->lchild,x) || Ancesstors(root->rchild,x)){
        //非空非x压栈
        stack.push(root->data);
        return true;//返回上一层
    }
    return false;//没找到
}
//最近公共祖先
BiTree getLCA(BiTree T,BiTNode *p,BiTNode *q){
	if(T==NULL) //如果T为空，返回NULL
	   return NULL;
    if(T==p||T==q)//如果T等于p或q，返回该结点
       return T;
   	BiTNode *left=getLCA(T->lchild,p,q);//沿着左子树遍历
   	BiTNode *right=getLCA(T->rchild,p,q);//沿着右子树遍历
	if(left&&right)//如果左右结点都不空，找到，返回T
	   return T;
    else if(left==NULL)//如果左子树为空，返回右子树的查找结果
       return right;
    else               //否则，返回左子树的查找结果
       return left;
}
```

根到路径

### 19.二叉树带权路径长度WPL

```c
//类型定义
typedef struct BiTNode{
    int weight;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

int WPL(BiTree root){
    reruen wpl_PreOrder(root,0);
}
int wpl_PreOrder(BiTree root,int deep){
    static int wpl=0;
    if(root->lchild==NULL&&root->rchild=NULL)
        wpl+=deep*root->weigth;//若为叶节点累积wpl
    if(root->lchild!=NULL)
        wpl_PreOrder(root->lchild,deep+1);
    if(root->rchild!=NULL)
        wpl_PreOrder(root->rchild,deep+1);
    return wpl;
}
```



### 定义huffman编码的结构

```c++
//定义huffman编码的结构 
struct HuffManCode {
	参考树结构和遍历
};
```

## 查找

#### 顺序查找算法

```c
typedef struct grade
{
	int key;
}node;
int SeqSearch(SeqList R,int n,KeyType k) //顺序查找算法
{
    int i=0;
    while (i<n && R[i].key!=k) 
 {
  printf("%d ",R[i].key);
  i++;     //从表头往后找
 }
    if (i>=n) 
  return -1;
    else 
 {
  printf("%d",R[i].key);
  return i;
 }
}
```

#### 折半查找✨📚📝

```c
int Binsearch(int A[], int low, int high, int k) { 
    int mid; 
    while (low < high) { 
        mid = (low+high) / 2; 
        if (A[mid] == k) { 
            return mid; 
        } 
        else if (A[mid] > k) {
            high = mid - 1; 
        }
        else { 
            low = mid + 1; 
        } 
    }return 0; 
}

//递归
int Besearch(sqlist r,int j,int k){
    int m;
    if(i>j) return(-1);
    else{
        m=(i+j)/2;
        if(r[m].key==k)
            return m;
        if(r[m].key>k)
            return(Besearch(r,i,m-1));
        else
            return(Bserach(r,m+1,j));  
    }
}
```

## 排序

### 类型定义

```c
#define n 10
typedef int Element;
typedef struct{
    Element key;  //主关键字
}node;

void show(node A[]){
    for(int i=0;i<n;i++){
        printf("%3d",A[i].key);
    }
    printf("\n");
}
```

### 插入排序

#### 直接插入✨📚

```c
//********************************************
//直接插入排序    &&写过程
//********************************************
void InsertSort(int a[]) { 
	int i, j,temp; 
	for (i = 1; i < n; i++) { 
		if (a[i] < a[i-1]) { //若A[i]小于前驱移到
			temp = a[i]; 
			for (j = i; a[j-1] > temp && j >= 1;j--) { //有序表里
				a[j] = a[j-1]; //向后挪位 j的值temp保存
			}
			a[j] = temp; 
		}
	} 
}

void Sort(LinkList &L){
    LNode *p=L->next,*pre;
    LNode *r=p->next;		//r保持*p后继指针保证不断链
    p->next=NULL;			//构造只含一个数据节点的有序表
    p=r;					//断开一个后拿到其后面
    while(p!=NULL){
        r=p->next; 			//保存*p的后继指针
        pre=L;
        while(pre->next!=NULL && pre->next->data<p->data)
            pre=pre->next;	//在有序表中查找插入*p的前驱节点*pre
        p->next=pre->next;	//将*p插入到*pre之后
        pre->next=p;
        p=r;				//扫描原单链表中剩下的节点
    }
}

void InsertSort(node a[]) { 
	int i, j; 
	node temp; 
	for (i = 1; i < n; ++i) { 
		if (a[i].key < a[i-1].key) { 
			temp.key = a[i].key; 
			for (j = i; a[j-1].key > temp.key && j >= 1; --j) { 
				a[j].key = a[j-1].key; 
			}
			a[j].key = temp.key; //减后的j
		}
	} 
}
```



#### 折半插入✨📚

```c
//********************************************
//折半/二分插入排序
//********************************************
void BinInsertSort(int A[]){
	int i,j,low,mid,high,temp;
	for(i=1;i<n;i++){		//	如果采用哨兵将A[0]给哨兵循环向后加1
		temp=A[i];
		low=0;high=i-1;		//二分查找
		while(low<=high){
			mid=(low+high)/2;
			if(temp<A[mid]) 
				high=mid-1;
			else
				low=mid+1;
		}
		for(j=i-1;j>=high+1;j--) //    想象  high j| low i 停
			A[j+1]=A[j];  //后移
		A[j+1]=temp;	  //插入 j和high相等
	}
}
```

#### 希尔排序

```c
//********************************************
//希尔排序
//********************************************
void ShellSort(int a[]) { 
	int i, j,temp,d;
	for(d=n/2;d>0;d/=2){
        //// 下面的内容就是插入排序中所有的1改为d，一共有5处修改，别忘了j-=d也要改
		for (i = d; i < n; i++) { 
			if (a[i] < a[i-d]) { 
				temp = a[i]; 
				for (j = i; a[j-d] > temp && j >= d; j-=d) { 
					a[j] = a[j-d]; 
				}
				a[j] = temp; 
			}
		} 
	}
	
}
```



### 交换排序

#### 冒泡排序✨

```c
//********************************************
//冒泡排序
//********************************************
void Bubblesort(node A[]){
    int i,j;
    node t;
    for(i=0;i<n-1;i++)
    {	int flag=1;
        for(j=n-1;j>i;j--)
        {
            if (A[j-1].key > A[j].key)
            {
                t = A[j-1];
                A[j-1] = A[j]; 
                A[j] = t;
				flag=0;
            }
        }
		if(flag) return;
    }
    show(A);
}

//双向冒泡
void BubbleSort(ElemType A[],int n){
    int low=0,hight=n-1;
    bool flag=true;
    while(low<high&&flag){
        flag=false;
        for(i=low;i<high;i++)//从前向后冒泡
            if(a[i]>a[i+1]){
                swap(a[i],a[i+1]);
                flag=true;
            }
        high--;//更新上界
        for(i=high;i>low;i--)//从后往前冒泡
            if(a[i]<a[i-1]){
                swap(a[i],a[i-1]);
                flag=true;
            }
        low++;
    }
}
```

#### 快速排序✨📚📝

```c
//********************************************
//快速排序1   要求写时间复杂度
//********************************************
int Partition(int A[], int low, int high){
	int pivot=A[low];   //枢轴
	while(low<high){
		while(low<high&&A[high]>=pivot)
			high--;				//--high
		A[low]=A[high]; //比枢轴小的元素移到左端
		while(low<high&&A[low]<=pivot)
			low++;				//++low
		A[high]=A[low]; //比枢轴大的元素移到右端
	}
	A[low]=pivot;  		//将枢轴元素存放到最终位置
	return low;
}

void QuickSort(int A[], int low, int high){
    if (low < high)
    {
		int pivotpos=Partition(A,low,high);
		QuickSort(A, low, pivotpos - 1);//递归地对temp左边的关键字进行排序
        QuickSort(A, pivotpos+1, high);//递归地对temp右边的关键字进行排序

    }
}

//要求改变遍历方向枢轴的情况下建议用这个改
//********************************************
//快速排序2
//********************************************
void QuickSort(node a[], int low, int high)
{
    node temp;
    int i = low, j = high;
    if (low < high)
    {
        temp.key = a[low].key;//记录第一个数作为枢轴
        //将小于枢轴的关键字放在枢轴左边，将大于枢轴的关键字放在枢轴右边
        while(i < j)
        {
            //从右向左扫描，如果右边的数比枢轴大，位置不变，j向左移动
            while (j > i && a[j].key >= temp.key)//一趟时>=0
                --j;
            //把要交换的关键字覆盖掉枢轴所对应的i的位置，i右移一位
            if (i < j)//一趟时省略
            {
                a[i].key = a[j].key;
                ++i;
            }
            //从左往右扫描，如果左边的数枢轴小，位置不变，i向右移动
            while (i < j && a[i].key <= temp.key)//一趟时<0
                ++i;
            //把要交换的关键字覆盖掉枢轴所对应的j的位置，j左移一位
            if (i < j)//一趟时a[i],a[j]交换
            {
                a[j].key = a[i].key;
                --j;
            }
            a[i].key = temp.key;//把枢轴的空缺补上
            QuickSort(a, low, i - 1);//递归地对temp左边的关键字进行排序
            QuickSort(a, i+1, high);//递归地对temp右边的关键字进行排序
        }
    }
}
```

### 选择排序

#### 选择排序🚦📝

```c
//********************************************
//直接选择排序
//********************************************
void selectsort(node A[])
{
    int i,j,min;
    node t;
    for(i=0;i<n-1;i++)
    {
        min=i;
        for(j=i+1;j<n;j++)//寻找本轮中的最小值
        {
            if(A[min].key>A[j].key) //记下最小值的位置
                min=j;
        }
        //把DATA[i]和最小值DATA[k]交换
        if(min!=i)
        {t=A[i];A[i]=A[min];A[min]=t;}
    }
    show(A);
}
typedef struct node{
    int data;
    struct node *next;
}Lnode,*link;
void Selctsort(link L){
    link p,q,minp;
    int temp;
    p=L->next;
    while(p!=NULL){
        minp=p;
        q=p->next;
        while(q!=NULL){
            if(q->data<minp->data)
                minp=q;
            q=q->next;
        }
        if(p->data>minp->data){//换值
            temp=p->data;
            p->data=minp->data;
            mip->data=temp;
        }
        p=p->next;
    }
}





//每次找出最大节点，头插法到头部 ->升序排序 或每次找出最小节点，尾插法
void selectSort(LinkedList &L){
    //对不带头结点的单链表L执行简单选择排序
    LinkNode *h=L,*p,*pre,*maxp,*maxpre;
    L=NULL;
    while(h!=NULL){
        p=maxp=h;pre=maxpre=NULL;
        //maxp和maxpre记忆最大节点和其前驱 p为工作指针，pre为前驱
        while(p!=NULL){
            if(p->data>maxp->data){//找最大节点
                maxp=p;
                maxpre=pre;
            }
            pre=p;
            p=p->next;
        }
        if(maxp==h)					//	换节点
            h=h->next;				//最大节点在原链表前端无序第一个
        else
            maxpre->next=maxp->next;	//最大节点在原链表表内，断开P节点
        maxp->next=L;					//节点s头插法插入结果链前端
        L=s;
    }
}
```

#### 堆排序 

```c
//手写过程p315
//对初始序列建立大根堆
void BuildMaxHeap(int A[], int len){
    for(int i=len/2; i>0; i--)   //从后往前调整所有非终端结点
        HeadAdjust(A, i, len);
}

/*将以k为根的子树调整为大根堆
从最底层的分支结点开始调整*/
void HeadAdjust(int A[], int k, int len){
    A[0] = A[k];                      //A[0]暂存子树的根结点
    for(int i=2*k; i<=len; i*=2){     //沿key较大的子结点向下筛选
                                      // i为当前所选根结点的左孩子
                                      //i*=2是为了判断调整后再下一层是否满足大根堆
        if(i<len && A[i]<A[i+1])      //判断：当前所选根结点的左、右结点哪个更大
            i++;                      //取key较大的子结点的下标
        if(A[0] >= A[i]) 
            break;                    //筛选结束：i指向更大的子结点
        else{
            A[k] = A[i];              //将A[i]调整至双亲结点上
            k=i;                      //修改k值，以便继续向下筛选
        }
    }
    A[k] = A[0];                      //被筛选的结点的值放入最终位置
}

//交换
void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}

//基于大根堆进行排序
void HeapSort(int A[], int len){
    BuildMaxHeap(A, len);          //初始建堆
    for(int i=len; i>1; i--){      //n-1趟的交换和建堆过程
        swap(A[i], A[1]);          //堆顶元素和堆底元素交换
        HeadAdjust(A,1,i-1);       //把剩余的待排序元素整理成堆
    }
}
```



### 归并排序✨📚📝

```c
//********************************************
//归并排序 
//********************************************
  int *B=(int *)malloc((n+1)*sizeof(int));
  void Merge(int A[],int low,int mid,int high){
	  int i,j,k;
	  for(k=low;k<=high;k++)
		  B[k]=A[k];       //将A元素复制到B
	  for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){
		  if(B[i]<=B[j])   //比较B左右两段
			  A[k]=B[i++]; //将较小值复制到A中
		  else
			  A[k]=B[j++];
	  }
	  while(i<=mid)   A[k++]=B[i++];//检测第一个表
	  while(j<=high)  A[k++]=B[j++]; //检测第二个表
  }
  void MergeSort(int A[],int low,int high){
	  if(low<high){
		  int mid=(low+high)/2;
		  MergeSort(A,low,mid);
		  MergeSort(A,mid+1,high);
		  Merge(A,low,mid,high);

	  }
  }
```





### 2020 

一、算法分析题(70 分) 

1、一个栈 s 进行如下操作, push(1), push(2), pop(), push(3), pop(), push(4),  

pop(), push(5), pop().求最终输出的序列。(10 分) 

```2,3,4,5   栈中留有1
2,3,4,5   栈中留有1
```

2、某二叉树的先序遍历为 ABHFDECKG，中序遍历为 HBDFAEKCG，画出该二叉 

树。(10 分)

 <img src="D:\数据结构\IMG\1png" alt="1634296582293" style="zoom:50%;" />

3、给出一个图，根据图采j用 Prim 算法画出一个生成子图，要求给出每一步的执 

行过程。(10 分)

 <img src="D:\数据结构\IMG\3.png" style="zoom:80%;" />

<img src="D:\数据结构\IMG\3.1.png" alt="3.1" style="zoom:50%;" />

4、将给定的关键字集{47,7,29,11,16,92,22,8,3,18,27,25,40}用长度为 13 的哈希  p<=13 

表存储，用线性探测法处理冲突。画出该哈希表，并求出该表的 ASL。(10 分)

5、根据给定的 a-g 的概率构造霍夫曼树并求其编码（权值小的在左边）。(10 分) <img src="D:\数据结构\IMG\2.PNG" style="zoom: 67%;" />

6、记录的关键字序列为{63,90,70,55,67,42,98,83,10,45,58}，画出给定序列的二 

叉排序树，并画出删除结点 70 之后的排序树。(10 分) 

<img src="D:\数据结构\IMG\4.png" alt="4" style="zoom:50%;" />

<img src="D:\数据结构\IMG\5.png" style="zoom:50%;" />

7、写出给定序列{67,38,29,56,53,95,48,12}的递增快速排序的每一趟排序的结果。 

(10 分) 

​      67,38,29,56,53,95,48,12

1️⃣	[12,38,29,56,53,48],67,[95]

2️⃣	12,[38,29,56,53,48],67,[95]

3️⃣	12,29,[38],[56,53,48],67,[95]

4️⃣	12,29,38,[56,53,48],67,[95]

5️⃣	12,29,38,[48,53],56,67,[95]

6️⃣	12,29,38,48,[53],56,67,[95]

7️⃣	12,29,38,48,53,56,67,[95]

8️⃣	12,29,38,48,53,56,67,95

二、算法设计题(80 分) 

1.、写出顺序表的结构体，并设计在顺序表 L 中第 pos 位置上插入一个元素 e 的 

算法，默认数据类型为整型。(15 分) 

```c
#define MaxSize 10      //定义最大长度 
typedef struct{
    ElemType data[MaxSize];  //用静态的“数组”存放数据元素 
    int Length;         //顺序表的当前长度
}SqList; 
//在L位序为i处插入元素e
bool ListInsert(SqList &L, int i, int e){ 
    //判断i的范围是否有效
    if(i<1||i>L.length+1) 
        return false;
    if(L.length>MaxSize) //当前存储空间已满，不能插入  
        return false;
     
    for(int j=L.length; j>i; j--){    //将第i个元素及其之后的元素后移
        L.data[j]=L.data[j-1];
    }
    L.data[i-1]=e;  //在位置i处放入e
    L.length++;      //长度加1
    return true;
}
```



2、写出链表的结构体，并设计在链表中删除指定元素 e 的算法，假设元素 e 在链 

表之中，默认数据类型为整型。(15 分) 

```c
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode, *LinkList;
//删除带头结点的单链表中值为x的结点
void delX(LinkList &L,int e){
    LNode *p=L->next,*pre=L,*q;//pre指向p的前驱
    while(p!=NULL){
            if(p->data==e){
				q=p;
                p=p->next;//注意这里删除分开是保留p
                pre->next=p; //删除q节点
                free(q);      
           }
            else{			 
				pre=p;      // pre 和 p 同步后移
                p=p->next; 
                }
        }
}
```



3、设计一个算法将给定的十进制数转化为二进制数。给定默认操作 Initial_stack()； 

Is_ empty_stack(s)；Push()；Pop()，利用这几个栈操作实现。(15 分) 

```c
void Convert(int x){
    Initial_stack(s);
    while(x!=0){
        Push(s,p%2);
        p=p/2;
        }
    while(!Is_ empty_stack(s))
          x=x*10+Pop(s);
}
```



4、设计在二叉排序树中查找结点值为 e 的算法。(15 分) 

```c
typedef struct  node
{
    KeyType  key ; /*关键字的值*/
    struct node  *lchild,*rchild;/*左右指针*/
}BSTNode, *BSTree;

BSTree  SearchBST(BSTree T, KeyType key)
{ 
    BSTree p=T;
    while(p)
    {
        if (p->key == key) 
            return q;  /*查找成功*/
        if (p->key > key)  
            p=p->lchild;  /*在左子树中查找*/
        else  
            p=p->rchild;  /*在右子树中查找*/
    }
    return NULL; /*查找失败*/
}
```



5、设计将 a[n]数组采用归并方式排序的算法。(20 分)

```c
//********************************************
//归并排序 
//********************************************
  int *B=(int *)malloc((n+1)*sizeof(int));
  void Merge(int A[],int low,int mid,int high){
	  int i,j,k;
	  for(k=low;k<=high;k++)
		  B[k]=A[k];       //将A元素复制到B
	  for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){
		  if(B[i]<=B[j])   //比较B左右两段
			  A[k]=B[i++]; //将较小值复制到A中
		  else
			  A[k]=B[j++];
	  }
	  while(i<=mid)   A[k++]=B[i++];//检测第一个表
	  while(j<=high)  A[k++]=B[j++]; //检测第二个表
  }
  void MergeSort(int A[],int low,int high){
	  if(low<high){
		  int mid=(low+high)/2;
		  MergeSort(A,low,mid);
		  MergeSort(A,mid+1,high);
		  Merge(A,low,mid,high);

	  }
  }
```



### 2021

1.写顺序表类型定义，顺序表的插入和删除。 

2.写链式堆栈类型定义，编程写出入栈和出栈。 

3.给定权集，构造哈夫曼树，求加权路径长度。 

4.给出序列，构造画出二叉排序树，删除其中一个节点后的二叉排序树。 

**中序前驱或者后继补**

5.有图，邻接矩阵，画图。利用普里姆算法写出最小生成树，利用 Dijkstra 算法求各 结点的最短路径。 

6.有向图，画图写出所有拓扑结构。例

<img src="D:\数据结构\IMG\拓扑排序.png" style="zoom:50%;" /> 

```
拓扑序列 
ABCFDEG,ABCDFEG,ABCDEFG,ABDCFEG,ABDCEFG
```

7.给出序列，利用归并排序和插入排序，在序列中进行升序排序。写过程。 

8.写快排的代码，求时间复杂度。

```
把n个元素组织成二叉树，二叉树的层数就是递归调用的层数，n个结点的二叉树最小高度 = ⌊log₂n⌋ + 1, 最大高度 = n

时间复杂度 = O(n×递归层数) （递归层数最大为n）

最好 = O(nlog₂n) : 每次选的枢轴元素都能将序列划分成均匀的两部分；
最坏 = O(n²) ：序列本就有序或逆序，此时时间、空间复杂度最高；
平均时间复杂度 = O(nlog₂n) （接近最好而不是最坏）
```

9.给出哈希表，哈希函数，权值序列，求利用线性探测法处理冲突的哈希表，求成功查找情况下平均最短路径。



2022

1.时间复杂度

2.插入算法

3.遍历序列

4.二叉树转森林

5.哈夫曼树和路径编码

6.普里姆和克鲁斯卡尔

7.线性探测成功概率

8.快速排序

# 2022

```
1.时间复杂度
2.在线性表某个位置出入一个元素（好像是找到一个然后后移进行插入）
3.二叉树遍历序列（前中后层次）  二叉树转森林和二叉树转树的互相转化
4.构造哈夫曼树，哈夫曼编码
8.求最小生成树 克鲁斯卡尔和普里姆，最短路径 迪杰斯特拉和弗洛伊德（一般没代码）
9.线性探测构造 求成功和不成功概率
10.快速排序
```



## 图例

✨ 考过

🚦参考书习题有

📚改后考过

📝期末考试出现过