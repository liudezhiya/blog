# ChineseWhisper

适用场景：未知具体分类数量，自动查找类别个数并进行快速聚类。增大类间距离，减小类内距离

 算法思想：

```
初始化：将所有的样本点初始化为不同的类，自下而上的进行聚类
	   迭代开始时,将每个节点都赋予一个id,该id作为该节点的类别,也就是说初始化时,每个节点都是一个类别

建图：根据样本点之间的距离，设定相似度，低于相似度阈值的两个样本点之间建立边，高于阈值则无边，由此构建加权无向图，边的权重为相似度
		
迭代：
①随机选取一个节点i开始，在其相连节点中选取边权重最大者j, 并将i归为节点j类（若相连节点中有多个节点属于同一类，则将这些权重相加再做比较）
		a 如果是初始化的时候,由于每个节点都有自己所属的类别,就将所有邻居中权重最大的节点对应的类做为该节点的类别,完成对该节点的类别更新
		b 如果迭代到第2次,那么对某个节点,就可能会出现有两个邻居属于同一个类,那么就将同一个类下的邻居权重累加,最后,再看该节点下的所有邻居节点所属的类别			的累加权重,取权重最大的类别作为当前节点的类别.
②遍历所有节点后，重复迭代至满足迭代次数
```



# Kmeans

 算法思想:一种典型的基于距离的算法，它以距离作为评价相似度的指标。两个对象的距离越近，则相似度也就越大 。

```
①随机选取K个聚类中心点。基于这k个中心点计算每个对象到中心点的距离，并将对象划分成其离最短的那个中心点的那一个类别，也就是第一轮迭代就根据选取的中心点将对象划分成了k类。
②对每一个类重新计算中心点，也就是中心点根据上一轮迭代的类别进行重算，得到新的k个中心点。

③基于新的中心点，开始新的聚类迭代，重新计算每个对象离中心点的距离，并划分成最短距离的中心点所对应的类别。

④重复第2和第3步，直到新的中心点与原来的中心点相等或者小于指定的阈值。
```



# Louvain

 算法思想

```
将图中的每个节点看成一个独立的社区，次数社区的数目与节点个数相同；2）对每个节点i，依次尝试把节点i分配到其每个邻居节点所在的社区，计算分配前与分配后的模块度变化Δ ，并记录Δ 最大的那个邻居节点，如果 Δ >0，则把节点i分配Δ 最大的那个邻居节点所在的社区，否则保持不变；3）重复2），直到所有节点的所属社区不再变化；4）对图进行压缩，将所有在同一个社区的节点压缩成一个新节点，社区内节点之间的边的权重转化为新节点的环的权重，社区间的边权重转化为新节点间的边权重；5）重复1）直到整个图的模块度不再发生变化。

模块度（Modularity）是一种常用的衡量节点分组质量的标准，模块度越高说明所检测到的社团越符合“内紧外松”的特征，分组质量越好。模块度越大，挖掘的社区内部连接越紧密，效果越好
```





# Newman

GN(Girvan-Newman)算法

算法思想：根据图的边介数中心性(Edge Betweenness Centrality,EBC)值，通过迭代去除图的边来发现图中的社区。边介数中心性最大的边最先被移除。

 ```
 Girvan-Newman算法的详细步骤：
 
 （1）计算网络中所有边的中介中心性；
 
 （2）去除中介中心性最高的边；
 
 （3）重新计算去除边后的网络中所有边的中介中心性；
 
 （4）跳至步骤2，重新计算，直至网络中没有边存在。
 
 Girvan-Newman算法所得到的结果实质上是网络中节点的树图（dendrogram）
 
 该算法给出了如何去除边得到社群结构。但在得到最终的社群数之前，还有一个问题没有得到解决，即如何确定合适的社群数，使社群划分结果最优。在他们随后的文章(Newman and Girvan 2004)中提出了Modularity Q的概念（见上个算法），并形成一个更为完整的方法。
 
 Q值能够体现网络划分为社群后社群结构的质量，该值逼近于1，说明社群结构越明显，该值逼近于0则社群结构不明显。对于同一个网络而言，不同算法可能得到的Q值不同，Q值高则代表了该算法较优。利用Q值寻找合适的社群数的思路如下：
 
 在上面Girvan-Newman算法中每去除一次边，则计算一下所得社群结构的Q值，寻找到Q值最大时的社群数量。一般而言，计算时不可能会在所有去边过程中都计算Q值，往往是寻找某一区间的Q值，取得局部最大值即可。Q一般有1-2次局部最大值。
 
 ```



 

# WeakCommpent

算法思想：生成 G 的弱连接组件，针对有向图

```python
seen = set()
for v in G:
    if v not in seen:
        c = _plain_bfs(G, v)
        seen.update(c)
        yield c
        
 def _plain_bfs(G, source):
    G_adj = G.adj
    seen = set()
    nextlevel = {source}
    while nextlevel:
        thislevel = nextlevel
        nextlevel = set()
        for v in thislevel:
            if v not in seen:
                seen.add(v)
                nextlevel.update(G_adj[v])
    return seen
```

## StrongCommpent

有向图的强连接性。有向图是强连接的，当且仅当中的每个顶点 可从每隔一个其他顶点访问该图形。

## Commpent

无向图 

# Bicomponet